<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Git és GitHub gyorstalpaló</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Git és GitHub gyorstalpaló</h1>
</header>
<section data-field="subtitle" class="p-summary">
A fejlesztők körében leginkább elterjedt verziókezelő rendszer a Git. Népszerűségét elsősorban rugalmasságának köszönheti. Olyan…
</section>
<section data-field="body" class="e-content">
<section name="3d4f" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="57bf" id="57bf" class="graf graf--h3 graf--leading graf--title">Git és GitHub gyorstalpaló</h3><p name="606a" id="606a" class="graf graf--p graf-after--h3">A fejlesztők körében leginkább elterjedt verziókezelő rendszer a <a href="https://git-scm.com/" data-href="https://git-scm.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Git</a>. Népszerűségét elsősorban rugalmasságának köszönheti. Olyan rendszerek alapja, mint például a <a href="https://github.com/" data-href="https://github.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>, ami a nyílt forrású projektek legnagyobb gyűjtőhelye. Ezt a cikket egy nagyon rövid bevezetőnek szánom, ami segít megérteni a Git működését, és azt, hogy hogyan járulhatunk hozzá nyílt forrású projektek fejlesztéséhez a GitHub-on. Ahhoz, hogy a Git működését megértsük, érdemes kicsit benézni a motorháztető alá…</p><figure name="5044" id="5044" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cgqGLrPj_zqQync3l0dv5w.jpeg" data-width="5000" data-height="3750" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*cgqGLrPj_zqQync3l0dv5w.jpeg"><figcaption class="imageCaption">Kép forrás: <a href="http://www.freepik.com" data-href="http://www.freepik.com" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">www.freepik.com</a>, szerző: kjpargeter</figcaption></figure><p name="3167" id="3167" class="graf graf--p graf-after--figure">A Git-et legegyszerűbben egy fájlrendszerként képzelhetjük el. Amikor létrehozunk egy verziót (<strong class="markup--strong markup--p-strong">commit</strong>), egyszerűen fogjuk a projekt aktuális változatát, és kimásoljuk egy könyvtárba, aminek a neve a felhasználói nevünkből és egy dátumból áll össze. Mondjuk valami ilyesmi: TheBojda_201902242053. Aztán fejlesztgetünk tovább, és ha megint úgy gondoljuk, létrehozunk egy új verziót, vagyis megint kimásoljuk az aktuális fájlokat egy könyvtárba. A verziókat aztán visszanézhetjük, megnézhetjük mi változott, vagy visszatérhetünk egy régebbi verzióra ha szükséges. A verziókon kívül van egy másik fogalom is Git-ben, az ág (<strong class="markup--strong markup--p-strong">branch</strong>). Ha létrehozunk egy ágat, akkor az egész projektet verziókkal együtt kimásoljuk egy külön könyvtárba, aminek szabadon választható nevet adhatunk. A Git tehát egy olyan fájlrendszer, ami branch-eket tartalmaz (ezeket most képzeljük könyvtáraknak), amin belül commitok (verziók — ezeket is képzeljük könytáraknak a branch-eken belül) vannak. Mivel mindig valamilyen branch alatt vagyunk, ezért létezik egy alapértelmezett branch, amit <strong class="markup--strong markup--p-strong">master</strong>-nek hívnak.</p><p name="541c" id="541c" class="graf graf--p graf-after--p">Persze ha a Git egyszerű fájlrendszer lenne, rengeteg helyet foglalna. Ha van például egy PHP alapú oldalunk ami 10Mb helyet foglal, és csinálunk belőle 10 commitot, amiből aztán létrehozunk 10 branch-et, az 1Gb-nyi helyet foglalna el a merevlemezünkön. Szerencsére a Git nem átlagos fájlrendszer, sokkal inkább hasonlít az IPFS-re.</p><blockquote name="fc23" id="fc23" class="graf graf--blockquote graf-after--p">Az IPFS-ről nemrég írtam egy <a href="https://medium.com/envienta-magyarorsz%C3%A1g/interplanetary-file-system-ipfs-92d354d522c0" data-href="https://medium.com/envienta-magyarorsz%C3%A1g/interplanetary-file-system-ipfs-92d354d522c0" class="markup--anchor markup--blockquote-anchor" target="_blank">cikket</a>, amit mindenképp érdemes elolvasni, ha valakit érdekelnek a részletek.</blockquote><p name="10be" id="10be" class="graf graf--p graf-after--blockquote">Dióhéjban annyi a lényeg, hogy az olyan hash alapú fájlrendszerek, mint az IPFS vagy a Git egy adott fájlt csak egyszer tárolnak, akárhány példány is legyen belőle a fájlrendszerben. Innentől kezdve nem érdekes, hogy hány verziót vagy branch-et hozunk létre, ezek szinte semmi helyet nem foglalnak, hiszen csak a megváltozott fájlokat kell pluszban eltárolnunk. A Git ráadásul tud még egy trükköt. Képes a tárolót egyetlen pack fájlba tömöríteni, ami az egyes fájl változatok közötti változásokat tárolja csak, ráadásul ezt is tömörített formában. Ennek az okos tárolásnak köszönhetően nagyon gyorsan és minimális tárhely felhasználás mellett készíthetünk branch-eket. Úgy is szokták mondani, hogy a Git esetén “olcsó” a branch-elés, amit a Git-et használó fejlesztők erősen ki is hasznának (erre később látunk majd példát). A Git a branch-eket és a verziókat a fent leírt tömörített formában a <strong class="markup--strong markup--p-strong">.git</strong> köyvtárban tárolja. Ha dolgozni akarunk egy változattal, azt ki kell bontanunk. Ezt hívjuk <strong class="markup--strong markup--p-strong">checkout</strong>-nak.</p><p name="a56e" id="a56e" class="graf graf--p graf-after--p">Persze az egész rendszer nem sokban segítené a közös munkát, ha csak egy lokális fájlrendszer lenne. Éppen ezért a Git lehetőséget biztosít ilyen lokális tárolók (<strong class="markup--strong markup--p-strong">repository</strong>-k) szinkronizálására. Ennek két módja lehet: a tároló áthúzása (<strong class="markup--strong markup--p-strong">pull</strong>) és áttolása (<strong class="markup--strong markup--p-strong">push</strong>). Maga a tároló lehet a fájlrendszer egy másik pontján, vagy egy távoli gépen, amit HTTP(S)-en vagy SSH-n érhetünk el. Ez a két legelterjedtebb metódus a távoli tárolók elérésére, de a Git flexibilis felépítésének köszönhetően más megoldások (pl. <a href="https://medium.com/@alexberegszaszi/mango-git-completely-decentralised-7aef8bcbcfe6" data-href="https://medium.com/@alexberegszaszi/mango-git-completely-decentralised-7aef8bcbcfe6" class="markup--anchor markup--p-anchor" target="_blank">IPFS támogatás</a>) is szóba jöhetnek.</p><p name="b1b6" id="b1b6" class="graf graf--p graf-after--p">Amikor egy távoli repository-t húzunk le (pull), a Git befésüli a commit listát a helyi tároló listájába, valamint a fájlok aktuális állapotát is megpróbálja összefésülni. Ha szerencsénk van, akkor a távoli repository-ban más fájlok változtak, mint helyben, így nem lesz probléma. Előfordulhat azonban az, hogy velünk egy időben egy másik fejelsztő is ugyanazzal a fájlal dolgozik mint mi és a rendszer nem képes összefésülni a helyi és a távoli változatot. Ekkor ütközés (<strong class="markup--strong markup--p-strong">conflict</strong>) keletkezik, és létrejön egy olyan fájl, ami a két változat összefésülésének eredménye, és meg vannak benne jelölve a problémás részek. Ezeket csak a fejesztő tudja rendbe rakni kézzel, hiszen ehhez érteni kell a kódot. Ha minden conflict feloldásra került, létre kell hozni egy új commitot, ami már a korrekten összefésült (<strong class="markup--strong markup--p-strong">merge</strong>-ölt) változatot tartalmazza.</p><p name="3d95" id="3d95" class="graf graf--p graf-after--p">A fordított irányú szinkronizálás, vagyis a változások áttolása (push) jóval egyszerűbb, hiszen push-olni csak akkor tudunk, ha előtte lehúztuk (pull) a távoli tároló tartalmát és mindent rendberaktunk. A távoli tárolókat <strong class="markup--strong markup--p-strong">remote</strong>-nak nevezzük, és akárhány lehet belőlük. Hivatkozhatunk rájuk URL-el, vagy el is nevezhetjük őket. Azt is megtehetjük, hogy a lokális tárolónkat egy távoli tároló másolásával (<strong class="markup--strong markup--p-strong">clone</strong>) hozzuk létre. Ekkor a távoli tároló tartalma letöltődik a helyi gépünkre, és a fő ág (master branch) legutolsó változata lesz kibontva (checkout) a lokális fájlrendszerbe. Ilyen esetben létrjön egy <strong class="markup--strong markup--p-strong">origin</strong> nevű remote is, ami a forrás URL-re mutat. Ez lesz az alapértelmezett célja a pull/push műveleteknek, ha nem adunk meg más remote-ot.</p><p name="49b6" id="49b6" class="graf graf--p graf-after--p">Most, hogy már szinte mindent tudunk a Git-ről, pár példán keresztül nézzük meg, hogy miként néz ki mindez a gyakorlatban. Arra fogok rövid példát mutatni, hogy hogyan járuhatunk hozzá egy GitHub projekt fejesztéséhez, jelen esetben az <a href="https://github.com/EnvientaGit/EnvientaPlatform" data-href="https://github.com/EnvientaGit/EnvientaPlatform" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ENVIENTA Platformhoz</a>. A GitHub logikája szerint ha szeretnénk beszállni egy projekt fejelsztésébe, ahhoz előszőr le kell másolni (<strong class="markup--strong markup--p-strong">fork</strong>-olni kell) a projektet. Olyan ez mint ha klónoznánk azt a saját felhasználónk alá, de nyilván a GitHub a Git-től ellesett okos tárolást alkalmazza, így a háttérben nem másolódik semmi. Ebből a szempontból a fork olyan mint a branch, csak eggyel magasabb szintű. A lényeg mindebből, hogy a fork után lesz egy saját példányunk, ahol kedvünkre garázdálkodhatunk, hiszen az csakis a miénk. Ahhoz, hogy valami érdemlegeset tudjunk kezdeni a repository-val, le kell azt klónoznunk a saját gépünkre. Ezt a következő git paranccsal tehetjük meg:</p><pre name="97b3" id="97b3" class="graf graf--pre graf-after--p">git clone <a href="https://github.com/TheBojda/EnvientaPlatform.git" data-href="https://github.com/TheBojda/EnvientaPlatform.git" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://github.com/TheBojda/EnvientaPlatform.git</a></pre><p name="1966" id="1966" class="graf graf--p graf-after--pre">Itt persze az URL-t mindenki cserélje le a saját Git tárolójának URL-jére, amit GitHub-on a <em class="markup--em markup--p-em">Clone or download</em> részben találhatunk.</p><p name="ac60" id="ac60" class="graf graf--p graf-after--p">Egy projekthez kéféle módon járulhatunk hozzá. Vagy keresünk egy feladatot (<strong class="markup--strong markup--p-strong">issue</strong>) magunknak, vagy mi találunk ki valami új funkciót, esetleg jelzünk valami hibát, amit egyből javítanánk is. Bárhogy is legyen és bármit is akarnánk csinálni, mindenképp legyen hozzá issue rögzítve a projektnél, tárgyaljuk meg a projekt fejlesztőivel a részleteket, és várjuk meg amíg hozzánk rendelik az issue-t. Ha nem így teszünk, könnyen megeshet, hogy nem fogják befésülni a módosításainkat, vagy kiderül, hogy velünk párhuzamosan más is dolgozott az adott issue-n, így a sok befektetett munka könnyen pocsékba mehet. Viszont ha megkaptuk az issue-t, indulhat a munka. Ehhez előszőr hozzunk létre egy branch-et az issue-hoz (ahogy a cikk elején említettem a Git-et használók szeretnek branch-elgetni). A branch neve akármi lehet. Érdemes valami beszédes nevet választani, és érdemes a névben feltüntetni az issue számát is. Új branch így hozható létre:</p><pre name="dde4" id="dde4" class="graf graf--pre graf-after--p">git checkout -b issue-12</pre><p name="0ace" id="0ace" class="graf graf--p graf-after--pre">A fenti git parancs létrehozza az <em class="markup--em markup--p-em">issue-12</em> nevű branch-et, és checkout-olja is azt, tehát ez a branch lesz aktuálisan kibontva a fájlrendszerbe és minden commit ebbe a branch-be fog menni.</p><p name="94b9" id="94b9" class="graf graf--p graf-after--p">A fejelsztés során bármikor commitolhatunk a <code class="markup--code markup--p-code">git commit</code> paranccsal, de erre kényelmesebb valamilyen grafikus Git klienst használni, illetve a legtöbb IDE is képes kezelni a Git-et. Ha készvagyunk a fejelsztésekkel, toljuk vissza (push) a GitHub-on lévő repository-ba a változásokat.</p><pre name="6429" id="6429" class="graf graf--pre graf-after--p">git push </pre><p name="4660" id="4660" class="graf graf--p graf-after--pre">Miután felkerült a branch a GitHub-ra, létrehozhatunk egy <strong class="markup--strong markup--p-strong">Pull request</strong>-et. A Pull request tulajdonképpen egy üzenet a projekt felé, hogy elvégeztük a feladatot, a kód itt van a mi repository-nkban, és kérjük, hogy húzzák azt át és fésüljék bele a projekt repository-ba. Ha elküldtük a Pull request-et, a fejelsztők át tudják nézni azt, és vagy befésülik a projekt repository-ba, vagy visszadobják, hogy javítsunk még rajta. Ha javítani kellene, akkor újra checkout-olni tudjuk a branch-et, és dolgozhatunk rajta tovább.</p><pre name="d252" id="d252" class="graf graf--pre graf-after--p">git checkout issue-12</pre><p name="4311" id="4311" class="graf graf--p graf-after--pre">Azért jó, hogy minden issue-nak külön branch-e van, mert így akár több feladaton is dolgozhatunk egyszerre. Megeshet például, hogy már elkezdtünk egy új issue-n dolgozni, mikor a projekt egy fejelsztője át tudja nézni az előző kódunkat és visszaküldi nekünk javításra. Miután megvagyunk a módosításokkal, nincs más dolgunk, mint push-olni, és a Pull request automatikusan frissül. Ha a Pull request-et elfogadták, és nincs már szükség az adott issue-hoz kötött <em class="markup--em markup--p-em">feature branch</em>-re, akkor azt a következő paranccsal törölhetjük:</p><pre name="c6c5" id="c6c5" class="graf graf--pre graf-after--p">git branch -d issue-12</pre><p name="6568" id="6568" class="graf graf--p graf-after--pre">Persze rajtunk kívűl mások is dolgozhatnak a projekten, ami folyamatosan fejlődik a Pull request-ek befésülésével. A GitHub nem tudja automatikusan frissíteni a fork-unkat (lehetnek ütözések), így azt nekünk kell megtennünk manuálisan. Ehhez érdemes <strong class="markup--strong markup--p-strong">upstream</strong> néven hozzáadni egy remote-ot, ami a projekt repository-ra mutat.</p><pre name="06c6" id="06c6" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">git remote add upstream </code><a href="https://github.com/EnvientaGit/EnvientaPlatform.git" data-href="https://github.com/EnvientaGit/EnvientaPlatform.git" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://github.com/EnvientaGit/EnvientaPlatform.git</a></pre><p name="982e" id="982e" class="graf graf--p graf-after--pre">Innen már könnyen megoldható a szinkronizálás egy pull-al, ami lehúzza az aktuális változatot az upstream-ről, és egy push-al, ami kitolja azt a mi saját bejáratú fork-olt repository-nkba.</p><pre name="8c0b" id="8c0b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">git pull upstream master<br>git push</code></pre><p name="d109" id="d109" class="graf graf--p graf-after--pre">Körülbelül ennyi lett volna a Git/GitHub gyorstalpaló. Mivel a Git csak az eszközkészletet adja, ezért a fent bemutatott fejlesztési folyamat csak a legegyszerűbb megvalósítás, ami tetszés szerint tovább bonyolítható. A projekt például fenntarthat magának egy development ágat, ahol a fejelsztések gyűlnek, majd bizonyos időközönként létrehozhatnak ezekből egy release-t (itt van erről egy igen részletes leírás: <a href="https://nvie.com/posts/a-successful-git-branching-model/" data-href="https://nvie.com/posts/a-successful-git-branching-model/" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://nvie.com/posts/a-successful-git-branching-model/</a>). Olyan megoldás is elképzelhető, ahol egy nagy projektnél több távoli repository is van. Itt példul a programozók egy csoportját egy vezető programozó fogja össze, és csak ő push-ol tovább a központi repository-ba. Branch-ek és repository-k kusza hálózatán futhatnak végig a fejelsztések, míg végül összeáll a kész szoftver (vagy bármilyen tartalom, akár könyv, stb.), a döntés a fejelsztőkre van bízva.</p><p name="78da" id="78da" class="graf graf--p graf-after--p">A fentiekből remélem jól látszik a Git flexibilitása, és az, hogy miért vált uralkodó verziókezelő rendszerré viszonylag rövid időn belül. Azt is remélem, hogy ebből az írásból sokaknak sikerült megérteniük a rendszer működését és hasznát veszik majd az itt tanultaknak. Tehát kalandra fel! Segítsetek minél több open source projektnek, ezzel is kicsit jobb hellyé téve a világot…</p><p name="0ee2" id="0ee2" class="graf graf--p graf-after--p graf--trailing">Ha valakit mélyebben érdekel a Git működése, itt talál egy nagyon átfogó, ingyenes könyvet róla angolul: <a href="https://git-scm.com/book/en/v2" data-href="https://git-scm.com/book/en/v2" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://git-scm.com/book/en/v2</a></p></div></div></section><section name="e7ac" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="fbc6" id="fbc6" class="graf graf--h3 graf--leading">Kövess minket!</h3><p name="0e27" id="0e27" class="graf graf--p graf-after--h3">Az #ethereumtudas cikksorozat előző és következő részeiben az okos szerződésekkel ismerkedünk meg közelebbről, miközben megtanuljuk azt is, hogy hogyan készíthetünk ilyeneket mi magunk is.</p><p name="4df4" id="4df4" class="graf graf--p graf-after--p">Hogy mindez tényleg felfogható lehessen a cikksorozatot ketten írjuk. A programozói részekért jómagam <a href="https://medium.com/u/792a8f999852" data-href="https://medium.com/u/792a8f999852" data-anchor-type="2" data-user-id="792a8f999852" data-action-value="792a8f999852" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Laszlo Fazekas</a> (fejlesztő) felelek, azért pedig, hogy tényleg minden érthető legyen <a href="https://medium.com/u/f91cbcd0bc44" data-href="https://medium.com/u/f91cbcd0bc44" data-anchor-type="2" data-user-id="f91cbcd0bc44" data-action-value="f91cbcd0bc44" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Gabriel Varaljay</a> (marketing) “játssza a naivat” (tesz fel kérdéseket, magyarázza újra a feldolgozott anyagot).</p><p name="3dcb" id="3dcb" class="graf graf--p graf-after--p graf--trailing">Amennyiben érdekel ez a témakör érdemes feliratkoznod <a href="https://medium.com/envienta-magyarország" data-href="https://medium.com/envienta-magyarország" class="markup--anchor markup--p-anchor" target="_blank">ERRE a medium csatornára</a>, de követheted az ENVIENTA Magyarországot <a href="https://twitter.com/envientahun" data-href="https://twitter.com/envientahun" class="markup--anchor markup--p-anchor" rel="nofollow noopener nofollow noopener nofollow noopener nofollow noopener nofollow noopener nofollow noopener noopener" target="_blank">Twitteren</a>, vagy akár csatlakozhatsz a <a href="https://www.facebook.com/groups/1459500857429638/" data-href="https://www.facebook.com/groups/1459500857429638/" class="markup--anchor markup--p-anchor" rel="nofollow noopener nofollow noopener nofollow noopener nofollow noopener nofollow noopener nofollow noopener noopener" target="_blank">tematikus Facebook csoportunkhoz</a> is.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/f2d78a732deb"><time class="dt-published" datetime="2019-03-06T12:01:01.084Z">March 6, 2019</time></a>.</p><p><a href="https://medium.com/@thebojda/git-%C3%A9s-github-gyorstalpal%C3%B3-f2d78a732deb" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 14, 2020.</p></footer></article></body></html>