<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>React Native alapozó</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">React Native alapozó</h1>
</header>
<section data-field="subtitle" class="p-summary">
avagy mobilalkalmazás fejlesztés (nem csak) webfejlesztőknek
</section>
<section data-field="body" class="e-content">
<section name="6edc" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="061b" id="061b" class="graf graf--h3 graf--leading graf--title">React Native alapozó</h3><h4 name="f0d0" id="f0d0" class="graf graf--h4 graf-after--h3 graf--subtitle">avagy mobilalkalmazás fejlesztés (nem csak) webfejlesztőknek</h4><figure name="b154" id="b154" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*GBg6Nv-NUhEU-I7YarxxcA.png" data-width="880" data-height="495" src="https://cdn-images-1.medium.com/max/800/1*GBg6Nv-NUhEU-I7YarxxcA.png"><figcaption class="imageCaption">Forrás: <a href="https://hackernoon.com/benefits-of-react-native-for-cross-platform-app-development-0gm30aa" data-href="https://hackernoon.com/benefits-of-react-native-for-cross-platform-app-development-0gm30aa" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://hackernoon.com/benefits-of-react-native-for-cross-platform-app-development-0gm30aa</a></figcaption></figure><p name="8782" id="8782" class="graf graf--p graf-after--figure">Időm nagy részében android fejlesztőként dolgozom és arra gondoltam keresni kéne valami eszközt amivel könnyen összedobhatok iOS appokat is ha szükséges. Az Objective-C-t próbáltam megszeretni, de nem igazán sikerült. A szögletes zárójeles szintaxisra nem igazán akart ráállni a szemem. A Swiftről sem hallottam sok jót, ráadásul nem akartam csak emiatt egy új nyelvet megtanulni (hasonló okokból esett ki végül a Dart alapú Flutter is). Valami hasonló logika mentén jutottam el végül a React Native-hoz, ahol a jó öreg JavaScriptben fejleszthet az ember mobilappokat, és hát ha a Facebooknak jó, akkor bizonyára jó lesz nekem is.</p><p name="8526" id="8526" class="graf graf--p graf-after--p">Mielőtt nekiestem volna a doksiknak, megnéztem pár mintakódot ami JavaScript volt ugyan, de valami egészen fura logikával. Android fejlesztőként ugye ahhoz voltam szokva, hogy egy XML-ből felépül a UI, ahol az egyes komponenseket az appon belül objektumokként érem el és metódusokkal módosítgathatom. Ha például egy TextView-ba ki akarok írni valamit, akkor meghívom a TextView setText metódusát. No, ilyesmit egyáltalán nem láttam a kódokban. Ez valami egészen új. Ahogy aztán kicsit jobban beleástam magam a doksikba, rájöttem, hogy ez az egész nem valami új dolog, sokkal inkább egy régi ismerős.</p><p name="e95d" id="e95d" class="graf graf--p graf-after--p">Ha az ember webappot akar fejleszteni mindenféle kliens oldali feldolgozás és JavaScript nélkül (mondjuk PHP-ben), akkor a dolog valahogy úgy néz ki, hogy a felhasználó felküldi az adatokat a szervernek (mondjuk egy kitöltött formot), a szerver feldolgozza azokat, majd ez alapján újragenerálja az egész oldalt és visszaküldi a böngészőnek. Tehát ha írni akarunk egy nagyon egyszerű PHP szkriptet, ami egy gomb megnyomásának hatására kiírja, hogy “Button clicked!”, akkor az úgy fog működni, hogy a gomb megnyomásának hatására az oldal frissül, a szerver pedig újragenerálja az egész oldalt, csak ezúttal úgy, hogy benne legyen a “Button clicked!” szöveg. Az ilyen fajta működés egyik nagy előnye például, hogy használhatunk template-eket, amivel sokkal kényelmesebb és átláthatóbb a működés. Nos, kb. így működik a dolog react native-ban is.</p><figure name="d422" id="d422" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/TheBojda/5ae25361ed930453fb4251ea5fcc44f0.js"></script></figure><p name="5963" id="5963" class="graf graf--p graf-after--figure">A fenti kódban jól látszik ez a fajta működés. A render metódusban látható a template amiből generálódik a UI. Nekem rögtön a PHP jutott az eszembe, ahol ugyanígy be lehet ágyazni a HTML kódot mint itt a UI-t leíró XML-t, ami más kódrészeket tartalmazhat. Erre itt a {}-ek szolgálnak. Ami elsőre feltűnik az embernek, hogy ilyen beágyazás a JavaScript-ben nincsen. A JS ilyen fajta kiterjesztése a <a href="https://reactjs.org/docs/introducing-jsx.html" data-href="https://reactjs.org/docs/introducing-jsx.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">JSX</a> amit egy előfordító fordít szabvány JS-re. A render metódus valójában egy ReactElement objektumokból álló fát ad vissza, de ezt a JSX teljesen elrejti előlünk.</p><p name="9488" id="9488" class="graf graf--p graf-after--p">A szerver oldali feldolgozás nagy hátránya, hogy mikor újrageneráljuk a teljes oldalt, azt a böngészőnek újra fel kell dolgoznia, újra legenerálni a teljes DOM-ot, stb. Ez elég nagy árnak tűnik egy vacak szöveg megváltoztatásáért. Szerencsére a React ezt okosan csinálja. Minden renderelést követően az objektum fát összehasonlítja az aktuális állapottal és mindig csak a változásokat érvényesíti, így a folyamat végén mégiscsak egy setText hívás fog történni. Ezzel a megoldással tehát megmarad a template-ek kényelme, miközben a végrehajtás ugyanolyan hatékony mint a natív megoldás esetén.</p><p name="87f9" id="87f9" class="graf graf--p graf-after--p">A másik dolog ami feltűnhet, az a clickHandler eseménykezelőben a setState metódus hívása. A this.state változót a konstruktorban közvetlenül állítjuk be és a render metódusban is közvetlenül olvassuk ki, az eseménykezelőben viszont a setState-n keresztül módosítjuk. Ez elsőre megint valami új dolognak tűnt, amiről később kiderült, hogy ugyancsak egy régi ismerős.</p><p name="4609" id="4609" class="graf graf--p graf-after--p">Még nagyon nagyon régen, mikor 3D engine-t írtunk (Pascalban!), úgy nézett ki a programlogika, hogy beolvastuk az inputot, legeneráltuk a tér aktuális állapotát, majd kirendereltük és megjelenítettük az objektumokat. Tulajdonképpen ez pörgött egy végtelen ciklusban. Csakhogy néha túl sokáig tartott a számolás vagy a renderelés, amitől a játék belassult. Vegyünk például egy kockát, aminek 10mp alatt kellene körbefordulnia. Írunk rá egy timert, ami ~0,028mp-enként forgat rajta egy fokot. De mi van akkor, ha a tér renderelése 0,1mp-ig tart? Ha minden forgatás után renderelünk, akkor kb. negyedére fog csökkenni a kocka forgási sebessége, így 10mp helyett 40mp-ig tart amíg körbeforog, ami nem jó. A másik lehetőség, hogy egyszerűen kidobunk 3 frame-et és csak minden negyediket rendereljük ki. Ekkor kicsit szaggatottabb lesz a mozgás (csökken az FPS — Frame Per Second), de a kocka ugyanúgy 10mp alatt fordul körbe. Ha így járunk el, nem fog használhatatlan mértékben lassulni a játék, csak csökken a folyamatosság (az FPS). Ugyanígy működik a react is. Mikor egy eseménykezelőben megváltoztatjuk az állapotot (mondjuk kiírunk egy szöveget), akkor nem biztos, hogy a UI-on történik is valami. Elképzelhető, hogy a rendszer nem ér rá, mert épp egy előző fázist renderel. Ilyenkor a változtatási kérelmek gyűlnek egy csőben, majd ha újra felszabadul a renderer, összefűzi őket és kirendereli a következő állapotot. Mivel a renderelés teljesen aszinkron, ezért ha közvetlenül piszkálnánk a state változót, megtörténhetne pl. olyan disznóság, hogy csak félig állítottuk be mikor renderel a rendszer. Ezért kell minden állapotváltoztatást a setState-ben csinálni.</p><p name="27ab" id="27ab" class="graf graf--p graf-after--p">Ha ezt a pár dolgot sikerül megszokni és tudunk a react logikájának megfelelően gondolkodni, akkor egy nagyon kényelmes rendszert kapunk, amivel gyorsan fejleszthetünk cross-platform alkalmazásokat JavaScriptben. <strong class="markup--strong markup--p-strong">A React Native segítségével egy biztos JavaScript tudással rendelkező webfejlesztőből pár hét alatt mobil app fejlesztő válhat.</strong></p><p name="0bc0" id="0bc0" class="graf graf--p graf-after--p">Az írás további részében össze fogunk rakni egy egyszerű todo appot, ahol lehet felvenni feladatokat, illetve ki lehet törölni azokat. Első lépésben telepítsük az expo-t (a telepítéshez <a href="https://nodejs.org/en/" data-href="https://nodejs.org/en/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Node.js</a> szükséges):</p><pre name="3696" id="3696" class="graf graf--pre graf-after--p">npm install -g expo-cli</pre><p name="3182" id="3182" class="graf graf--p graf-after--pre">Az <a href="https://expo.io/" data-href="https://expo.io/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Expo</a> egy nagyon okos kis tool React Native-hoz, amivel nagyon könnyen fejleszthetünk illetve forgathatunk natív appokat.</p><pre name="bc3b" id="bc3b" class="graf graf--pre graf-after--p">expo init todo</pre><p name="4951" id="4951" class="graf graf--p graf-after--pre">A fenti paranccsal létrehozzuk a todo projektet (a felajánlott listából válasszuk ki a teljesen üres blank projektet). A létrehozott könyvtárat nyissuk meg a kedvenc JavaScript editorunkkal (nálam ez a <a href="https://code.visualstudio.com/" data-href="https://code.visualstudio.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">VSCode</a>), majd a könyvtárba lépve adjuk ki a a következő parancsot:</p><pre name="344a" id="344a" class="graf graf--pre graf-after--p">expo start</pre><p name="6cc6" id="6cc6" class="graf graf--p graf-after--pre">Ha elindult a gépünkön a lokális szerver, egy QR kód fog megjelenni, amit az Expo <a href="https://play.google.com/store/apps/details?id=host.exp.exponent&amp;referrer=www" data-href="https://play.google.com/store/apps/details?id=host.exp.exponent&amp;referrer=www" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Android</a> vagy <a href="https://itunes.apple.com/app/apple-store/id982107779" data-href="https://itunes.apple.com/app/apple-store/id982107779" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">iOS</a> appjával bescannelve a mobilunkon elindul az alkalmazás. Ha a szerkesztőben bármit módosítunk, a mobilon automatikusan frissül a felület, így igazán gyorsan és kényelmesen megy a fejlesztés.</p><figure name="29aa" id="29aa" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/TheBojda/0576f961fac62b8c0bf4f3de8920318b.js"></script></figure><p name="dbbe" id="dbbe" class="graf graf--p graf-after--figure">Ha a fenti kódot bemásoljuk az App.js fájlba, rögtön láthatjuk is a TODO appot működés közben.</p><p name="ecef" id="ecef" class="graf graf--p graf-after--p">A kód értelmezését kezdjük talán a végével. A styles konstansban definiáljuk az egyes komponensekhez tartozó stílusokat. A stílusok megadása a CSS-hez nagyon hasonló, még a property elnevezések is gyakran ugyanazok. A <a href="https://facebook.github.io/react-native/docs/style" data-href="https://facebook.github.io/react-native/docs/style" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">komponens stílusokról</a> és a <a href="https://facebook.github.io/react-native/docs/flexbox" data-href="https://facebook.github.io/react-native/docs/flexbox" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">flexbox layout rendszerről</a> a React Native dokumentációban olvashatunk bővebben.</p><p name="9f87" id="9f87" class="graf graf--p graf-after--p">A UI a szokásos módon az App osztály render metódusában van definiálva. Egy FlatList és egy TextInput komponensből áll. A FlatList a data propertyben várja a megjelenítendő adatokat egyszerű JS tömb formájában. A renderItem paraméter egy komponensre mutat, ami az egyes sorokat meg fogja jeleníteni. Ebben az esetben ez a komponens a listItem. Feltűnhet, hogy a listItem az App-tól eltérően nem egy osztály ami a Componentből származik, hanem egy egyszerű JS függvény, React Native-ban ugyanis ez a két módja van egy komponens megadásának. Vagy definiálunk egy osztályt és implementáljuk a render függvényt, vagy egyszerűen definiálunk egy függvényt, ami paraméterként megkapja a komponens property-ket, a visszatérési értéke pedig a generált UI. Az így definiált komponenseket <a href="https://reactjs.org/docs/components-and-props.html" data-href="https://reactjs.org/docs/components-and-props.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">felhasználhatjuk az UI leíró XML-ben</a>, vagy paraméterként, mint a fenti esetben. A listItem paraméterként kapja meg a megjelenítendő elemet (item), és annak indexét (index).</p><p name="52a3" id="52a3" class="graf graf--p graf-after--p">A TextInput egy egyszerű beviteli mező. Az onChangeText paramétereként megadott changeTextHandler arra szolgál, hogy meg is jelenjen a szöveg amit beírunk. Itt ugyanis minden billentyűleütést követően visszaírjuk a bevitt szöveget a value paraméterbe. Az elem hozzáadását az onSubmit eseménykezelőben megadott addTask függvény végzi, ami egy új elemet fűz a state-ben lévő tasks tömb végére.</p><p name="ebf4" id="ebf4" class="graf graf--p graf-after--p">Végül a deleteTask, amit a listItem X gombja hív az átadott index alapján törli az adott elemet a tasks tömbből. Ezzel kb. le is fedtük a teljes működési logikát. Ami kimaradt, az a componentDidMount függvény, ami akkor fut le, amikor a komponens kikerül a UI-ra, így itt végezhető el minden szükséges inicializálás. Jelen esetben két eseménykezelőt definiálunk, amik a billentyűzet megjelenésekor feljebb, illetve eltűnésekor lejjebb állítják a beviteli mező helyzetét, hogy nyitott billentyűzet esetén is látszódjon amit írunk.</p><p name="816a" id="816a" class="graf graf--p graf-after--p">Most hogy minden fontos részt átbeszéltünk, jöhet a fordítás:</p><pre name="8d40" id="8d40" class="graf graf--pre graf-after--p">expo build:android</pre><p name="d6a9" id="d6a9" class="graf graf--p graf-after--pre">A fenti parancs az Expo build szerverét használva elkészíti az Android APK-t (vagy iOS esetén az IPA-t). A dolog előnye, hogy nem kell telepítenünk semmilyen fejlesztői környezetet, hiszen az Expo mindent intéz helyettünk. A hátránya, hogy az ingyenes változatnál sokszor sokat kell várni a build szerverre amíg kiköpi az appot. A priority buildért havi 30$-t kérnek.</p><p name="12a6" id="12a6" class="graf graf--p graf-after--p">Ha inkább lokálisan fordítanánk, akkor hozzunk létre egy üres React Native appot és másoljuk át a projekt tartalmát. Innen már fordíthatunk helyben <a href="https://facebook.github.io/react-native/docs/signed-apk-android" data-href="https://facebook.github.io/react-native/docs/signed-apk-android" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Androidra</a> és <a href="https://stackoverflow.com/questions/42110496/how-to-build-ipa-application-for-react-native-ios" data-href="https://stackoverflow.com/questions/42110496/how-to-build-ipa-application-for-react-native-ios" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">iOS-re</a>. A dolog kicsit macerásabb mint az Expo használata esetén, hiszen telepítenünk kell a fejlesztőkörnyezeteket és iOS esetén még egy Mac-re is szükségünk lesz, cserébe ingyen van és jobban testre szabható az alkalmazás.</p><p name="5b17" id="5b17" class="graf graf--p graf-after--p">A fentiekből jól látható, hogy React Native segítségével pár sorból egész ügyes dolgokat össze lehet rakni, ráadásul a kód is szép és átlátható, az Expo-nak köszönhetően pedig a kényelmes és egyszerű a fejlesztés. Ha valaki webfejlesztőként szeretne valódi, natív komponenseket használó mobilappot készíteni (tehát nem csak egy beágyazott weblapot, amilyet a Cordova alapú Ionic generál), annak a React Native ideális megoldás, hiszen JavaScriptben kódolhat, a UI-t pedig HTML/CSS használatához hasonló módon építheti fel.</p><p name="de9f" id="de9f" class="graf graf--p graf-after--p graf--trailing">Nyilván sokat lehetne még írni a React Native-ról, de úgy gondolom, hogy alapozásnak ennyi elegendő. A projekt népes közösséggel rendelkezik, sok nagy cég használja mobilappok fejlesztésére, élükön természetesen a Fecebokkal. Az Interneten rengeteg leírás, tutorial és példaprogram található, így többnyire hamar választ kaphatunk a felmerülő kérdésekre.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/f63dd346382a"><time class="dt-published" datetime="2020-02-10T11:27:36.842Z">February 10, 2020</time></a>.</p><p><a href="https://medium.com/@thebojda/react-native-alapoz%C3%B3-f63dd346382a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 9, 2021.</p></footer></article></body></html>