<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Zero-Knowledge Proofs Using SnarkJS and Circom</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Zero-Knowledge Proofs Using SnarkJS and Circom</h1>
</header>
<section data-field="subtitle" class="p-summary">
A JavaScript tutorial
</section>
<section data-field="body" class="e-content">
<section name="d175" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c418" id="c418" class="graf graf--h3 graf--leading graf--title">Zero-Knowledge Proofs Using SnarkJS and Circom</h3><h4 name="f68c" id="f68c" class="graf graf--h4 graf-after--h3 graf--subtitle">A JavaScript tutorial</h4><figure name="d223" id="d223" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*bGnw54bg_kGm992J" data-width="6720" data-height="4480" data-unsplash-photo-id="26YOSbRw65A" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*bGnw54bg_kGm992J"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@rikku72?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@rikku72?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Maria Cappelli</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="4729" id="4729" class="graf graf--p graf-after--figure">The technology of <a href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" data-href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zero-knowledge proof</a> and especially <a href="https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof" data-href="https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zk-SNARK</a> is one of the most exciting ones in the field of crypto because of the following reasons:</p><ul class="postList"><li name="cc37" id="cc37" class="graf graf--li graf-after--p">You can prove you have information without revealing it (for example, you can use it for anonymous voting).</li><li name="1c2e" id="1c2e" class="graf graf--li graf-after--li">The proof is small and easy to verify on the blockchain, so it can be used for rollups.</li></ul><blockquote name="ea27" id="ea27" class="graf graf--blockquote graf-after--li"><a href="https://vitalik.ca/general/2021/01/05/rollup.html" data-href="https://vitalik.ca/general/2021/01/05/rollup.html" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">Rollup</a> is a blockchain scaling solution where the computation is done off-chain, and after a given number of transactions the state is synchronized back to the blockchain. This solution gives you the security of the blockchain (after the synchronization), but the proof needs much less space (and less gas) than the original transactions. So zk-rollups are the ideal scaling solutions for the blockchain.</blockquote><p name="aa2d" id="aa2d" class="graf graf--p graf-after--blockquote">I have a <a href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" data-href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">previous article</a> where I show how zero-knowledge proofs work through the source code of the Tornado Cash coin mixer. If you are not familiar with the technology, it is strongly recommended to read that article before this one.</p><p name="e8e8" id="e8e8" class="graf graf--p graf-after--p">In this article, I will show you how you can use zk-SNARK in your JavaScript project.</p><p name="14f7" id="14f7" class="graf graf--p graf-after--p">If you have read my <a href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" data-href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">previous article</a>, you know that you need a circuit to generate a zero-knowledge proof. A circuit is a huge mathematical expression used by the system to calculate the outputs and the proof. The zero-knowledge proof itself is proof that you have successfully done the calculation.</p><p name="450b" id="450b" class="graf graf--p graf-after--p">A circuit can be really complex, but fortunately, there are circuit programming languages and libraries that make it easy to write your own circuits. We will use <a href="https://iden3.io/circom" data-href="https://iden3.io/circom" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Circom</a>. Circom is written in Rust. To install it, you have to install the Rust environment with the following command:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="d11c" id="d11c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh</span></pre><p name="57d5" id="57d5" class="graf graf--p graf-after--pre">After the Rust installation, clone the Circom repo and build the compiler:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="3831" id="3831" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">git <span class="hljs-built_in">clone</span> https://github.com/iden3/circom.git<br /><span class="hljs-built_in">cd</span> circom<br />cargo build --release<br />cargo install --path circom</span></pre><p name="1936" id="1936" class="graf graf--p graf-after--pre">If everything went well, now you have the Circom compiler installed.</p><p name="70fb" id="70fb" class="graf graf--p graf-after--p">The other thing we need is the <a href="https://github.com/iden3/circomlib" data-href="https://github.com/iden3/circomlib" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">circomlib</a>. Circomlib is a programming library with many useful predefined circuits. So, create an empty project, and install circomlib using this code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="06fa" id="06fa" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">npm <span class="hljs-keyword">init</span><br />npm i circomlib</span></pre><p name="a97c" id="a97c" class="graf graf--p graf-after--pre">Now, everything is ready to create our circuit. Here’s what that looks like:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="db0a" id="db0a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">pragma circom <span class="hljs-number">2.0</span><span class="hljs-number">.0</span>;<br /><br />include <span class="hljs-string">&quot;node_modules/circomlib/circuits/poseidon.circom&quot;</span>;<br /><br />template <span class="hljs-title class_">PoseidonHasher</span>() {<br />    signal input <span class="hljs-keyword">in</span>;<br />    signal output out;<br /><br />    component poseidon = <span class="hljs-title class_">Poseidon</span>(<span class="hljs-number">1</span>);<br />    poseidon.<span class="hljs-property">inputs</span>[<span class="hljs-number">0</span>] &lt;== <span class="hljs-keyword">in</span>;<br />    out &lt;== poseidon.<span class="hljs-property">out</span>;<br />}<br /><br />component main = <span class="hljs-title class_">PoseidonHasher</span>();</span></pre><p name="2c94" id="2c94" class="graf graf--p graf-after--pre">This simple circuit has a private input and an output <a href="https://docs.circom.io/circom-language/signals/" data-href="https://docs.circom.io/circom-language/signals/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">signal</a>. We are using the poseidon hasher from circomlib to generate the input <code class="markup--code markup--p-code">hash</code>. Using this circuit, we can prove that we know the original data for the given <code class="markup--code markup--p-code">hash</code> without revealing it.</p><p name="0944" id="0944" class="graf graf--p graf-after--p">In the first step, we compile the circuit by the circom compiler that will generate a wasm and an r1cs file.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="bash" name="25ff" id="25ff" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">circom poseidon_hasher.circom --wasm --r1cs -o ./build</span></pre><p name="7e23" id="7e23" class="graf graf--p graf-after--pre">The generated wasm and r1cs files are available in the build folder. To generate the proof, we need a proving key file, and to generate this file, we need a ptau file. This ptau file can be generated by <a href="https://github.com/iden3/snarkjs" data-href="https://github.com/iden3/snarkjs" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">snarkjs</a>, or you can download a pregenerated one (you can find the links in the snarkjs repo). For testing, the generated one is good for us, but in your production app, it’s recommended to do the ceremony and generate your own ptau file. (You can read about it in my <a href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" data-href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">previous article</a>.)</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="14b2" id="14b2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">wget https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28_hez_final_12.ptau</span></pre><p name="daa1" id="daa1" class="graf graf--p graf-after--pre">Now we can generate the proving key (zkey file) by using the circuit and the ptau file:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="5e5e" id="5e5e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">npx snarkjs groth16 setup build/poseidon_hasher.r1cs powersOfTau28_hez_final_12.ptau circuit_0000.zkey</span></pre><p name="0c4a" id="0c4a" class="graf graf--p graf-after--pre">It is not recommended to use this zkey file for production, but for testing, it will be good for us (for more info, please check the <a href="https://github.com/iden3/snarkjs" data-href="https://github.com/iden3/snarkjs" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">snarkjs documentation</a>).</p><p name="63fc" id="63fc" class="graf graf--p graf-after--p">Now, everything is ready to generate the proof. We will use snarkjs, so install it with this command:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="bash" name="0622" id="0622" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">npm i snarkjs</span></pre><p name="372a" id="372a" class="graf graf--p graf-after--pre">The generation of proof looks like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="00f0" id="00f0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> { proof, publicSignals } = <span class="hljs-keyword">await</span> snarkjs.<span class="hljs-property">groth16</span>.<span class="hljs-title function_">fullProve</span>(<br />  { <span class="hljs-attr">in</span>: <span class="hljs-number">10</span> }, <br />  <span class="hljs-string">&quot;build/poseidon_hasher_js/poseidon_hasher.wasm&quot;</span>, <br />  <span class="hljs-string">&quot;circuit_0000.zkey&quot;</span>);<br /><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(publicSignals);<br /><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proof);</span></pre><p name="0762" id="0762" class="graf graf--p graf-after--pre">The input signals are passed in the first parameter of the <code class="markup--code markup--p-code">fullProve</code> function. The second parameter is the compiled circuit, and the last parameter is the generated proving key. The function returns the outputs of the circuit and the proof.</p><p name="8e56" id="8e56" class="graf graf--p graf-after--p">We need a verification key that can be generated from the proving key to verify the proof. Here’s how to get that:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="25bd" id="25bd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">npx snarkjs zkey <span class="hljs-built_in">export</span> verificationkey circuit_0000.zkey verification_key.json</span></pre><p name="447b" id="447b" class="graf graf--p graf-after--pre">The verification code looks like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="6eae" id="6eae" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> vKey = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;verification_key.json&quot;</span>));<br /><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> snarkjs.<span class="hljs-property">groth16</span>.<span class="hljs-title function_">verify</span>(vKey, publicSignals, proof);<br /><br /><span class="hljs-keyword">if</span> (res === <span class="hljs-literal">true</span>) {<br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Verification OK&quot;</span>);<br />} <span class="hljs-keyword">else</span> {<br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Invalid proof&quot;</span>);<br />}</span></pre><p name="e122" id="e122" class="graf graf--p graf-after--pre">The verification key is the first parameter of the <code class="markup--code markup--p-code">verify</code> function, and the outputs and proof are the second and third parameters. The result of the function is a simple boolean.</p><p name="6067" id="6067" class="graf graf--p graf-after--p">In this example, we used the circuit to calculate the <code class="markup--code markup--p-code">hash</code>, but it is not always possible because the <code class="markup--code markup--p-code">hash</code> can be a partial result, or our circuit would look like this:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="9e83" id="9e83" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">pragma circom <span class="hljs-number">2.0</span><span class="hljs-number">.0</span>;<br /><br />include <span class="hljs-string">&quot;node_modules/circomlib/circuits/poseidon.circom&quot;</span>;<br /><br />template <span class="hljs-title class_">PoseidonHasher</span>() {<br />    signal input <span class="hljs-keyword">in</span>;<br />    signal input hash;<br /><br />    component poseidon = <span class="hljs-title class_">Poseidon</span>(<span class="hljs-number">1</span>);<br />    poseidon.<span class="hljs-property">inputs</span>[<span class="hljs-number">0</span>] &lt;== <span class="hljs-keyword">in</span>;<br />    hash === poseidon.<span class="hljs-property">out</span>;<br />}<br /><br />component main {public [hash]} = <span class="hljs-title class_">PoseidonHasher</span>();</span></pre><p name="6bc5" id="6bc5" class="graf graf--p graf-after--pre">This circuit has no outputs, only two inputs. The first input is the data, and the second is the hash of it. In the last line of the template, we check the <code class="markup--code markup--p-code">hash</code>. The circuit will run successfully only if the given <code class="markup--code markup--p-code">hash</code> is the poseidon <code class="markup--code markup--p-code">hash</code> of the given data. But how can we calculate the poseidon <code class="markup--code markup--p-code">hash</code> in JS?</p><p name="83d7" id="83d7" class="graf graf--p graf-after--p">Circomlib has a <a href="https://github.com/iden3/circomlibjs" data-href="https://github.com/iden3/circomlibjs" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">JS implementation</a> that can be used for this. Let’s install it:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="bash" name="f148" id="f148" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">npm i circomlibjs</span></pre><p name="4105" id="4105" class="graf graf--p graf-after--pre">Now we can calculate the <code class="markup--code markup--p-code">hash</code> by using the following code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="e2f1" id="e2f1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> <span class="hljs-keyword">const</span> poseidon = <span class="hljs-keyword">await</span> circomlibjs.<span class="hljs-title function_">buildPoseidon</span>();<br /> <span class="hljs-keyword">const</span> hash = poseidon.<span class="hljs-property">F</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-title function_">poseidon</span>([<span class="hljs-number">10</span>]));<br /> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash);</span></pre><p name="b4be" id="b4be" class="graf graf--p graf-after--pre">The result of the <code class="markup--code markup--p-code">poseidon</code> function is a <code class="markup--code markup--p-code">Buffer</code>, which we have to convert to a number. In zk-SNARK, every calculation is done in a <a href="https://en.wikipedia.org/wiki/Finite_field" data-href="https://en.wikipedia.org/wiki/Finite_field" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">finite field</a>, so we have to use <code class="markup--code markup--p-code">poseidon.F.toString</code> for the conversion.</p><p name="dd7d" id="dd7d" class="graf graf--p graf-after--p">Circomlibjs and snarkjs work well in Node.js and the browser, so you can generate or verify proofs on the client side. It is also possible to generate a smart contract for verification that you can use in your Solidity code to verify the proof. (For more info, please check the <a href="https://github.com/iden3/snarkjs" data-href="https://github.com/iden3/snarkjs" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">snarkjs documentation</a>.)</p><p name="ea24" id="ea24" class="graf graf--p graf-after--p">Circomlibjs also has smart contract generators. For example, if you want to generate a poseidon <code class="markup--code markup--p-code">hash</code> on-chain, you can do it by the generated code.</p><p name="e58d" id="e58d" class="graf graf--p graf-after--p">This was my very short tutorial on using zk-SNARK in JavaScript. It’s not a full course, and you probably have many questions, but I hope I helped you to start your journey. <a href="https://docs.circom.io/" data-href="https://docs.circom.io/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Circom</a> and <a href="https://github.com/iden3/snarkjs/blob/master/README.md" data-href="https://github.com/iden3/snarkjs/blob/master/README.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">snarkjs</a> are well documented, and you can also learn a lot from existing projects like <a href="https://github.com/tornadocash/tornado-core" data-href="https://github.com/tornadocash/tornado-core" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tornado Cash</a>.</p><p name="32af" id="32af" class="graf graf--p graf-after--p graf--trailing">The source codes for this tutorial are available in <a href="https://github.com/TheBojda/zksnark-tutorial" data-href="https://github.com/TheBojda/zksnark-tutorial" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this GitHub repo</a>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/fac6c4d63202"><time class="dt-published" datetime="2023-01-10T03:02:17.395Z">January 10, 2023</time></a>.</p><p><a href="https://medium.com/@thebojda/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on February 1, 2023.</p></footer></article></body></html>