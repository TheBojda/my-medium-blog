<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Programozzunk ICO-t (1. rész) #ethereumtudas</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Programozzunk ICO-t (1. rész) #ethereumtudas</h1>
</header>
<section data-field="subtitle" class="p-summary">
az ICO programozás alapjai
</section>
<section data-field="body" class="e-content">
<section name="8b40" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e06f" id="e06f" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">Programozzunk ICO-t (1. rész) #ethereumtudas</strong></h3><h4 name="337d" id="337d" class="graf graf--h4 graf-after--h3 graf--subtitle">az ICO programozás alapjai</h4><p name="2e8c" id="2e8c" class="graf graf--p graf-after--h4">Ahogyan már az előző #ethereumtudas részben ígértem, ebben a részben elkezdünk leprogramozni egy ICO-t. Azért csak az “elkezdjük”, mert a téma elég nagy, és sok területet lefed, így több részre kell bontanunk.</p><figure name="9bf9" id="9bf9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lbChs4602fL7lhFYVYXh5g.jpeg" data-width="1280" data-height="853" src="https://cdn-images-1.medium.com/max/800/1*lbChs4602fL7lhFYVYXh5g.jpeg"><figcaption class="imageCaption">Forrás: pixabay.com</figcaption></figure><p name="e630" id="e630" class="graf graf--p graf-after--figure">Hogy mi a fene az az ICO, arról <a href="https://medium.com/envienta-magyarorsz%C3%A1g/mi-a-fene-az-az-ico-38c7272b010c" data-href="https://medium.com/envienta-magyarorsz%C3%A1g/mi-a-fene-az-az-ico-38c7272b010c" class="markup--anchor markup--p-anchor" target="_blank">itt</a> olvashattok bővebben. Dióhéjban most annyit fogunk tenni, hogy írunk egy smart contractot, ami az előző részben létrehozott ERC20-as tokenjeinket fogja árulni. Egyelőre nem fogjuk túlbonyolítani a dolgot. Egy ETH-ért egységesen 100 tokent fogunk adni, a vásárlás indítását és lezárását pedig kézzel fogjuk vezérelni (egy igazi ICO-nál általában a smart contractba van kódolva a gyűjtés időtartama).</p><p name="54d5" id="54d5" class="graf graf--p graf-after--p">Az eladás úgy fog történni, hogy elsőként az ICO contractnak átutaljuk az eladásra szánt tokeneket, majd ha már eindult az eladás, bárki vehet tokent a megadott áron. Ha az eladás lezárult, a megmaradt tokenek és a begyűjtött pénz a tulajdonoshoz kerül.</p><blockquote name="1bc8" id="1bc8" class="graf graf--blockquote graf-after--p">Gabriel: Nagyon örülök, hogy ezt a részt vesézzük ki most, mert folyamatosan olyan megkereséseket kapunk, hogy beszéljünk már az ICO indításról. Közben persze állandóan a “miért oktattok ilyen alap szinten?” kérdésekre kell válaszolgatnom. A lényeget már többször is leírtuk: Aki fejlesztő, az rövid kutatás után megtalálja a leírásokat, de mi a kevésbé gyakorlott vagy kezdő fejlesztőket akarjuk felzárkóztatni, vagy legalábbis betekintést nyújtani az érdeklődőknek.</blockquote><p name="98cd" id="98cd" class="graf graf--p graf-after--blockquote">Íme a kód:</p><figure name="11e5" id="11e5" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/TheBojda/dc5cf005a17cede700f8415da2df3e42.js"></script></figure><p name="f023" id="f023" class="graf graf--p graf-after--figure">A kód ugye a szokásos pragma direktívával kezdődik, majd ezt követi az</p><p name="f390" id="f390" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">import “token.sol”;</em></p><p name="4473" id="4473" class="graf graf--p graf-after--p">rész. A fenti sorral húzzuk be az előző részben elkészített token kódját. Erre szükségünk lesz, ugyanis ezeket a tokeneket szeretnénk értékesíteni smart contracttal.</p><p name="e613" id="e613" class="graf graf--p graf-after--p">A Crowdsale contractban 4 változó szerepel:</p><p name="2a18" id="2a18" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">address public owner;<br>Token public rewardToken;<br>bool started = false;<br>uint tokenETH = 100;</em></p><p name="9ba8" id="9ba8" class="graf graf--p graf-after--p">Az owner egy Ethereum cím. Itt fogjuk tárolni, hogy ki a contract tulajdonosa (ki hozta létre az okosszerződést). A rewardToken egy Token típusú változó. A Token ugye az az ERC20-as token, amit az előző részben létrehoztunk. Ezt most a rewardToken változón keresztül érhetjük majd el. A started egy logikai (igen/nem) változó, és azt tárolja, hogy elindult-e már a tokenek árusítása. Végül a tokenETH egy konstans, ahol azt tároljuk, hogy egy ETH-ért hány tokent adunk.</p><blockquote name="5e1a" id="5e1a" class="graf graf--blockquote graf-after--p">Gabriel: Ez a rész szerintem teljesen világos és gondolom minden olvasó számára olyan mintha egyszercsak összeállna a kép. Személy szerint én mindig azt érzem (és ezzel nem akarom lebecsülni a fejlesztőket), mintha túlságosan az egekbe emelnénk az okosszerződéseket, miközben ha minden egyes sorra rávilágítunk az egész kezd világossá válni és párhuzamosan eltűnik a misztika is az egész körül… és marad az “okosság”.</blockquote><p name="1fec" id="1fec" class="graf graf--p graf-after--blockquote">A következő blokk egy modifier:</p><p name="12d6" id="12d6" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">modifier onlyOwner {<br> require(msg.sender == owner);<br> _;<br>}</em></p><p name="c11c" id="c11c" class="graf graf--p graf-after--p">Ezek olyan funkciók, amelyeket más funkciókhoz rendelhetünk, és valamilyen általános feladatot látnak el. Az onlyOwner pl. nevének megfelelően azt ellenőrzi, hogy a hozzá rendelt funkciót a contract tulajdonosa hajtja-e végre.</p><p name="415f" id="415f" class="graf graf--p graf-after--p">A require rész ellenőrzi, hogy a funkciót hívó felhasználó (msg.sender) megegyezik-e a tulajdonossal (owner). Ha ez nem teljesül, a require hibával megállítja a funkció futását. Ha a feltétel teljesül, tovább megy a végrehajtás (van itt egy _ jel, ez jelenti a hozzárendelt funkció végrehajtását). Hogy hogyan is kell használni ezeket a modifiereket, arra hamarosan mutatunk is példát.</p><p name="8d5b" id="8d5b" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function Crowdsale() {<br> owner = msg.sender;<br>}</em></p><p name="7b41" id="7b41" class="graf graf--p graf-after--p">A contract konstruktora beállítja az owner változót a létrehozó címére.</p><p name="ff07" id="ff07" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function start(address rewardTokenAddress) onlyOwner {<br> rewardToken = Token(rewardTokenAddress);<br> started = true;<br>}</em><br> <br>A start metódus szolgál az eladás elindítására. Paraméterként megkapja a token contract címét, ami alapján beállítja a rewardToken változó értékét, majd a start logikai változót igaz értékre állítja, ezzel jelezve , hogy az eladás elindult. A metódus megadásánál példát láthatunk az onlyOwner modifier használatára is. Egyszerűen csak oda kell írnunk a modifier-t a funkció végére. Ezzel biztosítani tudjuk, hogy ezt a funkciót csak és kizárólag a contract tulajdonosa (létrehozója) tudja meghívni.</p><p name="3ec8" id="3ec8" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function stop() onlyOwner {<br> started = false;<br>}</em></p><p name="1d96" id="1d96" class="graf graf--p graf-after--p">A start metódus párja a stop, amit ugyancsak a tulajdonos tus meghívni, és ami leállítja az eladást.</p><p name="e267" id="e267" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function destroy() onlyOwner {<br> rewardToken.transfer(owner, rewardToken.balanceOf(this));<br> selfdestruct(owner);<br>}</em></p><p name="e6bb" id="e6bb" class="graf graf--p graf-after--p">A destroy metódus az ICO contract megszüntetésére szolgál. Az első sor visszautalja a megmaradt tokeneket a tulajdonosnak. Itt ugye a token contract balanceOf metódusával lekérdezzük, hogy hány token van az ICO contract számláján (a this változóban van a contract saját címe), majd ezt a mennyiséget a transfer metódussal visszautaljuk.</p><p name="74cc" id="74cc" class="graf graf--p graf-after--p">A második sor a selfdestruct funkcióval megszünteti a smart contractot. Ezzel az kvázi törlődik a blokkláncról. A selfdestruct paramétere egy cím, ahová a contract-on tárolt ETH kerül a contract halálát követően. Itt owner szerepel, így a teljes begyűjtött összeg megy a tulajdonosnak. Mivel más pénz utaló funkciót nem raktunk a contractunkba, ezért igazából a contract megszüntetése az egyetlen mód arra, hogy hozzájussunk a tokenek értékesítéséből befolyt összeghez.</p><p name="a6cf" id="a6cf" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function () payable {<br> require(started);<br> uint amount = msg.value * tokenETH;<br> require(rewardToken.balanceOf(this) &gt;= amount);<br> rewardToken.transfer(msg.sender, amount);<br>}</em></p><p name="f665" id="f665" class="graf graf--p graf-after--p">A contract rendelkezik még egy név nélküli funkcióval, ami tulajdonképpen a lényeget rejti. A funkció megadásánál szerepel a payable módosító, ami azt jelöli, hogy a funkciónak pénz (ether) utalható. Bármelyik metódusnál megadható ez a módosító, de a névtelen metódus különleges szerepet tölt be. Ez fut le ugyanis akkor, ha ETH-t utalunk a contractnak. Az első sor ellenőrzi, hogy elindult-e a gyűjtés. Ha nem, hibát dob. A következő sor kiszámolja, hogy a beérkezett ETH-ért (msg.value) mennyi token jár.</p><p name="b80e" id="b80e" class="graf graf--p graf-after--p">Fontos megjegyezni, hogy a rendszer minden összeget wei-ben, az ETH legkisebb egységében kezel. Tehát ha a szerződésnek 1 ETH-t utalunk, akkor az msg.value (beérkezett összeg) értéke 10¹⁸ lesz.</p><p name="48a1" id="48a1" class="graf graf--p graf-after--p">A szemfülesek észrevehetik, hogy mikor az utalandó token mennyiséget számoljuk, nem váltottuk vissza ezt az összeget ETH-ra, egyszerűen csak beszoroztuk az token/ETH váltószámmal. Ezt azért tehetjük meg, mert a tokennél 18-at adtunk meg a decimal értéknél, ami pont egyezik az ETH-nál megadott értékkel. Tehát a tokenünkre is igaz, hogy mikor a walletünk jelzi a mennyiséget, akkor 10¹⁸ egység fog 1 db tokenként megjelenni. Érdemes odafigyelni erre, mert ha a tokennél nem 18 a decimal érték és figyelmetlenek vagyunk, abból lehet egy kis kavarodás.</p><p name="51f2" id="51f2" class="graf graf--p graf-after--p">A harmadik sorban ellenőrizzük, hogy a contract rendelkezik-e elég tokennel. Ha ez teljesül, átutalja a megfelelő mennyiségű tokent a pénzért cserébe.</p><blockquote name="5d85" id="5d85" class="graf graf--blockquote graf-after--p">Gabriel: És itt van az a pont, ami egy normálisnak nevezhető okosszerződés esetében elengedhetetlen: azaz minden valós időben zajlik. Számomra még mindig felháborító az a tény, hogy egy ICO token értékesítéskor miért nem látszódik azonnal a vásárolt token (miközben az ETH már elutalásra került és meg is érkezett). Ez is egyfajta minőségi mutató lehet egy ICO esetében.</blockquote><p name="1c6b" id="1c6b" class="graf graf--p graf-after--blockquote">Hát, röviden ennyi. Ahhoz, hogy kipróbáljuk az ICO contractunkat, indítsuk el egy terminálban a testrpc-t, majd egy másikban az emberkot. Ha minden jól megy, az embark jelezni fogja, hogy publikálta a contractokat.</p><p name="8949" id="8949" class="graf graf--p graf-after--p">Az embark konzolon keresztül (alulra kell majd írni a dolgokat) ki is próbálhatjuk a crowdsale szerződésünket. Elsőként ellenőrizzük, hogy mennyi pénz van az elsődleges Ethereum accountunkon. Ezt a</p><p name="4276" id="4276" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">web3.eth.getBalance(web3.eth.coinbase);</em></p><p name="b768" id="b768" class="graf graf--p graf-after--p">paranccsal tehetjük meg. Itt valamivel kevesebb mint 100 ETH-t fogunk látni (wei-en kijelezve), ugyanis pár wei-t levont a rendszer a szerződések publikálásáért cserébe. Nézzük meg azt is, mennyi tokenünk van:</p><p name="12db" id="12db" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Token.balanceOf(web3.eth.coinbase);</em></p><p name="b66f" id="b66f" class="graf graf--p graf-after--p">Itt láthatjuk, hogy nálunk van mind az 1000000 db token. Utaljunk át mindet az ICO contractnak:</p><p name="669e" id="669e" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Token.transfer(Crowdsale.address, 1000000);</em></p><p name="8e3b" id="8e3b" class="graf graf--p graf-after--p">Nézzük meg, hogy mennyi tokennel rendelkezik most a contract:</p><p name="ef6e" id="ef6e" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Token.balanceOf(Crowdsale.address);</em></p><p name="8d12" id="8d12" class="graf graf--p graf-after--p">Ha minden jól ment, látni fogjuk az előbb átutalt 1000 db tokent a contract számláján. Most, hogy ott vannak a tokenek, indíthatjuk az ICO-t:</p><p name="5961" id="5961" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Crowdsale.start(Token.address);</em></p><p name="bc3d" id="bc3d" class="graf graf--p graf-after--p">Vegyünk 200 tokent a contracttól:</p><p name="2340" id="2340" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">web3.eth.sendTransaction({from: web3.eth.coinbase, to: Crowdsale.address, value: 2})</em></p><p name="312c" id="312c" class="graf graf--p graf-after--p">Ha minden jól ment, van 200 tokenünk</p><p name="641d" id="641d" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Token.balanceOf(web3.eth.coinbase);</em></p><p name="9af8" id="9af8" class="graf graf--p graf-after--p">a contractnak pedig 2 egység (valójában wei-ben számolunk és a token mennyiséget is 10¹⁸-al kellene osztani a tizedesek miatt, de ezzel most ne kavarjunk) pénze</p><p name="03c3" id="03c3" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">web3.eth.getBalance(Crowdsale.address);</em></p><p name="9084" id="9084" class="graf graf--p graf-after--p">Az eladás tehát működik szépen. Ha végeztünk, megöljük a Crowdsale contractot</p><p name="877b" id="877b" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Crowdsale.destroy()</em></p><p name="d299" id="d299" class="graf graf--p graf-after--p">és ha minden jól ment a tokenek és a contracton lévő pénz visszakerült hozzánk</p><p name="0dfe" id="0dfe" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Token.balanceOf(web3.eth.coinbase)</em></p><p name="0fba" id="0fba" class="graf graf--p graf-after--p">Hát, ennyi lett volna: Megírtuk a világ legprimitívebb ICO-ját, ami egyszerűsége ellenére valójában egész használható. A későbbiekben ezt fogjuk kicsit tovább bonyolítani. Például visszaadjuk a pénzt, ha nem jött össze a minimum kampány célösszeg, illetve a smart contractra bízzuk majd a gyűjtés leállításának időzítését. Tartsatok velünk…</p><h3 name="6245" id="6245" class="graf graf--h3 graf-after--p">Kövess minket!</h3><p name="0e27" id="0e27" class="graf graf--p graf-after--h3">A cikksorozat további részeiben ezekkel az okos szerződésekkel fogunk közelebbről megismerkedni, és megtanuljuk azt is, hogy hogyan készíthetünk ilyeneket mi magunk is.</p><p name="4df4" id="4df4" class="graf graf--p graf-after--p">Hogy mindez tényleg felfogható lehessen a cikksorozatot ketten fogjuk írni. A programozói részekért jómagam <a href="https://medium.com/u/792a8f999852" data-href="https://medium.com/u/792a8f999852" data-anchor-type="2" data-user-id="792a8f999852" data-action-value="792a8f999852" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Laszlo Fazekas</a>(fejlesztő) felelek majd, azért pedig, hogy tényleg minden érthető legyen <a href="https://medium.com/u/f91cbcd0bc44" data-href="https://medium.com/u/f91cbcd0bc44" data-anchor-type="2" data-user-id="f91cbcd0bc44" data-action-value="f91cbcd0bc44" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Gabriel Varaljay</a>(marketing) “játssza majd a naivat” (tesz fel kérdéseket, magyarázza újra a feldolgozott anyagot).</p><p name="3dcb" id="3dcb" class="graf graf--p graf-after--p graf--trailing">Épp ezért érdemes feliratkoznod <a href="https://medium.com/envienta-magyarország" data-href="https://medium.com/envienta-magyarország" class="markup--anchor markup--p-anchor" target="_blank">ERRE a medium csatornára</a>, de követheted az ENVIENTA Magyarországot <a href="https://twitter.com/envientahun" data-href="https://twitter.com/envientahun" class="markup--anchor markup--p-anchor" rel="nofollow noopener nofollow noopener nofollow noopener noopener" target="_blank">Twitteren</a>, vagy akár csatlakozhatsz a <a href="https://www.facebook.com/groups/1459500857429638/" data-href="https://www.facebook.com/groups/1459500857429638/" class="markup--anchor markup--p-anchor" rel="nofollow noopener nofollow noopener nofollow noopener noopener" target="_blank">tematikus Facebook csoportunkhoz</a> is.</p></div></div></section><section name="3da7" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e524" id="e524" class="graf graf--h3 graf--leading">Támogasd az ENVIENTA-t!</h3><p name="872d" id="872d" class="graf graf--p graf-after--h3">Ha szereted a cikkeinket és támogatnád az ENVIENTA non-profit szervezet munkáját azt crypto valutában is megteheted:</p><p name="14f0" id="14f0" class="graf graf--p graf-after--p">BTC: 18LzExKVBpoWKvtGgUExUvjfbB7Tv5yqYY</p><p name="6ba9" id="6ba9" class="graf graf--p graf-after--p graf--trailing">ETH: 0x197E9bf5924c30Aa0140Cef4082E017A69Ca9d73</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/c251ecff18fc"><time class="dt-published" datetime="2017-10-02T14:34:28.760Z">October 2, 2017</time></a>.</p><p><a href="https://medium.com/@thebojda/programozzunk-ico-t-1-r%C3%A9sz-ethereumtudas-c251ecff18fc" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 14, 2020.</p></footer></article></body></html>