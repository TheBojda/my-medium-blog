<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How to Implement a Minimalist NFT zkRollup</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How to Implement a Minimalist NFT zkRollup</h1>
</header>
<section data-field="subtitle" class="p-summary">
Zero-knowledge rollups (ZK-rollups) are layer 2 scaling solutions that increase throughput on Ethereum Mainnet by moving computation and…
</section>
<section data-field="body" class="e-content">
<section name="91d6" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6ef0" id="6ef0" class="graf graf--h3 graf--leading graf--title">How to Implement a Minimalist NFT zkRollup</h3><figure name="e4af" id="e4af" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*d5X7Fy1m-bTe0OK4DH-Zog.png" data-width="1792" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*d5X7Fy1m-bTe0OK4DH-Zog.png"></figure><blockquote name="9805" id="9805" class="graf graf--blockquote graf-after--figure">Zero-knowledge rollups (ZK-rollups) are layer 2 scaling solutions that increase throughput on Ethereum Mainnet by moving computation and state-storage off-chain. ZK-rollups can process thousands of transactions in a batch and then only post some minimal summary data to Mainnet. This summary data defines the changes that should be made to the Ethereum state and some cryptographic proof that those changes are correct<strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">. </em></strong><em class="markup--em markup--blockquote-em">— </em><a href="https://ethereum.org/en/developers/docs/scaling/zk-rollups/" data-href="https://ethereum.org/en/developers/docs/scaling/zk-rollups/" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank"><em class="markup--em markup--blockquote-em">Ethereum documentation</em></a></blockquote><p name="b208" id="b208" class="graf graf--p graf-after--blockquote">Sounds good? Why not implement our own rollup just for fun?</p><p name="f1e1" id="f1e1" class="graf graf--p graf-after--p">In this article, we will develop a minimal Zero-knowledge rollup. It is important to note that the article’s primary goal is for the reader to understand the technology, so rather than focusing on efficiency, the emphasis will be on simplicity and understandability.</p><p name="2ca4" id="2ca4" class="graf graf--p graf-after--p">The prerequisite for understanding this article is knowing the basics of ZKP technology, the Circom language, and the SnarkJS library. If these topics are all foreign to you, then it is worth reading <a href="https://medium.com/better-programming/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" data-href="https://medium.com/better-programming/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="markup--anchor markup--p-anchor" target="_blank">my article</a> on ZKP technology, as well as <a href="https://medium.com/better-programming/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" data-href="https://medium.com/better-programming/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" class="markup--anchor markup--p-anchor" target="_blank">my article</a> on programming with Circom and SnarkJS.</p><p name="a904" id="a904" class="graf graf--p graf-after--p">Implementing a zkRollup is not a straightforward task. Before we get started, we need to become familiar with the concept of Sparse Merkle Tree (SMT).</p><p name="89ee" id="89ee" class="graf graf--p graf-after--p">The <a href="https://ethresear.ch/t/optimizing-sparse-merkle-trees/3751" data-href="https://ethresear.ch/t/optimizing-sparse-merkle-trees/3751" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Sparse Merkle Tree</a> is a key/value storage. In this respect, it is similar to a <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/" data-href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Merkle Patricia Trie</a> (Ethereum stores all data in such structures) but much simpler. Whereas the Merkle Patricia Tree is a complex data structure, the Sparse Merkle Tree is a simple binary tree, where each parent stores the hash of its children, with the stored values being the leaf elements, similar to a general Merkle tree. It becomes a key/value storage by having the child elements’ paths determined by the key bits. Let’s look at the following very simple Merkle tree, which is two levels deep and contains 4 values:</p><figure name="ce76" id="ce76" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*IVj3vTv6c7D4TqYx.png" data-width="800" data-height="509" src="https://cdn-images-1.medium.com/max/800/0*IVj3vTv6c7D4TqYx.png"><figcaption class="imageCaption">source: Wikipedia</figcaption></figure><p name="79e6" id="79e6" class="graf graf--p graf-after--figure">In this tree, two-bit keys can address the elements. If the key’s given bit is 0, we go left in the tree; if it’s 1, we go right. For example, if the key is 10, first we go right and then left, thus reaching the element L3. Of course, a two-bit key doesn’t make much sense in practice, and the tree’s size grows exponentially with the key’s size, hence storing such a tree requires a lot of storage capacity for large keys. So if we wanted to store, say, five numbers in the tree but the key size is 16 bits, we’d have to store 65536 values, 5 of which are meaningful and 65531 of which are 0. That is why this structure is called the Sparse Merkle Tree because we typically store far fewer values in it than its capacity. Fortunately, such a structure can be compressed quite adeptly: it is enough to go down a structure as deep as there are relevant bits.</p><p name="32c8" id="32c8" class="graf graf--p graf-after--p">Let’s store 3 values in the above structure. Their keys are 00, 01, 10. To store the values corresponding to keys 00 and 01, we must go to level 2, but the value corresponding to the key 10 we can store on level 1. So, we get a tree where on the left side of the root element there is a branch node with 2 leaves, whereas on the right side, there is a leaf node directly. With this “pruning” of the binary tree, we can store the elements very efficiently.</p><p name="0934" id="0934" class="graf graf--p graf-after--p">The advantage of SMT over the general Merkle tree is that it not only allows us to provide an <strong class="markup--strong markup--p-strong">inclusion proof</strong> but also an <strong class="markup--strong markup--p-strong">exclusion proof</strong>. This means that we can prove that a tree does not contain a value for the given key. Thanks to this, we can prove any operation (insert, delete, update), which will be a very important property of our rollup. Fortunately, Circomlib (and <a href="https://github.com/iden3/circomlibjs" data-href="https://github.com/iden3/circomlibjs" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CircomlibJS</a>) includes an SMT implementation, so we do not need to implement this ourselves.</p><p name="75ec" id="75ec" class="graf graf--p graf-after--p">Our rollup will store NFTs in an SMT. The NFT’s ID will be the key, with its value being the current owner’s public key. For NFTs to be transferred, the owner must produce a digitally signed transaction containing the new owner’s public key and the NFT’s identifier. The owner must prove two things: one, that they signed the transaction, and two, that they are the owner of the NFT so that their public key is stored with the NFT’s ID. If these two proofs are valid, then the ownership of the NFT will be changed to the new owner.</p><p name="0d87" id="0d87" class="graf graf--p graf-after--p">The sequencer collects these NFT transfer transactions, calculates the Merkle root following the transactions, and then sends the new root, list of transactions, and a zero-knowledge proof to a smart contract that proves that the sent transactions truly generate the sent root. The smart contract checks the zero-knowledge proof and if the check is successful, modifies the root.</p><p name="0eca" id="0eca" class="graf graf--p graf-after--p">Anyone can submit transaction batches to a smart contract if they present the corresponding zero-knowledge proofs. To do this, they need to set up the SMT which is easily accomplished since all the transactions are written on the blockchain. There is a special variation of Rollups, called Validium, where the transactions are not written on the blockchain but stored on an external repository (e.g. IPFS or Swarm). This is an even cheaper solution but we have to guarantee data availability. For example, in a DAO, we must select validators who have to sign the state root modification and only then sign the transaction after they have verified that the data is indeed available.</p><p name="0af5" id="0af5" class="graf graf--p graf-after--p">Here is a very simple summary graphic from Vitalik Buterin:</p><figure name="bf0f" id="bf0f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*ntAJ0shIxYiVaVPO.png" data-width="241" data-height="121" src="https://cdn-images-1.medium.com/max/800/0*ntAJ0shIxYiVaVPO.png"></figure><p name="6c44" id="6c44" class="graf graf--p graf-after--figure">In a nutshell, that’s how our rollup works. Doesn’t sound too complicated, right? We’ll see from the code that the devil is in the details. Let’s take a look at the code. (Of course, all code is available on <a href="https://github.com/TheBojda/mini-zk-rollup" data-href="https://github.com/TheBojda/mini-zk-rollup" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>.)</p><p name="ff76" id="ff76" class="graf graf--p graf-after--p">For simplicity, we will pre-create the NFTs and they cannot be moved from the rollup to the blockchain (the NFTs only exist on the rollup), so it is enough to implement the NFT transfer (which itself is sufficiently complex). At the end of the article, I will explain how to further develop our rollup to enable NFTs to be moved between the blockchain and the rollup.</p><p name="ee5f" id="ee5f" class="graf graf--p graf-after--p">As a first step, let’s generate the wallet user accounts. Similar to Ethereum accounts, each Rollup account will have a private key, a public key, and an address, however, instead of ECDSA we use EDDSA for digital signing of transactions. EDDSA is a ZKP-friendly digital signature format. We’ll randomly generate the private keys and generate the addresses from the public keys with the help of Poseidon Hash (a ZKP-friendly hash algorithm). Here’s the code that generates 5 test accounts:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="bd68" id="bd68" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<br />  <span class="hljs-comment">// generate private and public eddsa keys, </span><br />  <span class="hljs-comment">// the public address is the poseidon hash of the public key</span><br />  <span class="hljs-keyword">const</span> prvKey = randomBytes(<span class="hljs-number">32</span>);<br />  <span class="hljs-keyword">const</span> pubKey = eddsa.prv2pub(prvKey);<br />  accounts[i] = {<br />    prvKey: prvKey,<br />    pubKey: pubKey,<br />    address: trie.F.toObject(poseidon(pubKey))<br />  }<br />}</span></pre><p name="bf4f" id="bf4f" class="graf graf--p graf-after--pre">We convert the Poseidon hash to a <a href="https://en.wikipedia.org/wiki/Finite_field" data-href="https://en.wikipedia.org/wiki/Finite_field" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">finite field</a> at address generation using the trie.F.toObject function.</p><p name="d924" id="d924" class="graf graf--p graf-after--p">The next step is to create the NFTs. For this, we create an SMT and fill it correctly. The key in the SMT is the NFT ID and the associated value is the address of the NFT owner. (I will write about nonce SMT later.)</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="d7ff" id="d7ff" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// generate 5 NFTs, and set the first account as owner</span><br /><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {<br />  <span class="hljs-keyword">await</span> trie.insert(i, accounts[<span class="hljs-number">0</span>].address)<br />  <span class="hljs-keyword">await</span> nonceTrie.insert(i, <span class="hljs-number">0</span>)<br />}</span></pre><p name="78a2" id="78a2" class="graf graf--p graf-after--pre">The first task to solve is to enable users to create digitally signed transactions. A transaction consists of 3 data elements. The NFT ID of the asset to be moved, the destination address of the NFT to be sent, and a nonce. The nonce is an incrementing counter needed to make each transaction unique and only executable once. This is very similar to the solution that Ethereum uses for making transactions unique, except that Ethereum assigns the nonce to the Ethereum address, while in our case we assign it to the NFT. If we were to assign the nonce to the address, we would need a larger SMT (if the address is the key then the key size is 32-bit), so it is more practical to associate with the NFT (which needs only a 10-bit tree). Therefore the transaction is a Poseidon hash of these 3 values. This is digitally signed using EDDSA.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="f18a" id="f18a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> createTransferRequest = (<span class="hljs-attr">owner</span>: <span class="hljs-title class_">Account</span>, <span class="hljs-attr">target</span>: <span class="hljs-title class_">Account</span>, <br />  <span class="hljs-attr">nftID</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">nonce</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">TransferRequest</span> =&gt;</span> {<br />  <span class="hljs-keyword">const</span> transactionHash = <span class="hljs-title function_">poseidon</span>([<br />    <span class="hljs-title function_">buffer2hex</span>(target.<span class="hljs-property">address</span>), nftID, <span class="hljs-title function_">buffer2hex</span>(nonce)<br />  ])<br />  <span class="hljs-keyword">const</span> signature = eddsa.<span class="hljs-title function_">signPoseidon</span>(owner.<span class="hljs-property">prvKey</span>, <br />    transactionHash);<br />  <span class="hljs-keyword">return</span> {<br />    <span class="hljs-attr">ownerPubKey</span>: owner.<span class="hljs-property">pubKey</span>,<br />    <span class="hljs-attr">targetAddress</span>: target.<span class="hljs-property">address</span>,<br />    <span class="hljs-attr">nftID</span>: nftID,<br />    <span class="hljs-attr">nonce</span>: nonce,<br />    <span class="hljs-attr">signature</span>: signature<br />  }<br />}</span></pre><p name="e4bd" id="e4bd" class="graf graf--p graf-after--pre">This transaction can be verified with the following Circom circuit:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="81fe" id="81fe" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">pragma circom <span class="hljs-number">2.0</span><span class="hljs-number">.0</span>;<br /><br />include <span class="hljs-string">&quot;../node_modules/circomlib/circuits/eddsaposeidon.circom&quot;</span>;<br />include <span class="hljs-string">&quot;../node_modules/circomlib/circuits/poseidon.circom&quot;</span>;<br /><br />template <span class="hljs-title class_">VerifyTransferRequest</span>() {<br /><br />    signal input targetAddress;<br />    signal input nftID;<br />    signal input nonce;<br /><br />    signal input <span class="hljs-title class_">Ax</span>;<br />    signal input <span class="hljs-title class_">Ay</span>;<br />    signal input S;<br />    signal input R8x;<br />    signal input R8y;<br /><br />    component eddsa = <span class="hljs-title class_">EdDSAPoseidonVerifier</span>();<br />    component poseidon = <span class="hljs-title class_">Poseidon</span>(<span class="hljs-number">3</span>);<br /><br />    <span class="hljs-comment">// calculate the transaction hash</span><br /><br />    poseidon.<span class="hljs-property">inputs</span>[<span class="hljs-number">0</span>] &lt;== targetAddress;<br />    poseidon.<span class="hljs-property">inputs</span>[<span class="hljs-number">1</span>] &lt;== nftID;<br />    poseidon.<span class="hljs-property">inputs</span>[<span class="hljs-number">2</span>] &lt;== nonce;<br /><br />    <span class="hljs-comment">// verify the signature on the transaction hash</span><br /><br />    eddsa.<span class="hljs-property">enabled</span> &lt;== <span class="hljs-number">1</span>;<br />    eddsa.<span class="hljs-property">Ax</span> &lt;== <span class="hljs-title class_">Ax</span>;<br />    eddsa.<span class="hljs-property">Ay</span> &lt;== <span class="hljs-title class_">Ay</span>;<br />    eddsa.<span class="hljs-property">S</span> &lt;== S;<br />    eddsa.<span class="hljs-property">R8x</span> &lt;== R8x;<br />    eddsa.<span class="hljs-property">R8y</span> &lt;== R8y;<br />    eddsa.<span class="hljs-property">M</span> &lt;== poseidon.<span class="hljs-property">out</span>;<br /><br />}</span></pre><p name="eda7" id="eda7" class="graf graf--p graf-after--pre">The first 3 input signals (targetAddress, nftID, nonce) are the data of the transaction, while the next 5 (Ax, Ay, S, R8x, R8y) are the public key and digital signature. The circuit first calculates the poseidon hash from the data of the transaction, then verifies the digital signature and that it belongs to the given public key.</p><p name="3f65" id="3f65" class="graf graf--p graf-after--p">The following code snippet shows how to check the circuit using TypeScript:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="b94a" id="b94a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> transferRequest = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createTransferRequest</span>(accounts[<span class="hljs-number">0</span>], <br />  accounts[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br /><br /><span class="hljs-keyword">const</span> inputs = {<br />  <span class="hljs-attr">targetAddress</span>: <span class="hljs-title function_">buffer2hex</span>(transferRequest.<span class="hljs-property">targetAddress</span>),<br />  <span class="hljs-attr">nftID</span>: transferRequest.<span class="hljs-property">nftID</span>,<br />  <span class="hljs-attr">nonce</span>: <span class="hljs-title function_">buffer2hex</span>(transferRequest.<span class="hljs-property">nonce</span>),<br />  <span class="hljs-title class_">Ax</span>: eddsa.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(transferRequest.<span class="hljs-property">ownerPubKey</span>[<span class="hljs-number">0</span>]),<br />  <span class="hljs-title class_">Ay</span>: eddsa.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(transferRequest.<span class="hljs-property">ownerPubKey</span>[<span class="hljs-number">1</span>]),<br />  <span class="hljs-attr">R8x</span>: eddsa.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(transferRequest.<span class="hljs-property">signature</span>.<span class="hljs-property">R8</span>[<span class="hljs-number">0</span>]),<br />  <span class="hljs-attr">R8y</span>: eddsa.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(transferRequest.<span class="hljs-property">signature</span>.<span class="hljs-property">R8</span>[<span class="hljs-number">1</span>]),<br />  <span class="hljs-attr">S</span>: transferRequest.<span class="hljs-property">signature</span>.<span class="hljs-property">S</span>,<br />}<br /><br /><span class="hljs-keyword">const</span> w = <span class="hljs-keyword">await</span> verifyTransferCircuit.<span class="hljs-title function_">calculateWitness</span>(inputs, <span class="hljs-literal">true</span>);<br /><span class="hljs-keyword">await</span> verifyTransferCircuit.<span class="hljs-title function_">checkConstraints</span>(w);</span></pre><p name="5868" id="5868" class="graf graf--p graf-after--pre">Every input signal of the circuit is a BigNumber. The targetAddress and the nonce are converted to hexadecimal BigNumber format using the bufer2hex function, while the Ax, Ay, R8x, and R8y signals are converted to finite field format using eddsa.F.toObject. This is necessary because, in the world of zero-knowledge proofs, all calculations are done in a finite field. For the targetAddress, the nonce, the nftID, and the S parameter, this is not necessary, since they are already mapped to a finite field.</p><p name="87df" id="87df" class="graf graf--p graf-after--p">I used the <a href="https://github.com/iden3/circom_tester" data-href="https://github.com/iden3/circom_tester" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">circom_tester</a> library to check a circuit, which is a very effective solution for testing circuits since there is no need to compile the circuit for testing. The calculateWitness function calculates the witness which is then checked by checkConstraints.</p><p name="eb07" id="eb07" class="graf graf--p graf-after--p">The next step is to run a full transaction and generate the proof for it:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="14f7" id="14f7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">transferNFT</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"><span class="hljs-keyword">from</span>: Account, to: Account, nftID: <span class="hljs-built_in">number</span></span>) =&gt; {<br />  <span class="hljs-comment">// get the nonce for the NFT</span><br />  <span class="hljs-keyword">const</span> nonce = <span class="hljs-title class_">BigNumber</span>.<span class="hljs-title function_">from</span>(<br />    nonceTrie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>((<span class="hljs-keyword">await</span> nonceTrie.<span class="hljs-title function_">find</span>(nftID)).<span class="hljs-property">foundValue</span>)<br />  ).<span class="hljs-title function_">toNumber</span>()<br /><br />  <span class="hljs-comment">// creating transfer request</span><br />  <span class="hljs-keyword">const</span> transferRequest = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createTransferRequest</span>(<span class="hljs-keyword">from</span>, to, nftID, nonce)<br /><br />  <span class="hljs-comment">// move the NFT to the new owner</span><br />  <span class="hljs-keyword">const</span> nft_res = <span class="hljs-keyword">await</span> trie.<span class="hljs-title function_">update</span>(nftID, transferRequest.<span class="hljs-property">targetAddress</span>)<br /><br />  <span class="hljs-comment">// increase nonce for the NFT</span><br />  <span class="hljs-keyword">const</span> nonce_res = <span class="hljs-keyword">await</span> nonceTrie.<span class="hljs-title function_">update</span>(nftID, transferRequest.<span class="hljs-property">nonce</span> + <span class="hljs-number">1</span>)<br /><br />  <span class="hljs-comment">// generate and check zkp</span><br />  <span class="hljs-keyword">let</span> nft_siblings = <span class="hljs-title function_">convertSiblings</span>(nft_res.<span class="hljs-property">siblings</span>)<br />  <span class="hljs-keyword">let</span> nonce_siblings = <span class="hljs-title function_">convertSiblings</span>(nonce_res.<span class="hljs-property">siblings</span>)<br /><br />  <span class="hljs-keyword">const</span> inputs = {<br />    <span class="hljs-attr">targetAddress</span>: <span class="hljs-title function_">buffer2hex</span>(transferRequest.<span class="hljs-property">targetAddress</span>),<br />    <span class="hljs-attr">nftID</span>: transferRequest.<span class="hljs-property">nftID</span>,<br />    <span class="hljs-attr">nonce</span>: <span class="hljs-title function_">buffer2hex</span>(transferRequest.<span class="hljs-property">nonce</span>),<br />    <span class="hljs-title class_">Ax</span>: eddsa.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(transferRequest.<span class="hljs-property">ownerPubKey</span>[<span class="hljs-number">0</span>]),<br />    <span class="hljs-title class_">Ay</span>: eddsa.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(transferRequest.<span class="hljs-property">ownerPubKey</span>[<span class="hljs-number">1</span>]),<br />    <span class="hljs-attr">R8x</span>: eddsa.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(transferRequest.<span class="hljs-property">signature</span>.<span class="hljs-property">R8</span>[<span class="hljs-number">0</span>]),<br />    <span class="hljs-attr">R8y</span>: eddsa.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(transferRequest.<span class="hljs-property">signature</span>.<span class="hljs-property">R8</span>[<span class="hljs-number">1</span>]),<br />    <span class="hljs-attr">S</span>: transferRequest.<span class="hljs-property">signature</span>.<span class="hljs-property">S</span>,<br />    <span class="hljs-attr">oldRoot</span>: trie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(nft_res.<span class="hljs-property">oldRoot</span>),<br />    <span class="hljs-attr">siblings</span>: nft_siblings,<br />    <span class="hljs-attr">nonceOldRoot</span>: trie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(nonce_res.<span class="hljs-property">oldRoot</span>),<br />    <span class="hljs-attr">nonceSiblings</span>: nonce_siblings<br />  }<br /><br />  <span class="hljs-keyword">const</span> w = <span class="hljs-keyword">await</span> verifyRollupTransactionCircuit.<span class="hljs-title function_">calculateWitness</span>(<br />    inputs, <span class="hljs-literal">true</span><br />  );<br />  <span class="hljs-keyword">await</span> verifyRollupTransactionCircuit.<span class="hljs-title function_">checkConstraints</span>(w);<br />  <span class="hljs-keyword">await</span> verifyRollupTransactionCircuit.<span class="hljs-title function_">assertOut</span>(w, {<br />    <span class="hljs-attr">newRoot</span>: trie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(nft_res.<span class="hljs-property">newRoot</span>),<br />    <span class="hljs-attr">nonceNewRoot</span>: trie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(nonce_res.<span class="hljs-property">newRoot</span>)<br />  });<br /><br />}</span></pre><p name="1dc1" id="1dc1" class="graf graf--p graf-after--pre">As a first step, we read the nonce associated with the NFT to generate the transaction. To run the transaction, we update the SMT from the owner to the new owner and increment the nonce value by one in the nonce SMT. The update function, in addition to performing the modifications, returns the siblings that are needed to prove the operation.</p><p name="7152" id="7152" class="graf graf--p graf-after--p">We check the proper execution of the circuit as usual with the checkConstraints function. If the circuit works correctly, then the two outputs must match the new roots of the SMTs.</p><p name="c658" id="c658" class="graf graf--p graf-after--p">Let’s look at the circuit that verifies the transaction:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="a7ab" id="a7ab" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">pragma circom <span class="hljs-number">2.0</span><span class="hljs-number">.0</span>;<br /><br />include <span class="hljs-string">&quot;verify-transfer-req.circom&quot;</span>;<br />include <span class="hljs-string">&quot;../node_modules/circomlib/circuits/smt/smtprocessor.circom&quot;</span>;<br />include <span class="hljs-string">&quot;../node_modules/circomlib/circuits/poseidon.circom&quot;</span>;<br /><br />template <span class="hljs-title class_">RollupTransactionVerifier</span>(nLevels) {<br /><br />    signal input targetAddress;<br />    signal input nftID;<br />    signal input nonce;<br /><br />    signal input <span class="hljs-title class_">Ax</span>;<br />    signal input <span class="hljs-title class_">Ay</span>;<br />    signal input S;<br />    signal input R8x;<br />    signal input R8y;<br /><br />    signal input oldRoot;<br />    signal input siblings[nLevels];<br /><br />    signal input nonceOldRoot;<br />    signal input nonceSiblings[nLevels];<br /><br />    signal output newRoot;<br />    signal output nonceNewRoot;<br /><br />    component transferRequestVerifier = <span class="hljs-title class_">VerifyTransferRequest</span>();<br />    component smtVerifier = <span class="hljs-title class_">SMTProcessor</span>(nLevels);<br />    component nonceVerifier = <span class="hljs-title class_">SMTProcessor</span>(nLevels);<br />    component poseidon = <span class="hljs-title class_">Poseidon</span>(<span class="hljs-number">2</span>);<br /><br />    <span class="hljs-comment">// verify the transfer request</span><br /><br />    transferRequestVerifier.<span class="hljs-property">targetAddress</span> &lt;== targetAddress;<br />    transferRequestVerifier.<span class="hljs-property">nftID</span> &lt;== nftID;<br />    transferRequestVerifier.<span class="hljs-property">nonce</span> &lt;== nonce;<br /><br />    transferRequestVerifier.<span class="hljs-property">Ax</span> &lt;== <span class="hljs-title class_">Ax</span>;<br />    transferRequestVerifier.<span class="hljs-property">Ay</span> &lt;== <span class="hljs-title class_">Ay</span>;<br />    transferRequestVerifier.<span class="hljs-property">S</span> &lt;== S;<br />    transferRequestVerifier.<span class="hljs-property">R8x</span> &lt;== R8x;<br />    transferRequestVerifier.<span class="hljs-property">R8y</span> &lt;== R8y;<br /><br />    <span class="hljs-comment">// verify the SMT update</span><br />    <span class="hljs-comment">// the old value of the NFT ID key has to be the poseidon hash of </span><br />    <span class="hljs-comment">// the signers public key, </span><br />    <span class="hljs-comment">// the new value is the target address </span><br /><br />    poseidon.<span class="hljs-property">inputs</span>[<span class="hljs-number">0</span>] &lt;== <span class="hljs-title class_">Ax</span>;<br />    poseidon.<span class="hljs-property">inputs</span>[<span class="hljs-number">1</span>] &lt;== <span class="hljs-title class_">Ay</span>;<br /><br />    smtVerifier.<span class="hljs-property">fnc</span>[<span class="hljs-number">0</span>] &lt;== <span class="hljs-number">0</span>;<br />    smtVerifier.<span class="hljs-property">fnc</span>[<span class="hljs-number">1</span>] &lt;== <span class="hljs-number">1</span>;<br />    smtVerifier.<span class="hljs-property">oldRoot</span> &lt;== oldRoot;<br />    smtVerifier.<span class="hljs-property">siblings</span> &lt;== siblings;<br />    smtVerifier.<span class="hljs-property">oldKey</span> &lt;== nftID;<br />    smtVerifier.<span class="hljs-property">oldValue</span> &lt;== poseidon.<span class="hljs-property">out</span>;<br />    smtVerifier.<span class="hljs-property">isOld0</span> &lt;== <span class="hljs-number">0</span>; <br />    smtVerifier.<span class="hljs-property">newKey</span> &lt;== nftID;<br />    smtVerifier.<span class="hljs-property">newValue</span> &lt;== targetAddress;<br /><br />    <span class="hljs-comment">// verify nonce SMT update, the new value has to be the old value + 1</span><br /><br />    nonceVerifier.<span class="hljs-property">fnc</span>[<span class="hljs-number">0</span>] &lt;== <span class="hljs-number">0</span>;<br />    nonceVerifier.<span class="hljs-property">fnc</span>[<span class="hljs-number">1</span>] &lt;== <span class="hljs-number">1</span>;<br />    nonceVerifier.<span class="hljs-property">oldRoot</span> &lt;== nonceOldRoot;<br />    nonceVerifier.<span class="hljs-property">siblings</span> &lt;== nonceSiblings;<br />    nonceVerifier.<span class="hljs-property">oldKey</span> &lt;== nftID;<br />    nonceVerifier.<span class="hljs-property">oldValue</span> &lt;== nonce;<br />    nonceVerifier.<span class="hljs-property">isOld0</span> &lt;== <span class="hljs-number">0</span>; <br />    nonceVerifier.<span class="hljs-property">newKey</span> &lt;== nftID;<br />    nonceVerifier.<span class="hljs-property">newValue</span> &lt;== nonce + <span class="hljs-number">1</span>;<br /><br />    newRoot &lt;== smtVerifier.<span class="hljs-property">newRoot</span>; <br />    nonceNewRoot &lt;== nonceVerifier.<span class="hljs-property">newRoot</span>;<br /><br />}</span></pre><p name="7c8b" id="7c8b" class="graf graf--p graf-after--pre">The RollupTransactionVerifier template has one parameter: the depth of the SMT. The inputs are the digitally signed transaction, the previous roots of the SMT-s, and the siblings. We have to prove that:</p><ul class="postList"><li name="ab79" id="ab79" class="graf graf--li graf-after--p">The transaction is valid</li><li name="5450" id="5450" class="graf graf--li graf-after--li">The address of the user signing the transaction is associated with the NFT moved in the SMT</li><li name="d5e9" id="d5e9" class="graf graf--li graf-after--li">In the SMT the address associated with the NFT was modified to the new address (targetAddress)</li><li name="6ac4" id="6ac4" class="graf graf--li graf-after--li">The nonce was increased by one in the SMT for the associated NFT.</li></ul><p name="0352" id="0352" class="graf graf--p graf-after--li">In the first block, we verify the transaction with the VerifyTransferRequest circuit previously presented.</p><p name="f129" id="f129" class="graf graf--p graf-after--p">In the second block, we validate the SMT modification. To do this, we calculate the address of the transaction signer from the Ax and Ay parameters using a Poseidon hash. The transaction is valid if this address was originally assigned to the NFT.</p><p name="9360" id="9360" class="graf graf--p graf-after--p">We can prove SMT modification with the SMTProcessor circuit. This is a general circuit that is suitable for proving every transformation (insert, update, delete). The fnc signal determines the function of the circuit. If the fnc value is 01, we can prove an update. The transaction is valid if the old value (oldValue) linked to the nftID is the address of the signer of the transaction (the Poseidon hash of the public key) and the new value (newValue) is the tragetAddress specified in the transaction.</p><p name="635e" id="635e" class="graf graf--p graf-after--p">In the third block, we validate that the nonce in SMT has increased by one. If all conditions have been met, then the circuit output is the new root of SMT and the nonce SMT.</p><p name="055d" id="055d" class="graf graf--p graf-after--p">Now that we can validate a transaction, all that is left to do is create the final circuit that can validate a whole batch. This is what the final circuit looks like:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="73ee" id="73ee" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">pragma circom <span class="hljs-number">2.0</span><span class="hljs-number">.0</span>;<br /><br />include <span class="hljs-string">&quot;rollup-tx.circom&quot;</span>;<br />include <span class="hljs-string">&quot;../node_modules/circomlib/circuits/sha256/sha256.circom&quot;</span>;<br />include <span class="hljs-string">&quot;../node_modules/circomlib/circuits/bitify.circom&quot;</span>;<br />include <span class="hljs-string">&quot;../node_modules/circomlib/circuits/poseidon.circom&quot;</span>;<br /><br />template <span class="hljs-title class_">Rollup</span>(nLevels, nTransactions) {<br /><br />    signal input oldRoot;<br />    signal input newRoot;<br /><br />    signal input nonceOldRoot;<br />    signal input nonceNewRoot;<br /><br />    signal input nonceList[nTransactions];<br />    signal input targetAddressList[nTransactions];<br />    signal input nftIDList[nTransactions];<br /><br />    signal input <span class="hljs-title class_">AxList</span>[nTransactions];<br />    signal input <span class="hljs-title class_">AyList</span>[nTransactions];<br />    signal input <span class="hljs-title class_">SList</span>[nTransactions];<br />    signal input R8xList[nTransactions];<br />    signal input R8yList[nTransactions];<br /><br />    signal input siblingsList[nTransactions][nLevels];<br />    signal input nonceSiblingsList[nTransactions][nLevels];<br /><br />    signal input transactionListHash;<br />    signal input oldStateHash;<br />    signal input newStateHash;<br /><br />    <span class="hljs-comment">// verify the transactions in the transaction list, </span><br />    <span class="hljs-comment">// and calculate the new roots</span><br /><br />    <span class="hljs-keyword">var</span> root = oldRoot;<br />    <span class="hljs-keyword">var</span> nonceRoot = nonceOldRoot;<br />    component rollupVerifiers[nTransactions];<br />    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nTransactions; i++) {<br />        rollupVerifiers[i] = <span class="hljs-title class_">RollupTransactionVerifier</span>(nLevels);<br /><br />        rollupVerifiers[i].<span class="hljs-property">targetAddress</span> &lt;== targetAddressList[i];<br />        rollupVerifiers[i].<span class="hljs-property">nftID</span> &lt;== nftIDList[i];<br />        rollupVerifiers[i].<span class="hljs-property">nonce</span> &lt;== nonceList[i];<br /><br />        rollupVerifiers[i].<span class="hljs-property">Ax</span> &lt;== <span class="hljs-title class_">AxList</span>[i];<br />        rollupVerifiers[i].<span class="hljs-property">Ay</span> &lt;== <span class="hljs-title class_">AyList</span>[i];<br />        rollupVerifiers[i].<span class="hljs-property">S</span> &lt;== <span class="hljs-title class_">SList</span>[i];<br />        rollupVerifiers[i].<span class="hljs-property">R8x</span> &lt;== R8xList[i];<br />        rollupVerifiers[i].<span class="hljs-property">R8y</span> &lt;== R8yList[i];<br /><br />        rollupVerifiers[i].<span class="hljs-property">siblings</span> &lt;== siblingsList[i];<br />        rollupVerifiers[i].<span class="hljs-property">oldRoot</span> &lt;== root;<br /><br />        rollupVerifiers[i].<span class="hljs-property">nonceSiblings</span> &lt;== nonceSiblingsList[i];<br />        rollupVerifiers[i].<span class="hljs-property">nonceOldRoot</span> &lt;== nonceRoot;<br /><br />        root = rollupVerifiers[i].<span class="hljs-property">newRoot</span>;<br />        nonceRoot = rollupVerifiers[i].<span class="hljs-property">nonceNewRoot</span>;<br />    }<br /><br />    <span class="hljs-comment">// compute sha256 hash of the transaction list</span><br /><br />    component sha = <span class="hljs-title class_">Sha256</span>(nTransactions * <span class="hljs-number">2</span> * <span class="hljs-number">32</span> * <span class="hljs-number">8</span>);<br />    component address2bits[nTransactions];<br />    component nftid2bits[nTransactions];<br /><br />    <span class="hljs-keyword">var</span> c = <span class="hljs-number">0</span>;<br /><br />    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;nTransactions; i++) {<br />        address2bits[i] = <span class="hljs-title class_">Num2Bits</span>(<span class="hljs-number">32</span> * <span class="hljs-number">8</span>);<br />        address2bits[i].<span class="hljs-property">in</span> &lt;== targetAddressList[i];<br />        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">32</span> * <span class="hljs-number">8</span>; j++) {<br />            sha.<span class="hljs-property">in</span>[c] &lt;== address2bits[i].<span class="hljs-property">out</span>[(<span class="hljs-number">32</span> * <span class="hljs-number">8</span>) - <span class="hljs-number">1</span> - j];<br />            c++;<br />        }<br />    }<br /><br />    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;nTransactions; i++) {<br />        nftid2bits[i] = <span class="hljs-title class_">Num2Bits</span>(<span class="hljs-number">32</span> * <span class="hljs-number">8</span>);<br />        nftid2bits[i].<span class="hljs-property">in</span> &lt;== nftIDList[i];<br />        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">32</span> * <span class="hljs-number">8</span>; j++) {<br />            sha.<span class="hljs-property">in</span>[c] &lt;== nftid2bits[i].<span class="hljs-property">out</span>[(<span class="hljs-number">32</span> * <span class="hljs-number">8</span>) - <span class="hljs-number">1</span> - j];<br />            c++;<br />        }<br />    }<br /><br />    component bits2num = <span class="hljs-title class_">Bits2Num</span>(<span class="hljs-number">256</span>);<br />    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++) {<br />        bits2num.<span class="hljs-property">in</span>[i] &lt;== sha.<span class="hljs-property">out</span>[<span class="hljs-number">255</span> - i];<br />    }<br /><br />    <span class="hljs-comment">// check the constraints</span><br /><br />    transactionListHash === bits2num.<span class="hljs-property">out</span>;<br />    newRoot === root;<br />    nonceNewRoot === nonceRoot;<br /><br />    component oldStateHasher = <span class="hljs-title class_">Poseidon</span>(<span class="hljs-number">2</span>);<br />    oldStateHasher.<span class="hljs-property">inputs</span>[<span class="hljs-number">0</span>] &lt;== oldRoot;<br />    oldStateHasher.<span class="hljs-property">inputs</span>[<span class="hljs-number">1</span>] &lt;== nonceOldRoot;<br /><br />    component newStateHasher = <span class="hljs-title class_">Poseidon</span>(<span class="hljs-number">2</span>);<br />    newStateHasher.<span class="hljs-property">inputs</span>[<span class="hljs-number">0</span>] &lt;== newRoot;<br />    newStateHasher.<span class="hljs-property">inputs</span>[<span class="hljs-number">1</span>] &lt;== nonceNewRoot;<br /><br />    oldStateHash === oldStateHasher.<span class="hljs-property">out</span>;<br />    newStateHash === newStateHasher.<span class="hljs-property">out</span>;<br /><br />}<br /><br />component main {public [oldStateHash, newStateHash, transactionListHash]} = <br />  <span class="hljs-title class_">Rollup</span>(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>);</span></pre><p name="e0b8" id="e0b8" class="graf graf--p graf-after--pre">The main point is the first block where we invoke the RollupTransactionVerifier that we introduced earlier in an iteration. We set the root and the nonceRoot variables to the current root of the SMT and the nonce SMT respectively. Then we execute the transactions sequentially and always update the values of the root and the nonceRoot variables. After executing the transactions, we get the final roots which can be stored on the blockchain. The first version of the rollup only included this block, and the transaction data was public inputs, but it was not very efficient.</p><p name="91ec" id="91ec" class="graf graf--p graf-after--p">If we validate a zero-knowledge proof on-chain with a smart contract, the cost of validation depends on the number of public variables, thus the cost of validation increases with the number of transactions as well. Therefore, I modified the rollup circuit to use the sha256 hash of the transactions instead of the list of transactions. This is sufficient for validating the transactions and only 1 input instead of many. The second block thus calculates the sha256 hash of the transactions and compares it with the transactionListHash input, which is produced by the smart contract. Computing the sha256 hash in a circom circuit is a bit tricky as the order of bits is not trivial, but after a few days of research, reading, and trying out, I found the correct method for calculating the hash.</p><p name="b328" id="b328" class="graf graf--p graf-after--p">At the end of the circuit, there is still a little optimization in block 3. The circuit originally used 2 SMT roots, the NFT state root, and the nonce state root. From these I formed an oldStateHash and a newStateHash value via a Poseidon hash, so instead of 4 the number of state parameters was reduced to 2 and only 1 state root needs to be stored on the blockchain instead of 2. Therefore, the rollup finally had 3 public inputs: the oldStateHash which is the initial state, the transactionListHash which is the sha256 hash of the transaction list and the newStateHash which is the final state that will be stored on the blockchain.</p><p name="8192" id="8192" class="graf graf--p graf-after--p">This is the TypeScript code that produces the zero-knowledge proof using the above circuit, which validates a full batch:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="13c5" id="13c5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">generateBatchTransferZKP</span> = <span class="hljs-title function_ invoke__">async</span> (<span class="hljs-attr">_trie</span>: any, _nonceTrie, <br />  <span class="hljs-attr">transferRequestList</span>: TransferRequest[]) =&gt; {<br />  let targetAddressList = []<br />  let nftIDList = []<br />  let nonceList = []<br />  let AxList = []<br />  let AyList = []<br />  let SList = []<br />  let R8xList = []<br />  let R8yList = []<br />  let siblingsList = []<br />  let nonceSiblingsList = []<br /><br />  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">oldRoot</span> = _trie.F.<span class="hljs-title function_ invoke__">toObject</span>(_trie.root)<br />  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">nonceOldRoot</span> = _nonceTrie.F.<span class="hljs-title function_ invoke__">toObject</span>(_nonceTrie.root)<br /><br />  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">transferRequest</span> of transferRequestList) {<br />    targetAddressList.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">buffer2hex</span>(transferRequest.targetAddress))<br />    nftIDList.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">buffer2hex</span>(transferRequest.nftID))<br />    nonceList.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">buffer2hex</span>(transferRequest.nonce))<br />    AxList.<span class="hljs-title function_ invoke__">push</span>(eddsa.F.<span class="hljs-title function_ invoke__">toObject</span>(transferRequest.ownerPubKey[<span class="hljs-number">0</span>]))<br />    AyList.<span class="hljs-title function_ invoke__">push</span>(eddsa.F.<span class="hljs-title function_ invoke__">toObject</span>(transferRequest.ownerPubKey[<span class="hljs-number">1</span>]))<br />    SList.<span class="hljs-title function_ invoke__">push</span>(transferRequest.signature.S)<br />    R8xList.<span class="hljs-title function_ invoke__">push</span>(eddsa.F.<span class="hljs-title function_ invoke__">toObject</span>(transferRequest.signature.R8[<span class="hljs-number">0</span>]))<br />    R8yList.<span class="hljs-title function_ invoke__">push</span>(eddsa.F.<span class="hljs-title function_ invoke__">toObject</span>(transferRequest.signature.R8[<span class="hljs-number">1</span>]))<br /><br />    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">res</span> = await _trie.<span class="hljs-title function_ invoke__">update</span>(transferRequest.nftID, <br />      transferRequest.targetAddress)<br />    siblingsList.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">convertSiblings</span>(res.siblings))<br /><br />    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">res2</span> = await _nonceTrie.<span class="hljs-title function_ invoke__">update</span>(transferRequest.nftID, <br />      transferRequest.nonce + <span class="hljs-number">1</span>)<br />    nonceSiblingsList.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">convertSiblings</span>(res2.siblings))<br />  }<br /><br /> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">newRoot</span> = _trie.F.<span class="hljs-title function_ invoke__">toObject</span>(_trie.root)<br />  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">nonceNewRoot</span> = _nonceTrie.F.<span class="hljs-title function_ invoke__">toObject</span>(_nonceTrie.root)<br /><br />  let transactionBuffers = []<br />  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">transferRequest</span> of transferRequestList) {<br />    transactionBuffers.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">numToBuffer</span>(transferRequest.targetAddress))<br />  }<br />  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">transferRequest</span> of transferRequestList) {<br />    transactionBuffers.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">numToBuffer</span>(transferRequest.nftID))<br />  }<br />  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">hash</span> = <span class="hljs-title function_ invoke__">createHash</span>(<span class="hljs-string">&quot;sha256&quot;</span>).<span class="hljs-title function_ invoke__">update</span>(Buffer.<span class="hljs-title function_ invoke__">concat</span>(transactionBuffers))<br />    .<span class="hljs-title function_ invoke__">digest</span>(<span class="hljs-string">&quot;hex&quot;</span>)<br />  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ffhash</span> = BigNumber.<span class="hljs-keyword">from</span>(<span class="hljs-string">&#x27;0x&#x27;</span> + hash).<span class="hljs-title function_ invoke__">mod</span>(FIELD_SIZE)<br /><br />  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">oldStateHash</span> = <span class="hljs-title function_ invoke__">poseidon</span>([oldRoot, nonceOldRoot])<br />  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">newStateHash</span> = <span class="hljs-title function_ invoke__">poseidon</span>([newRoot, nonceNewRoot])<br /><br />  <span class="hljs-keyword">return</span> await snarkjs.groth16.<span class="hljs-title function_ invoke__">fullProve</span>(<br />    {<br />      <span class="hljs-attr">targetAddressList</span>: targetAddressList,<br />      <span class="hljs-attr">nftIDList</span>: nftIDList,<br />      <span class="hljs-attr">nonceList</span>: nonceList,<br />      <span class="hljs-attr">AxList</span>: AxList,<br />      <span class="hljs-attr">AyList</span>: AyList,<br />      <span class="hljs-attr">R8xList</span>: R8xList,<br />      <span class="hljs-attr">R8yList</span>: R8yList,<br />      <span class="hljs-attr">SList</span>: SList,<br />      <span class="hljs-attr">siblingsList</span>: siblingsList,<br />      <span class="hljs-attr">nonceSiblingsList</span>: nonceSiblingsList,<br />      <span class="hljs-attr">oldRoot</span>: oldRoot,<br />      <span class="hljs-attr">nonceOldRoot</span>: nonceOldRoot,<br />      <span class="hljs-attr">newRoot</span>: newRoot,<br />      <span class="hljs-attr">nonceNewRoot</span>: nonceNewRoot,<br />      <span class="hljs-attr">transactionListHash</span>: ffhash.<span class="hljs-title function_ invoke__">toHexString</span>(),<br />      <span class="hljs-attr">oldStateHash</span>: poseidon.F.<span class="hljs-title function_ invoke__">toObject</span>(oldStateHash),<br />      <span class="hljs-attr">newStateHash</span>: poseidon.F.<span class="hljs-title function_ invoke__">toObject</span>(newStateHash)<br />    },<br />    <span class="hljs-string">&quot;./build/rollup_js/rollup.wasm&quot;</span>,<br />    <span class="hljs-string">&quot;./build/rollup.zkey&quot;</span>);<br />}</span></pre><p name="f8dc" id="f8dc" class="graf graf--p graf-after--pre">Finally, the smart contract, which stores the state root on the blockchain, as well as validates the zero-knowledge proof:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="19cd" id="19cd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br />pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.19</span>;<br /><br /><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./RollupVerifier.sol&quot;</span>;<br /><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;hardhat/console.sol&quot;</span>;<br /><br />uint256 constant <span class="hljs-variable constant_">FIELD_SIZE</span> = <br />  <span class="hljs-number">21888242871839275222246405745257275088548364400416034343698204186575808495617</span>;<br /><br />interface <span class="hljs-title class_">IVerifier</span> {<br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">verifyProof</span>(<span class="hljs-params"><br />        uint[<span class="hljs-number">2</span>] memory a,<br />        uint[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] memory b,<br />        uint[<span class="hljs-number">2</span>] memory c,<br />        uint[<span class="hljs-number">3</span>] memory input<br />    </span>) external pure returns (bool r);<br />}<br /><br />contract <span class="hljs-title class_">Rollup</span> {<br />    <span class="hljs-title class_">IVerifier</span> public immutable verifier;<br /><br />    event <span class="hljs-title class_">RootChanged</span>(uint newRoot);<br /><br />    uint root;<br /><br />    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">uint _root, IVerifier _verifier</span>) {<br />        root = _root;<br />        verifier = _verifier;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateState</span>(<span class="hljs-params"><br />        uint[<span class="hljs-number">2</span>] calldata _pA,<br />        uint[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] calldata _pB,<br />        uint[<span class="hljs-number">2</span>] calldata _pC,<br />        uint _oldRoot,<br />        uint _newRoot,<br />        uint[<span class="hljs-number">16</span>] calldata transactionList<br />    </span>) external {<br />        <span class="hljs-built_in">require</span>(root == _oldRoot, <span class="hljs-string">&quot;Invalid old root&quot;</span>);<br /><br />        uint256 hash = <span class="hljs-title function_">uint256</span>(<span class="hljs-title function_">sha256</span>(abi.<span class="hljs-title function_">encodePacked</span>(transactionList)));<br />        hash = <span class="hljs-title function_">addmod</span>(hash, <span class="hljs-number">0</span>, <span class="hljs-variable constant_">FIELD_SIZE</span>);<br /><br />        <span class="hljs-built_in">require</span>(<br />            verifier.<span class="hljs-title function_">verifyProof</span>(_pA, _pB, _pC, [hash, _oldRoot, _newRoot]),<br />            <span class="hljs-string">&quot;Verification failed&quot;</span><br />        );<br /><br />        root = _newRoot;<br />        emit <span class="hljs-title class_">RootChanged</span>(root);<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRoot</span>(<span class="hljs-params"></span>) public view virtual returns (uint) {<br />        <span class="hljs-keyword">return</span> root;<br />    }<br /><br />}</span></pre><p name="37c3" id="37c3" class="graf graf--p graf-after--pre">The rollup contract itself is relatively simple. In the constructor, it receives the initial state root and the address of the ZKP verifier contract, which can be generated from snarkjs for the circuit. The contract has a single variable named root which stores the state root and emits a RootChanged event after each batch run.</p><p name="7c64" id="7c64" class="graf graf--p graf-after--p">The contract has a single updateState method. The first three parameters (_pA, _pB, _pC) of the method are the zero-knowledge proof. The _oldRoot is the old state root, the _newRoot is the new state root, and the transactionList is a list of transactions. The list includes a list of NFTs that we are moving and a list of target addresses that are the new owners of the NFTs. Since our example rollup consists of 8 elements, the transactionList will be 16 elements.</p><p name="5467" id="5467" class="graf graf--p graf-after--p">First, check if the _oldRoot matches the root stored in the smart contract. Then calculate the sha256 hash of the transaction list. Since, in the case of ZKP, every calculation is done in a finite field, we need to convert the hash into a finite field, which we do with the addmod function. Then run the validation on the proof, and if everything is OK, set the new root</p><p name="8610" id="8610" class="graf graf--p graf-after--p">This is a TypeScript example code that produces the zero-knowledge proof and calls the smart contract:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="3644" id="3644" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">trie = <span class="hljs-keyword">await</span> <span class="hljs-title function_">newMemEmptyTrie</span>()<br />nonceTrie = <span class="hljs-keyword">await</span> <span class="hljs-title function_">newMemEmptyTrie</span>()<br /><span class="hljs-keyword">let</span> transferRequests = []<br /><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable constant_">BATCH_SIZE</span>; i++) {<br />  <span class="hljs-keyword">await</span> trie.<span class="hljs-title function_">insert</span>(i, accounts[<span class="hljs-number">0</span>].<span class="hljs-property">address</span>)<br />  <span class="hljs-keyword">await</span> nonceTrie.<span class="hljs-title function_">insert</span>(i, <span class="hljs-number">0</span>)<br />  transferRequests.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createTransferRequest</span>(accounts[<span class="hljs-number">0</span>], accounts[<span class="hljs-number">1</span>], i, <span class="hljs-number">0</span>))<br />}<br /><br /><span class="hljs-keyword">const</span> oldRoot = trie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(trie.<span class="hljs-property">root</span>)<br /><span class="hljs-keyword">const</span> nonceOldRoot = nonceTrie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(nonceTrie.<span class="hljs-property">root</span>)<br /><span class="hljs-keyword">const</span> oldStateHash = poseidon.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(<span class="hljs-title function_">poseidon</span>([oldRoot, nonceOldRoot]))<br /><br /><span class="hljs-keyword">const</span> <span class="hljs-title class_">Rollup</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;Rollup&quot;</span>);<br />rollup = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Rollup</span>.<span class="hljs-title function_">deploy</span>(oldStateHash, <span class="hljs-keyword">await</span> rollupVerifier.<span class="hljs-title function_">getAddress</span>());<br /><br /><span class="hljs-keyword">const</span> { proof, publicSignals } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">generateBatchTransferZKP</span>(<br />  trie, nonceTrie, transferRequests<br />)<br /><br /><span class="hljs-keyword">const</span> newRoot = trie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(trie.<span class="hljs-property">root</span>)<br /><span class="hljs-keyword">const</span> nonceNewRoot = nonceTrie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(nonceTrie.<span class="hljs-property">root</span>)<br /><span class="hljs-keyword">const</span> newStateHash = poseidon.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(<span class="hljs-title function_">poseidon</span>([newRoot, nonceNewRoot]))<br /><br /><span class="hljs-keyword">let</span> <span class="hljs-attr">transactionList</span>: <span class="hljs-built_in">any</span> = []<br /><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> transferRequest <span class="hljs-keyword">of</span> transferRequests) {<br />  transactionList.<span class="hljs-title function_">push</span>(transferRequest.<span class="hljs-property">targetAddress</span>)<br />}<br /><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> transferRequest <span class="hljs-keyword">of</span> transferRequests) {<br />  transactionList.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">BigNumber</span>.<span class="hljs-title function_">from</span>(transferRequest.<span class="hljs-property">nftID</span>).<span class="hljs-title function_">toBigInt</span>())<br />}<br /><br /><span class="hljs-keyword">await</span> rollup.<span class="hljs-title function_">updateState</span>(<br />  [proof.<span class="hljs-property">pi_a</span>[<span class="hljs-number">0</span>], proof.<span class="hljs-property">pi_a</span>[<span class="hljs-number">1</span>]],<br />  [[proof.<span class="hljs-property">pi_b</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], proof.<span class="hljs-property">pi_b</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]], [proof.<span class="hljs-property">pi_b</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], proof.<span class="hljs-property">pi_b</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]]],<br />  [proof.<span class="hljs-property">pi_c</span>[<span class="hljs-number">0</span>], proof.<span class="hljs-property">pi_c</span>[<span class="hljs-number">1</span>]],<br />  publicSignals[<span class="hljs-number">1</span>], publicSignals[<span class="hljs-number">2</span>], transactionList<br />)<br /><br />assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">await</span> rollup.<span class="hljs-title function_">getRoot</span>(), newStateHash);</span></pre><p name="b249" id="b249" class="graf graf--p graf-after--pre">At the beginning of the article, we mentioned that the Rollup differs from Validium by storing the transaction list on the blockchain in the calldata. This is important because if anyone wants to submit a new batch to the smart contract, they need to build the SMTs. With Rollup, this can be easily done because every transaction is stored on the blockchain, from which the SMTs can be constructed. Let’s see the code that implements this:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="d246" id="d246" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">trie = <span class="hljs-keyword">await</span> <span class="hljs-title function_">newMemEmptyTrie</span>()<br /> nonceTrie = <span class="hljs-keyword">await</span> <span class="hljs-title function_">newMemEmptyTrie</span>()<br /><br /> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable constant_">BATCH_SIZE</span>; i++) {<br />   <span class="hljs-keyword">await</span> trie.<span class="hljs-title function_">insert</span>(i, accounts[<span class="hljs-number">0</span>].<span class="hljs-property">address</span>)<br />   <span class="hljs-keyword">await</span> nonceTrie.<span class="hljs-title function_">insert</span>(i, <span class="hljs-number">0</span>)<br /> }<br /><br /> <span class="hljs-keyword">const</span> events = <span class="hljs-keyword">await</span> rollup.<span class="hljs-title function_">queryFilter</span>(rollup.<span class="hljs-property">filters</span>.<span class="hljs-property">RootChanged</span>)<br /> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> event <span class="hljs-keyword">of</span> events) {<br />   <span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> event.<span class="hljs-property">provider</span>.<span class="hljs-title function_">getTransaction</span>(event.<span class="hljs-property">transactionHash</span>)<br />   <span class="hljs-keyword">const</span> pubSignals = rollup.<span class="hljs-property">interface</span>.<span class="hljs-title function_">parseTransaction</span>(tx).<span class="hljs-property">args</span>.<span class="hljs-title function_">at</span>(<span class="hljs-number">5</span>)<br />   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable constant_">BATCH_SIZE</span>; i++) {<br />     <span class="hljs-keyword">const</span> address = pubSignals[i];<br />     <span class="hljs-keyword">const</span> nftID = pubSignals[<span class="hljs-variable constant_">BATCH_SIZE</span> + i];<br />     <span class="hljs-keyword">await</span> trie.<span class="hljs-title function_">update</span>(nftID, address)<br />     <span class="hljs-keyword">const</span> nonce = <span class="hljs-title class_">BigNumber</span>.<span class="hljs-title function_">from</span>(<br />       nonceTrie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>((<span class="hljs-keyword">await</span> nonceTrie.<span class="hljs-title function_">find</span>(nftID)).<span class="hljs-property">foundValue</span>)<br />     ).<span class="hljs-title function_">toNumber</span>()<br />     <span class="hljs-keyword">await</span> nonceTrie.<span class="hljs-title function_">update</span>(nftID, nonce + <span class="hljs-number">1</span>)<br />   }<br /><br />   <span class="hljs-keyword">const</span> newRoot = trie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(trie.<span class="hljs-property">root</span>)<br />   <span class="hljs-keyword">const</span> nonceNewRoot = nonceTrie.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(nonceTrie.<span class="hljs-property">root</span>)<br />   <span class="hljs-keyword">const</span> newStateHash = poseidon.<span class="hljs-property">F</span>.<span class="hljs-title function_">toObject</span>(<span class="hljs-title function_">poseidon</span>([newRoot, nonceNewRoot]))<br /><br />   assert.<span class="hljs-title function_">equal</span>(newStateHash, rollup.<span class="hljs-property">interface</span>.<span class="hljs-title function_">parseTransaction</span>(tx).<span class="hljs-property">args</span>.<span class="hljs-title function_">at</span>(<span class="hljs-number">4</span>))</span></pre><p name="de37" id="de37" class="graf graf--p graf-after--pre">As I wrote, a smart contract emits a RootChanged event after each batch run. This is useful because it enables us to collect the transactions from which we can extract the transaction data. In the code above, we query the events with the queryFilter method. The transaction hash associated with the event is available for the full transaction, which can be extracted with the parseTransaction method for the calldata, making the transactions accessible from which the SMT can be reconstructed, which is necessary for submitting new batches.</p><p name="273d" id="273d" class="graf graf--p graf-after--p">In a nutshell, this is how the minimalist NFT rollup works. Let’s have a quick recap.</p><h3 name="38cd" id="38cd" class="graf graf--h3 graf-after--p">The Good</h3><p name="f5bd" id="f5bd" class="graf graf--p graf-after--h3">I compared a traditional NFT contract with a 64-element batch-size rollup. Moving 64 NFTs on-chain cost 2,965,696 gas, while running the 64-element batch cost only 299,575 gas. The cost of moving NFTs on rollup is thus about 10% of the on-chain solution, and we only store one root on the blockchain plus the list of transactions in the calldata (or nothing in the case of validium). This sounds pretty good. Moreover, the cost of ZKP validation does not depend on the number of transactions, so if there were 2x or 4x as many transactions in the batch, it wouldn’t be much more expensive, so even more gas could be saved, and even more space on the blockchain.</p><h3 name="7906" id="7906" class="graf graf--h3 graf-after--p">The Bad</h3><p name="2cc2" id="2cc2" class="graf graf--p graf-after--h3">To compile a circuit, a lot of RAM and computational capability is required. On my laptop (24G RAM, i7) the largest circuit I could compile was around 64 elements. For a larger batch-size circuit (say 256 elements), a huge amount of RAM is needed. The compile time was also around half to one hour, and the fan was really roaring. Thankfully, generating the proof for the batch was much faster, but still had to wait a few minutes. This time can probably be improved a lot by using <a href="https://github.com/iden3/rapidsnark" data-href="https://github.com/iden3/rapidsnark" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">rapidsnark</a> for proof generation, and the technology will also probably improve a lot in the future, for example using GPU or ASICs-based proof generation.</p><h3 name="f8a0" id="f8a0" class="graf graf--h3 graf-after--p">The Ugly</h3><p name="c8f6" id="c8f6" class="graf graf--p graf-after--h3">As I wrote at the beginning of the article, this is a minimalistic solution, whose aim is not efficiency but rather understanding, therefore, a lot more could still be improved.</p><p name="a867" id="a867" class="graf graf--p graf-after--p">Rollups typically compress transaction data to make use of fewer calldata. Our rollup stores addresses in 32 bytes and NFT IDs in 32 bytes as well, so every transaction in the batch uses 64 bytes of calldata. That is 4096 bytes for a 64-element batch. If we were to store NFT IDs in only 4 bytes and introduce a new SMT that maps addresses to IDs, then 4 bytes would be enough to store addresses too. That would mean only 8 bytes per transaction, resulting in only 512 calldata for a 64-element batch.</p><p name="7616" id="7616" class="graf graf--p graf-after--p">The other thing we mentioned is that it is not possible to move NFTs between the rollup and the blockchain, so we have to pre-generate all NFTs and keep them on the rollup only. We did this to keep our code simple. Moving items to rollup (deposits) could be accomplished through the introduction of a new Merkle tree. If someone wants to move an NFT to the rollup, they should lock it in the smart contract and provide the rollup address which will become the owner of the NFT on the rollup. This is stored in a Merkle tree managed by the smart contract. Then, a zero-knowledge proof has to be produced, including an SMT insert proof and an inclusion proof to ensure that the same address is supplied with the NFT in the Merkle tree managed by the smart contract. If all checks out okay, then the NFT will appear on the rollup and can be moved around as previously discussed.</p><p name="92bd" id="92bd" class="graf graf--p graf-after--p">To withdraw an NFT onto the blockchain, an SMT delete proof has to be sent to the rollup contract, digitally signed (with EDDSA) by the current owner of the NFT, and provided an Ethereum address where the smart contract can transfer the NFT.</p><h3 name="138c" id="138c" class="graf graf--h3 graf-after--p">Summary</h3><p name="4424" id="4424" class="graf graf--p graf-after--h3">Zero-knowledge proof technology and zk rollups are some of the hottest fields in the blockchain world where many breakthroughs can be expected. I envision the sole duty of the blockchains of the future being the validation of zk proofs and management of state roots since every asset will exist on rollups. There will be no need to run smart contracts on the blockchain as those will run off-chain and only the state root changes will be written to the blockchain which will be validated by the accompanying zero-knowledge proof. With this solution computing and storage will be much more efficiently distributed and blockchains will be able to much higher performance. An evermore efficient yet decentralized system.</p><p name="63ff" id="63ff" class="graf graf--p graf-after--p">These solutions already exist in our days. An example of this is the <a href="https://minaprotocol.com/" data-href="https://minaprotocol.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">mina protocol</a>, where smart contracts run off-chain and the PoS validators only collect and store the transactions. Mina isn’t a blockchain since it replaces it with recursive proofs. Each block contains a proof of the validity of the previous block. Thanks to this, the “blockchain” of mina is <a href="https://minaprotocol.com/blog/22kb-sized-blockchain-a-technical-reference" data-href="https://minaprotocol.com/blog/22kb-sized-blockchain-a-technical-reference" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">only 22KB in size</a>.</p><p name="09c4" id="09c4" class="graf graf--p graf-after--p">The future is very exciting. It is therefore worthwhile to get acquainted with zero-knowledge proof technology, as it is becoming an increasingly integral part of the blockchain world.</p><p name="5915" id="5915" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Originally published here: </em><a href="https://hackernoon.com/how-to-implement-a-minimalist-nft-zkrollup-with-circom-and-snarkjs" data-href="https://hackernoon.com/how-to-implement-a-minimalist-nft-zkrollup-with-circom-and-snarkjs" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank"><em class="markup--em markup--p-em">https://hackernoon.com/how-to-implement-a-minimalist-nft-zkrollup-with-circom-and-snarkjs</em></a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/b93fd4e326ad"><time class="dt-published" datetime="2024-01-05T17:44:39.813Z">January 5, 2024</time></a>.</p><p><a href="https://medium.com/@thebojda/how-to-implement-a-minimalist-nft-zkrollup-b93fd4e326ad" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 20, 2024.</p></footer></article></body></html>