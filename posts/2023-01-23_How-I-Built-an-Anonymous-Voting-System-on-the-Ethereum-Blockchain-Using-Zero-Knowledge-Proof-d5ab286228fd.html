<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How I Built an Anonymous Voting System on the Ethereum Blockchain Using Zero-Knowledge Proof</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How I Built an Anonymous Voting System on the Ethereum Blockchain Using Zero-Knowledge Proof</h1>
</header>
<section data-field="subtitle" class="p-summary">
I’ve started to deal with the technology of zero-knowledge proofs because I was curious if it was possible to create an anonymous…
</section>
<section data-field="body" class="e-content">
<section name="3b03" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5c0f" id="5c0f" class="graf graf--h3 graf--leading graf--title">How I Built an Anonymous Voting System on the Ethereum Blockchain Using Zero-Knowledge Proof</h3><figure name="f9cb" id="f9cb" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*GPF9OI3ippTjDIl1" data-width="4000" data-height="6000" data-unsplash-photo-id="b0TVblffqco" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*GPF9OI3ippTjDIl1"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/es/@fwed?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/es/@fwed?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Fred Moon</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="c379" id="c379" class="graf graf--p graf-after--figure">I’ve started to deal with the technology of zero-knowledge proofs because I was curious if it was possible to create an <a href="https://medium.com/geekculture/how-to-create-an-anonymous-unhackable-voting-system-on-the-blockchain-ff6f932727b8" data-href="https://medium.com/geekculture/how-to-create-an-anonymous-unhackable-voting-system-on-the-blockchain-ff6f932727b8" class="markup--anchor markup--p-anchor" target="_blank">anonymous, unhackable voting system on the blockchain</a>.</p><p name="1259" id="1259" class="graf graf--p graf-after--p">Paper-based voting (like the Elections) is a very expensive way of voting. I have no exact data, but it costs billions of dollars, and it is always in the air that somebody cheated it.</p><p name="5793" id="5793" class="graf graf--p graf-after--p">A blockchain-based system costs only a fraction of this price, and it is super secure because the blockchain is public and everybody can track everything on it.</p><p name="7e41" id="7e41" class="graf graf--p graf-after--p">The only thing that is untrackable is that who voted to which party thanks to the zero-knowledge proof (for a more detailed explanation, please read my <a href="https://medium.com/geekculture/how-to-create-an-anonymous-unhackable-voting-system-on-the-blockchain-ff6f932727b8" data-href="https://medium.com/geekculture/how-to-create-an-anonymous-unhackable-voting-system-on-the-blockchain-ff6f932727b8" class="markup--anchor markup--p-anchor" target="_blank">previous article</a>). So, blockchain-based voting seems like the holy grail of voting.</p><p name="d9ce" id="d9ce" class="graf graf--p graf-after--p">In my previous article, I promised a simple proof of concept. It is now completed and available on <a href="https://github.com/TheBojda/zktree-vote" data-href="https://github.com/TheBojda/zktree-vote" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>. I will show you how it works in this article.</p><p name="d918" id="d918" class="graf graf--p graf-after--p">The method that I’m using is the same as what is used by <a href="https://github.com/tornadocash/tornado-core" data-href="https://github.com/tornadocash/tornado-core" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tornado Cash</a>. Tornado Cash is a non-custodial Ethereum and ERC20 privacy solution based on zkSNARKs.</p><p name="9a36" id="9a36" class="graf graf--p graf-after--p">The main component of it is a smart contract where you can deposit your money with a commitment that you can withdraw later by a nullifier. One commitment is assigned to only one nullifier, but nobody knows which nullifier is assigned to which commitment.</p><p name="1f29" id="1f29" class="graf graf--p graf-after--p">This is also usable for anonymous voting because everybody should vote only once, but nobody should know which vote is assigned to which voter. (I have a <a href="https://medium.com/better-programming/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" data-href="https://medium.com/better-programming/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="markup--anchor markup--p-anchor" target="_blank">full article</a> about the topic.)</p><p name="1600" id="1600" class="graf graf--p graf-after--p">My voting app is an Ethereum dApp. It is a static page with JavaScript without any backend (the backend is the smart contract on Ethereum). Because of this, it is tough to attack the system, because, on the blockchain, there is no single point of failure.</p><p name="4b16" id="4b16" class="graf graf--p graf-after--p">If you want to test it locally, the easiest way is to run a local blockchain by:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="bash" name="f4aa" id="f4aa" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">npx hardhat node</span></pre><p name="b761" id="b761" class="graf graf--p graf-after--pre">and <a href="https://medium.com/@kaishinaw/connecting-metamask-with-a-local-hardhat-network-7d8cea604dc6" data-href="https://medium.com/@kaishinaw/connecting-metamask-with-a-local-hardhat-network-7d8cea604dc6" class="markup--anchor markup--p-anchor" target="_blank">set up the accounts in MetaMask</a>. We will use the first 2 accounts.</p><p name="5bc0" id="5bc0" class="graf graf--p graf-after--p">In the first step, clone the repo, deploy the smart contracts, and start the app:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="a1d2" id="a1d2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">git <span class="hljs-built_in">clone</span> https://github.com/TheBojda/zktree-vote<br /><span class="hljs-built_in">cd</span> zktree-vote<br />npm i<br />npm run prepare (optional, npm i should run it)<br />npm run deploy<br />npm start</span></pre><p name="c6af" id="c6af" class="graf graf--p graf-after--pre">The dApp uses MetaMask to communicate the blockchain, so if you use it from your desktop browser, MetaMask has to be installed, and if you use it from your mobile phone, open it in the MetaMask application’s embedded browser.</p><p name="3969" id="3969" class="graf graf--p graf-after--p">When you open <a href="http://localhost:1234/" data-href="http://localhost:1234/" class="markup--anchor markup--p-anchor" target="_blank">http://localhost:1234/</a> you will see the menu of the app:</p><figure name="0de9" id="0de9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZxSQhbYe9w6vwB2QHuDqmQ.png" data-width="736" data-height="648" src="https://cdn-images-1.medium.com/max/800/1*ZxSQhbYe9w6vwB2QHuDqmQ.png"></figure><p name="9f64" id="9f64" class="graf graf--p graf-after--figure">Click on the registration to vote to open the registration page.</p><figure name="fd36" id="fd36" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5kg-oQv4tWKVkrSrhcidAQ.png" data-width="730" data-height="1314" src="https://cdn-images-1.medium.com/max/800/1*5kg-oQv4tWKVkrSrhcidAQ.png"></figure><p name="5e5f" id="5e5f" class="graf graf--p graf-after--figure">When you open the page, it automatically generates the commitment and the nullifier in the background, and stores it in the browser’s local storage.</p><p name="6225" id="6225" class="graf graf--p graf-after--p">The validation of the voter can be done in person at the voting place, or online by using a video conferencing system, etc. The validator can use the “Validator tool” for it:</p><figure name="7143" id="7143" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_NR5IZWYISX8raqM3FXZzA.png" data-width="730" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*_NR5IZWYISX8raqM3FXZzA.png"></figure><p name="1da8" id="1da8" class="graf graf--p graf-after--figure">To make it easy, I have added a QR reader to the page, so sending the commitment to the validator can be done by scanning the voter’s QR code, or the voter can copy it and send it in the chat (online validation).</p><p name="e995" id="e995" class="graf graf--p graf-after--p">When the validator checked the voter’s identity by checking her identity card, etc., he sends the commitment to the blockchain with a unique hash that can be the hash of the user’s ID card or any unique identifier.</p><p name="89f9" id="89f9" class="graf graf--p graf-after--p">This ensures that one voter will be registered only once with one commitment, which means she can vote only once.</p><figure name="0fe1" id="0fe1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*4LdXP7WNL3bacmhqp6fVwg.png" data-width="734" data-height="736" src="https://cdn-images-1.medium.com/max/800/1*4LdXP7WNL3bacmhqp6fVwg.png"></figure><p name="3833" id="3833" class="graf graf--p graf-after--figure">The voting process is easy. You choose one option and send it to the blockchain. The app will use the nullifier that is generated in the background.</p><p name="00fa" id="00fa" class="graf graf--p graf-after--p">On the last page, you can check the results of the voting in real time.</p><p name="0968" id="0968" class="graf graf--p graf-after--p">That’s it. Simple and very comfortable way of voting, but it has all of the advantages of paper-based voting without all of the disadvantages.</p><p name="0be2" id="0be2" class="graf graf--p graf-after--p">After this short intro, let’s see some code.</p><p name="9f4e" id="9f4e" class="graf graf--p graf-after--p">To develop this voting dApp, I’ve used my<a href="https://www.npmjs.com/package/zk-merkle-tree" data-href="https://www.npmjs.com/package/zk-merkle-tree" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> zk-merkle-tree</a> library. It is a JavaScript library that uses Tornado Cash’s zkSNARK-based method and hides all of the complexity of zero-knowledge proofs.</p><p name="27c2" id="27c2" class="graf graf--p graf-after--p">I plan to write a full article about this library, so in this article, I won’t write about it in more detail.</p><p name="1649" id="1649" class="graf graf--p graf-after--p">The smart contract of the voting system looks like this:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="bd97" id="bd97" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br />pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.17</span>;<br /><br /><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;zk-merkle-tree/contracts/ZKTree.sol&quot;</span>;<br /><br />contract <span class="hljs-title class_">ZKTreeVote</span> is <span class="hljs-title class_">ZKTree</span> {<br />    address public owner;<br />    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> bool) public validators;<br />    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">uint256</span> =&gt;</span> bool) uniqueHashes;<br />    uint numOptions;<br />    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">uint</span> =&gt;</span> uint) optionCounter;<br /><br />    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><br />        uint32 _levels,<br />        IHasher _hasher,<br />        IVerifier _verifier,<br />        uint _numOptions<br />    </span>) <span class="hljs-title class_">ZKTree</span>(_levels, _hasher, _verifier) {<br />        owner = msg.<span class="hljs-property">sender</span>;<br />        numOptions = _numOptions;<br />        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt;= numOptions; i++) optionCounter[i] = <span class="hljs-number">0</span>;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerValidator</span>(<span class="hljs-params">address _validator</span>) external {<br />        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">sender</span> == owner, <span class="hljs-string">&quot;Only owner can add validator!&quot;</span>);<br />        validators[_validator] = <span class="hljs-literal">true</span>;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerCommitment</span>(<span class="hljs-params"><br />        uint256 _uniqueHash,<br />        uint256 _commitment<br />    </span>) external {<br />        <span class="hljs-built_in">require</span>(validators[msg.<span class="hljs-property">sender</span>], <span class="hljs-string">&quot;Only validator can commit!&quot;</span>);<br />        <span class="hljs-built_in">require</span>(<br />            !uniqueHashes[_uniqueHash],<br />            <span class="hljs-string">&quot;This unique hash is already used!&quot;</span><br />        );<br />        <span class="hljs-title function_">_commit</span>(<span class="hljs-title function_">bytes32</span>(_commitment));<br />        uniqueHashes[_uniqueHash] = <span class="hljs-literal">true</span>;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">vote</span>(<span class="hljs-params"><br />        uint _option,<br />        uint256 _nullifier,<br />        uint256 _root,<br />        uint[<span class="hljs-number">2</span>] memory _proof_a,<br />        uint[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] memory _proof_b,<br />        uint[<span class="hljs-number">2</span>] memory _proof_c<br />    </span>) external {<br />        <span class="hljs-built_in">require</span>(_option &lt;= numOptions, <span class="hljs-string">&quot;Invalid option!&quot;</span>);<br />        <span class="hljs-title function_">_nullify</span>(<br />            <span class="hljs-title function_">bytes32</span>(_nullifier),<br />            <span class="hljs-title function_">bytes32</span>(_root),<br />            _proof_a,<br />            _proof_b,<br />            _proof_c<br />        );<br />        optionCounter[_option] = optionCounter[_option] + <span class="hljs-number">1</span>;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getOptionCounter</span>(<span class="hljs-params">uint _option</span>) external view returns (uint) {<br />        <span class="hljs-keyword">return</span> optionCounter[_option];<br />    }<br />}</span></pre><p name="3bff" id="3bff" class="graf graf--p graf-after--pre">The smart contract is inherited from ZKTree (from the zk-merkle-tree library) and uses its _commit and _nullify methods. The _commit method stores the commitment, and the _nullify method stores the nullifier and verifies the zero-knowledge proof for it.</p><p name="5d44" id="5d44" class="graf graf--p graf-after--p">The owner can add the validators by calling the registerValidator method. Only validators can send a commitment to the smart contract after checking the voter’s identity.</p><p name="312b" id="312b" class="graf graf--p graf-after--p">The last method is getOptionCounter which you can use to query the result of the voting in real-time.</p><p name="6d11" id="6d11" class="graf graf--p graf-after--p">That’s all. Thanks to <a href="https://github.com/TheBojda/zk-merkle-tree" data-href="https://github.com/TheBojda/zk-merkle-tree" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zk-merkle-tree</a>, the voting contract is super simple, every complexity is hidden behind the library.</p><p name="ac31" id="ac31" class="graf graf--p graf-after--p">The dApp itself is a vue.js single-page application. The commitment and the nullifier are generated in the VoterRegistration component by using the generateCommitment from zk-merkle-tree and stored in the local storage.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="2333" id="2333" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-variable language_">this</span>.<span class="hljs-property">commitment</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<br />  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;zktree-vote-commitment&quot;</span>)<br />);<br /><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">commitment</span>) {<br />  <span class="hljs-variable language_">this</span>.<span class="hljs-property">commitment</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">generateCommitment</span>();<br />  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<br />    <span class="hljs-string">&quot;zktree-vote-commitment&quot;</span>,<br />    <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">commitment</span>)<br />  );<br />}</span></pre><p name="5cc7" id="5cc7" class="graf graf--p graf-after--pre">The ValidatorTool component is used by the validator to send the commitment to the blockchain. It reads the contract address from the contracts.json (generated by the deployment process) and sends the commitment with the unique hash to the voting contract.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="438d" id="438d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> abi = [<br />  <span class="hljs-string">&quot;function registerCommitment(uint256 _uniqueHash, uint256 _commitment)&quot;</span>,<br />];<br /><span class="hljs-keyword">const</span> provider = <span class="hljs-keyword">new</span> ethers.<span class="hljs-property">providers</span>.<span class="hljs-title class_">Web3Provider</span>(<br />  (<span class="hljs-variable language_">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">ethereum</span><br />);<br /><span class="hljs-keyword">await</span> provider.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;eth_requestAccounts&quot;</span>, []);<br /><span class="hljs-keyword">const</span> signer = provider.<span class="hljs-title function_">getSigner</span>();<br /><span class="hljs-keyword">const</span> contracts = <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;contracts.json&quot;</span>)).<span class="hljs-title function_">json</span>();<br /><span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(contracts.<span class="hljs-property">zktreevote</span>, abi, signer);<br /><span class="hljs-keyword">try</span> {<br />  <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">registerCommitment</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uniqueHash</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">commitment</span>);<br />} <span class="hljs-keyword">catch</span> (e) {<br />  <span class="hljs-title function_">alert</span>(e.<span class="hljs-property">reason</span>);<br />}</span></pre><p name="0a58" id="0a58" class="graf graf--p graf-after--pre">The Vote component is used by the voter for voting. It generates the ZK proof by using the calculateMerkleRootAndZKProof method from zk-merkle-tree and sends it to the blockchain with the nullifier.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="f5d8" id="f5d8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> commitment = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<br />  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;zktree-vote-commitment&quot;</span>)<br />);<br /><br /><span class="hljs-keyword">const</span> abi = [<br />  <span class="hljs-string">&quot;function vote(uint _option,uint256 _nullifier,uint256 _root, <br />   uint[2] memory _proof_a,uint[2][2] memory _proof_b,<br />   uint[2] memory _proof_c)&quot;</span>,<br />];<br /><span class="hljs-keyword">const</span> provider = <span class="hljs-keyword">new</span> ethers.<span class="hljs-property">providers</span>.<span class="hljs-title class_">Web3Provider</span>(<br />  (<span class="hljs-variable language_">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">ethereum</span><br />);<br /><span class="hljs-keyword">await</span> provider.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;eth_requestAccounts&quot;</span>, []);<br /><span class="hljs-keyword">const</span> signer = provider.<span class="hljs-title function_">getSigner</span>();<br /><span class="hljs-keyword">const</span> contracts = <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;contracts.json&quot;</span>)).<span class="hljs-title function_">json</span>();<br /><span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(contracts.<span class="hljs-property">zktreevote</span>, abi, signer);<br /><span class="hljs-keyword">const</span> cd = <span class="hljs-keyword">await</span> <span class="hljs-title function_">calculateMerkleRootAndZKProof</span>(<br />  contracts.<span class="hljs-property">zktreevote</span>,<br />  signer,<br />  <span class="hljs-variable constant_">TREE_LEVELS</span>,<br />  commitment,<br />  <span class="hljs-string">&quot;verifier.zkey&quot;</span><br />);<br /><span class="hljs-keyword">try</span> {<br />  <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">vote</span>(<br />    <span class="hljs-variable language_">this</span>.<span class="hljs-property">option</span>,<br />    cd.<span class="hljs-property">nullifierHash</span>,<br />    cd.<span class="hljs-property">root</span>,<br />    cd.<span class="hljs-property">proof_a</span>,<br />    cd.<span class="hljs-property">proof_b</span>,<br />    cd.<span class="hljs-property">proof_c</span><br />  );<br />} <span class="hljs-keyword">catch</span> (e) {<br />  <span class="hljs-title function_">alert</span>(e.<span class="hljs-property">reason</span>);<br />}</span></pre><p name="ea26" id="ea26" class="graf graf--p graf-after--pre">As you can see, the code is really simple, because all of the complexity of ZKP is hidden by the zk-merkle-tree library. Based on this code, you can easily build your own voting system.</p><p name="111e" id="111e" class="graf graf--p graf-after--p">Possible improvements:</p><ul class="postList"><li name="3272" id="3272" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Voter whitelisting.</strong> You can build a Merkle tree from the unique hashes of the voters before voting, and check the voter’s existence in it when the validator sends the commitment. It prevents using fake identities.</li><li name="4150" id="4150" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Better validator management.</strong> If there are thousands of validators, then a Merkle tree is a better way to batch-register them. If voters and validators are divided into districts, then you can generate separate Merkle trees for districts, and assign the validators to these trees.</li><li name="a7fd" id="a7fd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Better validation method.</strong> The only way to cheat in this system is if somebody uses a fake identity for voting. This is why validation is very important. There are more methods to prevent malicious validators. For example, the system can randomly choose 2 or 3 validators for one voter. It has very little chance that all of them are malicious. Or it can record the validation process, and other validators randomly check the recorded videos. Cheating on voting is a crime, so it has a very high risk for the validator to be malicious.</li><li name="07d0" id="07d0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Integration of video conferencing systems like </strong><a href="https://github.com/jitsi/jitsi-meet" data-href="https://github.com/jitsi/jitsi-meet" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">Jitsi Meet</strong></a><strong class="markup--strong markup--li-strong">.</strong> Sending the commitment, and the whole validation process can be very easy if the video conferencing system is integrated. Voters can fill out a form with their data and send it before the validation. The validator has to only check the ID card through the camera, and if everything is well, he can send the commitment and the unique hash to the blockchain with a button click.</li><li name="c90b" id="c90b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Digital ID card support.</strong> If the voter has a digital ID card that can be used for digitally signing the commitment, then the whole validation process can be skipped. This method is super cheap because no human resource is needed, so it can be used frequently, and voters can be more involved in decision-making.</li></ul><p name="b883" id="b883" class="graf graf--p graf-after--li"><a href="https://medium.com/geekculture/web3-is-not-about-blockchain-or-decentralization-f78fda0d3f9b" data-href="https://medium.com/geekculture/web3-is-not-about-blockchain-or-decentralization-f78fda0d3f9b" class="markup--anchor markup--p-anchor" target="_blank">Democracy is the most important aspect of blockchain</a>, and Web3 and blockchain-based anonymous voting are the holy grail of it.</p><p name="8f61" id="8f61" class="graf graf--p graf-after--p">I hope this short article and the zk-merkle-tree library can be a good starting point for others to make their own systems that will be used in the real-world one day.</p><p name="c313" id="c313" class="graf graf--p graf-after--p">UPDATE: You can read the introduction article about the zk-merkle-tree library here:</p><div name="0e73" id="0e73" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://thebojda.medium.com/an-introduction-of-zk-merkle-tree-a-javascript-library-for-anonymous-voting-on-ethereum-using-79caa3415d1e" data-href="https://thebojda.medium.com/an-introduction-of-zk-merkle-tree-a-javascript-library-for-anonymous-voting-on-ethereum-using-79caa3415d1e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://thebojda.medium.com/an-introduction-of-zk-merkle-tree-a-javascript-library-for-anonymous-voting-on-ethereum-using-79caa3415d1e"><strong class="markup--strong markup--mixtapeEmbed-strong">An introduction of zk-merkle-tree, a JavaScript library for anonymous voting on Ethereum using…</strong><br><em class="markup--em markup--mixtapeEmbed-em">Anonymity in voting is one of the basic requirements, but on a public network like a blockchain, it’s not trivial to…</em>thebojda.medium.com</a><a href="https://thebojda.medium.com/an-introduction-of-zk-merkle-tree-a-javascript-library-for-anonymous-voting-on-ethereum-using-79caa3415d1e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="24bcdb35861acec634225dee8f24fda3" data-thumbnail-img-id="0*_mbHRS597QvG7gSG" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*_mbHRS597QvG7gSG);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/d5ab286228fd"><time class="dt-published" datetime="2023-01-23T15:35:50.487Z">January 23, 2023</time></a>.</p><p><a href="https://medium.com/@thebojda/how-i-built-an-anonymous-voting-system-on-the-ethereum-blockchain-using-zero-knowledge-proof-d5ab286228fd" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on February 1, 2023.</p></footer></article></body></html>