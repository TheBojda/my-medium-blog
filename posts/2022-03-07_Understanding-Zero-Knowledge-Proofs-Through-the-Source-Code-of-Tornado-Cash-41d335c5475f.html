<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Understanding Zero-Knowledge Proofs Through the Source Code of Tornado Cash</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Understanding Zero-Knowledge Proofs Through the Source Code of Tornado Cash</h1>
</header>
<section data-field="subtitle" class="p-summary">
Dive into the world of smart contracts with Zero-knowledge proof
</section>
<section data-field="body" class="e-content">
<section name="5ce8" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5d97" id="5d97" class="graf graf--h3 graf--leading graf--title">Understanding Zero-Knowledge Proofs Through the Source Code of Tornado Cash</h3><h4 name="93ce" id="93ce" class="graf graf--h4 graf-after--h3 graf--subtitle">Dive into the world of smart contracts with Zero-knowledge proof</h4><figure name="91c3" id="91c3" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*uJmdJkcXqGykJWRm" data-width="1080" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*uJmdJkcXqGykJWRm"><figcaption class="imageCaption">Source: <a href="https://unsplash.com/photos/JrrWC7Qcmhs" data-href="https://unsplash.com/photos/JrrWC7Qcmhs" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://unsplash.com/photos/JrrWC7Qcmhs</a></figcaption></figure><p name="8da5" id="8da5" class="graf graf--p graf-after--figure">Based on <a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof" data-href="https://en.wikipedia.org/wiki/Zero-knowledge_proof" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">Wikipedia</a>, the definition of the Zero Knowledge Proof (ZKP) is the following:</p><blockquote name="2ef7" id="2ef7" class="graf graf--blockquote graf-after--p">… zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that a given statement is true while the prover avoids conveying any additional information apart from the fact that the statement is indeed true. The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information.</blockquote><p name="ecae" id="ecae" class="graf graf--p graf-after--blockquote">The technology of ZKP can be widely used in many different fields like anonymous voting or anonymous money transfer that are difficult to solve on a public database like the blockchain.</p><p name="c7bb" id="c7bb" class="graf graf--p graf-after--p"><a href="https://tornado.cash/" data-href="https://tornado.cash/" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">Tornado Cash</a> is a coin mixer that you can use to anonymize your Ethereum transactions. Because of the logic of the blockchain, every transaction is public. If you have some ETH on your account, you cannot transfer it anonymously, because anybody can follow your transaction history on the blockchain. Coin mixers, like Tornado Cash, can solve this privacy problem by breaking the on-chain link between the source and the destination address by using ZKP.</p><p name="b20f" id="b20f" class="graf graf--p graf-after--p">If you want to anonymize one of your transactions, you have to deposit a small amount of ETH (or ERC20 token) on the Tornado Cash contract (ex.: 1 ETH). After a little while, you can withdraw this 1 ETH with a different account. The trick is that nobody can create a link between the depositor account and the withdrawal account. If hundreds of accounts deposit 1 ETH on one side and the other hundreds of accounts withdraw 1 ETH on the other side, then nobody will be able to follow the path where the money moves. The technical challenge is that smart contract transactions are also public like any other transaction on the Ethereum network. This is the point where ZKP will be relevant.</p><p name="a0be" id="a0be" class="graf graf--p graf-after--p">When you deposit your 1 ETH on the contract, you have to provide a “commitment”. This commitment is stored by the smart contract. When you withdraw 1 ETH on the other side, you have to provide a “nullifier” and a zero-knowledge proof. The nullifier is a unique ID that is in connection with the commitment and the ZKP proves the connection, but nobody knows which nullifier is assigned to which commitment (except the owner of the depositor/withdrawal account).</p><p name="2922" id="2922" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Again: We can prove that one of the commitments is assigned to our nullifier, without revealing our commitment.</strong></p><p name="501f" id="501f" class="graf graf--p graf-after--p">The nullifiers are tracked by the smart contract, so we can withdraw only one deposited ETH with one nullifier.</p><p name="849a" id="849a" class="graf graf--p graf-after--p">Sounds easy? It’s not! :) Let’s go deep inside the technology. But before anything, we have to understand another tricky thing, the <a href="https://en.wikipedia.org/wiki/Merkle_tree" data-href="https://en.wikipedia.org/wiki/Merkle_tree" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">Merkle tree</a>.</p><figure name="73cf" id="73cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*GfKImZAfzpvxdPX4xNJKXg.png" data-width="1131" data-height="720" src="https://cdn-images-1.medium.com/max/800/1*GfKImZAfzpvxdPX4xNJKXg.png"><figcaption class="imageCaption">source: <a href="https://en.wikipedia.org/wiki/Merkle_tree" data-href="https://en.wikipedia.org/wiki/Merkle_tree" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://en.wikipedia.org/wiki/Merkle_tree</a></figcaption></figure><p name="a7f9" id="a7f9" class="graf graf--p graf-after--figure">Merkle trees are hash trees, where the leaves are the elements, and every node is a hash of the child nodes. The root of the tree is the Merkle root, which represents the whole set of elements. If you add, remove, or change any element (leaf) in the tree, the Merkle root will change. The Merkle root is a unique identifier of the set of elements. But how can we use it?</p><figure name="c611" id="c611" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*PdCWjHFRJkUVv6Wr.png" data-width="1400" data-height="541" src="https://cdn-images-1.medium.com/max/800/0*PdCWjHFRJkUVv6Wr.png"></figure><p name="9266" id="9266" class="graf graf--p graf-after--figure">There is another thing called Merkle proof. If I have a Merkle root, you can send me a Merkle proof that proves that an element is in the set that is represented by the root. The figure below shows how is it working. If you want to prove to me that H<em class="markup--em markup--p-em">K</em> is in the set, you have to send me the H<em class="markup--em markup--p-em">L</em>, H<em class="markup--em markup--p-em">IJ</em>, H<em class="markup--em markup--p-em">MNOP</em>, and H<em class="markup--em markup--p-em">ABCDEFGH</em> hashes. Using these hashes I can calculate the Merkle root. If the root is the same as my root then H<em class="markup--em markup--p-em">K</em> is in the set. Where can we use it?</p><p name="fa94" id="fa94" class="graf graf--p graf-after--p">A simple example is whitelisting. Imagine a smart contract that has a method that can be called by only whitelisted users. The problem is that there are 1000 whitelisted accounts. How can you store them on the smart contract? The simple way is to store every account in mapping, but it is very expensive. A cheaper solution is building a Merkle tree, and storing the Merkle root only (1 hash vs 1000 is not bad). If somebody wants to call the method she has to give a Merkle proof (in this case it is a list of 10 hashes) that can be easily validated by the smart contract.</p><p name="7112" id="7112" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Again: A Merkle tree is used to represent a set of elements with one hash (the Merkle root). The existence of an element can be proven by the Merkle proof.</strong></p><p name="a192" id="a192" class="graf graf--p graf-after--p">The next thing that we have to understand is the zero-knowledge proof itself. With ZKP, you can prove that you know something without revealing the thing that you know. For generating a ZKP, you need a circuit. A circuit is something like a small program that has public inputs and outputs, and private inputs. These private inputs are the knowledge that you don’t reveal for the verification, this is why it is called zero-knowledge proof. With ZKP, we can prove that the output can be generated from the inputs with the given circuit.</p><p name="4900" id="4900" class="graf graf--p graf-after--p">A simple circuit looks like this:</p><pre name="3f63" id="3f63" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">pragma circom 2.0.0;<br><br>include &quot;node_modules/circomlib/circuits/bitify.circom&quot;;<br>include &quot;node_modules/circomlib/circuits/pedersen.circom&quot;;<br><br>template Main() {<br>    signal input nullifier;<br>    signal output nullifierHash;<br><br>    component nullifierHasher = Pedersen(248);<br>    component nullifierBits = Num2Bits(248);<br><br>    nullifierBits.in &lt;== nullifier;<br>    for (var i = 0; i &lt; 248; i++) {<br>        nullifierHasher.in[i] &lt;== nullifierBits.out[i];<br>    }<br><br>    nullifierHash &lt;== nullifierHasher.out[0];<br>}<br><br>component main = Main();</code></pre><p name="89da" id="89da" class="graf graf--p graf-after--pre">Using this circuit, we can prove that we know the source of the given hash. This circuit has one input (the nullifier) and one output (the nullifier hash). The default accessibility of the inputs is private, and the outputs are always public. This circuit uses 2 libraries from the Circomlib. <a href="https://github.com/iden3/circomlib" data-href="https://github.com/iden3/circomlib" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">Circomlib</a> is a set of useful circuits. The first library is bitlify that contains bit manipulation methods, and the second is pedersen which contains the Pedersen hasher. Pedersen hashing is a hashing method that can be run efficiently in ZKP circuits. In the body of the Main template, we fill the hasher and calculate the hash. (For more info about the circom language, please take a look at the <a href="https://docs.circom.io/" data-href="https://docs.circom.io/" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">circom documentation</a>)</p><p name="eba5" id="eba5" class="graf graf--p graf-after--p">For generating the zero-knowledge proof, you will need a proving key. This is the most sensitive part of ZKP because using the source data that is used to generate the proving key, anybody could generate fake proofs. This source data is called the “toxic waste” that has to be dropped. Because of this, there is a “ceremony” for generating the proving key. The ceremony has many members and every member contribute to the proving key. Only one non-malicious member is enough to generate a valid proving key. Using the private inputs, the public inputs, and the proving key, the ZKP system can run the circuit and generate the Proof and the outputs.</p><figure name="65d2" id="65d2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*jFHwERxrnWyuEBHZ.png" data-width="351" data-height="194" src="https://cdn-images-1.medium.com/max/800/0*jFHwERxrnWyuEBHZ.png"></figure><p name="f683" id="f683" class="graf graf--p graf-after--figure">There is a validation key for the proving key that can be used for the validation. The validation system uses the public inputs, the outputs, and the validation key to validate the proof.</p><figure name="1dae" id="1dae" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*SlVAKC2jfKq1c4Dk.png" data-width="471" data-height="211" src="https://cdn-images-1.medium.com/max/800/0*SlVAKC2jfKq1c4Dk.png"></figure><p name="23d1" id="23d1" class="graf graf--p graf-after--figure">Snarkjs is a full-featured tool to generate the proving key and the verification key by the ceremony, generate the proof, and validate it. It can also generate a smart contract for the verification, that can be used by any other contract to validate the zero-knowledge proof. For more information, please look at the <a href="https://github.com/iden3/snarkjs" data-href="https://github.com/iden3/snarkjs" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">snarkjs documentation</a>.</p><p name="91d5" id="91d5" class="graf graf--p graf-after--p">Now, we have everything to understand how Tornado Cash (TC) works. When you deposit 1 ETH on the TC contract, you have to provide a commitment hash. This commitment hash will be stored in a Merkle tree. When you withdraw this 1 ETH with a different account, you have to provide 2 zero-knowledge proofs. The first proves that the Merkel tree contains your commitment. This proof is a zero-knowledge proof of a Merkle proof. But this is not enough, because you should be allowed to withdraw this 1 ETH only once. Because of this, you have to provide a nullifier that is unique for the commitment. The contract stores this nullifier, this ensures that you don’t be able to withdraw the deposited money more than one time.</p><p name="90f0" id="90f0" class="graf graf--p graf-after--p">The uniqueness of the nullifier is ensured by the commitment generation method. The commitment is generated from the nullifier and a secret by hashing. If you change the nullifier then the commitment will change, so one nullifier can be used for only one commitment. Because of the one-way nature of hashing, it’s not possible to link the commitment and the nullifier, but we can generate a ZKP for it.</p><figure name="bf4e" id="bf4e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*4L6nd2nGRKyd-b2w.png" data-width="219" data-height="121" src="https://cdn-images-1.medium.com/max/800/0*4L6nd2nGRKyd-b2w.png"></figure><p name="3c84" id="3c84" class="graf graf--p graf-after--figure">After the theory, let’s see how the <a href="https://github.com/tornadocash/tornado-core/blob/master/circuits/withdraw.circom" data-href="https://github.com/tornadocash/tornado-core/blob/master/circuits/withdraw.circom" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">withdraw circuit of TC</a> looks like:</p><pre name="46b8" id="46b8" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">include &quot;../node_modules/circomlib/circuits/bitify.circom&quot;;<br>include &quot;../node_modules/circomlib/circuits/pedersen.circom&quot;;<br>include &quot;merkleTree.circom&quot;;</code></pre><pre name="bef7" id="bef7" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// computes Pedersen(nullifier + secret)<br>template CommitmentHasher() {<br>    signal input nullifier;<br>    signal input secret;<br>    signal output commitment;<br>    signal output nullifierHash;</code></pre><pre name="44ac" id="44ac" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    component commitmentHasher = Pedersen(496);<br>    component nullifierHasher = Pedersen(248);<br>    component nullifierBits = Num2Bits(248);<br>    component secretBits = Num2Bits(248);<br>    nullifierBits.in &lt;== nullifier;<br>    secretBits.in &lt;== secret;<br>    for (var i = 0; i &lt; 248; i++) {<br>        nullifierHasher.in[i] &lt;== nullifierBits.out[i];<br>        commitmentHasher.in[i] &lt;== nullifierBits.out[i];<br>        commitmentHasher.in[i + 248] &lt;== secretBits.out[i];<br>    }</code></pre><pre name="2237" id="2237" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    commitment &lt;== commitmentHasher.out[0];<br>    nullifierHash &lt;== nullifierHasher.out[0];<br>}</code></pre><pre name="51c5" id="51c5" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// Verifies that commitment that corresponds to given secret and nullifier is included in the merkle tree of deposits<br>template Withdraw(levels) {<br>    signal input root;<br>    signal input nullifierHash;<br>    signal private input nullifier;<br>    signal private input secret;<br>    signal private input pathElements[levels];<br>    signal private input pathIndices[levels];</code></pre><pre name="0cdf" id="0cdf" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    component hasher = CommitmentHasher();<br>    hasher.nullifier &lt;== nullifier;<br>    hasher.secret &lt;== secret;<br>    hasher.nullifierHash === nullifierHash;</code></pre><pre name="7af3" id="7af3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    component tree = MerkleTreeChecker(levels);<br>    tree.leaf &lt;== hasher.commitment;<br>    tree.root &lt;== root;<br>    for (var i = 0; i &lt; levels; i++) {<br>        tree.pathElements[i] &lt;== pathElements[i];<br>        tree.pathIndices[i] &lt;== pathIndices[i];<br>    }<br>}</code></pre><pre name="e1d2" id="e1d2" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">component main = Withdraw(20);</code></pre><p name="9d79" id="9d79" class="graf graf--p graf-after--pre">The first template is the CommitmentHasher. It has two inputs, the nullifier and the secret which are two random 248-bit numbers. The template calculates the nullifier hash and the commitment hash which is a hash of the nullifier and the secret as I wrote before.</p><p name="30b9" id="30b9" class="graf graf--p graf-after--p">The second template is the Withdraw itself. It has 2 public inputs, the Merkle root, and the nullifierHash. The Merkle root is needed to verify the Merkle proof, and the nullifierHash is needed by the smart contract to store it. The private input parameters are the nullifier, the secret, and the pathElements and pathIndices of the Merkle proof. The circuit checks the nullifier by generating the commitment from it and from the secret and also checks the given Merkle proof. If everything is fine, the zero-knowledge proof will be generated that can be validated by the TC smart contract.</p><p name="b638" id="b638" class="graf graf--p graf-after--p">You can find the smart contracts in the <a href="https://github.com/tornadocash/tornado-core/tree/master/contracts" data-href="https://github.com/tornadocash/tornado-core/tree/master/contracts" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">contracts folder</a> in the repo. The Verifier is generated from the circuit. It is used by the Tornado contract to verify the ZKP for the given nullifier hash and Merkle root.</p><p name="d86a" id="d86a" class="graf graf--p graf-after--p">The easiest way to use the contract is the <a href="https://github.com/tornadocash/tornado-core/blob/master/src/cli.js" data-href="https://github.com/tornadocash/tornado-core/blob/master/src/cli.js" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">command-line interface</a>. It is written in JavaScript, and its source code is relatively simple. You can easily find where the parameters and the ZKP are generated and used to call the smart contract.</p><p name="f2ca" id="f2ca" class="graf graf--p graf-after--p">Zero-knowledge proof is relatively new in the crypto world. The math behind it is really complex and hard to understand, but tools like <code class="markup--code markup--p-code">snarkjs</code> and <code class="markup--code markup--p-code">circom</code> make it easy to use. I hope, this article helps you to understand this “magical” technology, and you can use ZKP in your next project.</p><p name="9d89" id="9d89" class="graf graf--p graf-after--p graf--trailing">Happy coding…</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/41d335c5475f"><time class="dt-published" datetime="2022-03-07T18:16:15.437Z">March 7, 2022</time></a>.</p><p><a href="https://medium.com/@thebojda/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 31, 2022.</p></footer></article></body></html>