<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>TensorFlow alapozó</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">TensorFlow alapozó</h1>
</header>
<section data-field="subtitle" class="p-summary">
(neurális hálózatok, tenzorok és képfelismerés a gyakorlatban)
</section>
<section data-field="body" class="e-content">
<section name="785f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="60b2" id="60b2" class="graf graf--h3 graf--leading graf--title">TensorFlow alapozó</h3><h4 name="e369" id="e369" class="graf graf--h4 graf-after--h3 graf--subtitle">(neurális hálózatok, tenzorok és képfelismerés a gyakorlatban)</h4><p name="fe25" id="fe25" class="graf graf--p graf-after--h4">Napjaink egyik legnépszerűbb témája a mesterséges intelligencia és a gépi tanulás. Akit mélyebben érdekel ez a terület, az előbb-utóbb bele fog futni a TensorFlow-ba ami a Google mesterséges intelligencia megoldáscsomagja. A programkönyvtár segítségével például olyan nyalánkságokat fejleszthetünk, mint a konvolúciós mély neurális hálóztok (Convolutional Deep Neural Networks‎), amik a tárgyakat képeken felismerni képes rendszerek lelkét képezik. Ez az írás egy kis alapozó azok számára, akik TensorFlow-val szeretnének foglalkozni. Az írás második felében szeretném majd egy rövid példán keresztül bemutatni, hogy hogyan működik a rendszer a gyakorlatban, így annak megértéséhez alap Python tudásra lehet majd szükség. Az írás többi része alap programozó tudással (vagy akár anélkül is) értelmezhető.</p><p name="b2e5" id="b2e5" class="graf graf--p graf-after--p">Vágjunk is bele a közepébe. Elsőként érdemes tisztázni, hogy mit jelent a tenzor (tensor) a TensorFlow-ban. Ráment pár órám, hogy értelmezni próbáljam a tenzor fogalmát a fellelhető matematikai definíciók alapján. Végül úgy döntöttem, jobban járok ha megnézek pár TensorFlow-s kódot. Ekkor kellett rádöbbennem, hogy a tenzor nem más mint egy tömb. Szinte hallom a távolban ahogy a fizikusok és matematikusok felszisszennek erre a definícióra, mondván hogy a tömb maximum a tenzor reprezentációja, nem a tenzor maga, de a lényegen ez sokat nem változtat. Van 1 dimenziós tenzor (számok listája), amit vektor néven is szoktunk emlegetni, van 2 dimenziós tenzor (számok listájának listája), amit mátrixnak is szoktunk hívni, és persze a tenzor lehet 3 vagy több dimenziós is (számok listájának listájának listája, stb.). A TensorFlow segítségével gráfokat építhetünk aminek minden csomópontja egy tenzor transzformáció. Ezt a gráfot hívjuk modellnek. A legtöbb esetben a modell egy sima szekvenciális gráf, tehát olyan mint egy cső amibe egyik oldalon betolunk egy tenzort, a csőben végigmegy pár transzformáción, a végén pedig a transzformációk eredményeként kijön egy másik tenzor. A transzformációs gráfon tehát tenzorok “folynak” végig, innen származik a TensorFlow név, ami tenzor folyamot jelent.</p><p name="62cc" id="62cc" class="graf graf--p graf-after--p">Szép-szép ez a tenzor folyam dolog, de hogy lesz ebből mesterséges intelligencia és neurális hálózat? Vegyünk egy egyszerű példát: Egy olyan neurális hálózatot, ami eldönti, hogy egy képen kutya vagy cica látható. A hálózat bemenete egy kép, ami leképezhető egy 3 dimenziós tenzorra, aminek az egyik dimenziója a szélesség, a másik a magasság, a harmadik pedig az egyes szín összetevők. Egy 32x32 pixeles RGB kép például egy 32x32x3 méretű tenzorral (tömbbel) írható le. Ha a kép szürkeárnyalatos lenne, akkor elég lenne egy 32x32-es mátrix (32x32x1). Ez lesz tehát a modell bemenete. A kimenet egy 2 elemű vektor (1 dimenziós tenzor), ahol mindkét elem egy valós szám 0–1-ig. Az első szám azt mondja meg, hogy a képen látható dolog mennyire cica, a másik pedig hogy mennyire kutya (mennyire tartozik a cica vagy a kutya osztályba). A cicákat és kutyákat felismerő neurális hálózatunk tehát felfogható egy doboznak ami tenzor transzformációkat tartalmaz és egy 3d-s tenzort képez le 1d-s tenzorrá. Hasonló doboz például egy arcfelismerő rendszer is. A bemenet itt is egy 3d-s tenzor, a kimenet pedig egy vektor (1d-s tenzor). Itt általában annyi a különbség, hogy a kimeneti vektor egy fix méretű (pl. 256 elem) tulajdonság vektor (feature vector). A cicás/kutyás példával ellentétben itt nem tudjuk, hogy a vektor egyes elemei mit jelentenek, csak annyit tudunk, hogy ezek jellemzőek az adott arcra. Ha fel akarunk ismertetni egy betanított arcot, akkor a hálózattal elkészítjük a feature vectort, majd összehasonlítjuk az adatbázisunkban lévő más feature vectorokkal. Ha találunk olyan vektort ami bizonyos hibahatáron belül hasonlít a minta vektorhoz, akkor megvan a keresett arc. Minden egyes neurális hálózat felfogható olyan dobozként, aminek a bemenete egy tenzor, a kimenete pedig egy másik tenzor. A kérdés már csak az, hogy mi van a dobozban?</p><p name="1e05" id="1e05" class="graf graf--p graf-after--p">Egy neurális hálózat a nevéből adódóan mesterséges neuronok hálózata. Egy mesterséges neuron a következőképpen néz ki:</p><figure name="66a1" id="66a1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*T4ARzySpEQvEnr_9pc78pg.jpeg" data-width="1500" data-height="712" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*T4ARzySpEQvEnr_9pc78pg.jpeg"><figcaption class="imageCaption">Forrás: <a href="https://medium.com/@jayeshbahire/the-artificial-neural-networks-handbook-part-4-d2087d1f583e" data-href="https://medium.com/@jayeshbahire/the-artificial-neural-networks-handbook-part-4-d2087d1f583e" class="markup--anchor markup--figure-anchor" target="_blank">https://medium.com/@jayeshbahire/the-artificial-neural-networks-handbook-part-4-d2087d1f583e</a></figcaption></figure><p name="e030" id="e030" class="graf graf--p graf-after--figure">A neuronnak súlyozott bemenetei vannak, ami annyit jelent, hogy minden bemeneti értéket megszorzunk egy w számmal (az első x1 bemenet w1-el, a második x2 bemenet w2-vel, stb.). A neuron ezeket a bemeneteket összegzi, ehhez jön még egy bemenetektől független módosító (bias), majd egy kimeneti függvényen (aktivációs függvény) keresztül előáll a neuron kimenete. A neurális hálózat ilyen neuronok hálózata.</p><figure name="db2c" id="db2c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*A4WUBZkjiNRrN-20qDso9Q.png" data-width="236" data-height="284" src="https://cdn-images-1.medium.com/max/800/1*A4WUBZkjiNRrN-20qDso9Q.png"><figcaption class="imageCaption">Forrás: <a href="https://hu.wikipedia.org/wiki/Mesters%C3%A9ges_neur%C3%A1lis_h%C3%A1l%C3%B3zat" data-href="https://hu.wikipedia.org/wiki/Mesters%C3%A9ges_neur%C3%A1lis_h%C3%A1l%C3%B3zat" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://hu.wikipedia.org/wiki/Mesters%C3%A9ges_neur%C3%A1lis_h%C3%A1l%C3%B3zat</a></figcaption></figure><p name="0c5f" id="0c5f" class="graf graf--p graf-after--figure">A hálózatnak van tehát X db bemenete, ezt követi egy vagy több rejtett réteg, majd egy utolsó réteg, ami a kimenetet adja. Egy ilyen hálózatot a súlyok (a bemenetet szorzó w értékek) állítgatásával lehet paraméterezni és megvalósítható vele bármilyen logikai függvény, sőt, ha megengedett a visszacsatolás, úgy a neurális háló lehet Turing-teljes. Ez utóbbi azt jelenti, hogy bármilyen létező algoritmus (program) leképezhető neurális hálózattal. Elképzelhetjük ezt úgy is mint egy dobozt, aminek van bizonyos számú be és kimenete, valamint van rajta egy csomó csavargatható potméter. A potméterek megfelelő beállításával bármilyen program létrehozható. Eddig persze nem annyira érdekes a dolog, hiszen egy függvényt, vagy egy algoritmust egyszerűbb leprogramozni mint potméterek beállítgatásával megadni. A varázslat abban rejlik, hogy a potmétereket nem nekünk kell kézzel becsavargatni ugyanis ezt megoldja helyettünk a tanítási algoritmus. A mi feladatunk csak annyi, hogy elég mintát (tehát bemenetet és hozzá tartozó elvárt kimenetet) adjunk a rendszernek. A tanító algoritmus minden egyes mintát átfuttat a neurális hálózaton, majd összehasonlítja a kimenetet az elvárt kimenettel. Az eltérések alapján beállítja a potmétereket, majd fix lépésben ismétli a folyamatot, vagy addig, amíg a kimenet és az elvárt kimenetek közti hiba egy adott hibahatár alá kerül. Pont ugyanúgy hangolgatja a hálózatot mint a hangmérnökök a potmétereket a megfelelő hangzás érdekében. Ez jól láthatóan egy hagyományostól eltérő programozási paradigma, hiszen míg hagyományos esetben a programot egy programozó írja, addig itt egy rendszer hozza létre a minták alapján. Az így létrejött programok működését komplexitásuk miatt képtelenség átlátni, de ennek ellenére működnek. <strong class="markup--strong markup--p-strong">Olyan programokat tudunk tehát létrehozni, amiket amúgy képtelenek lennénk megírni</strong> és ez az ami miatt olyan izgalmas a mesterséges intelligencia. Ehhez viszont nagyon sok minta kell. Nem csoda hát, hogy a mesterséges intelligencia és a bigdata kéz a kézben járnak. Bigdata nélkül ugyanis nincs jó MI.</p><p name="af57" id="af57" class="graf graf--p graf-after--p">Mielőtt fejest ugranánk a kódolásba, még egy témáról szerettem volna írni, ez pedig a konvolúciós hálózatok témája. A konvolúciós neurális hálózat olyan neurális hálózat, ami tartalmaz konvolúciós réteget. A konvolúció a képfeldolgozásból lehet ismerős. Arról van szó, hogy létrehozunk egy kis “alhálózatot”, aminek a bemenete egy X*X méretű mátrix, és ezt a kis alhálózatot ismételgetjük meg a bemeneti mátrixon 1 vagy több pixellel eltolva.</p><figure name="918f" id="918f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nDCLdHdKK32s8PohosPxwQ.gif" data-width="1280" data-height="720" src="https://cdn-images-1.medium.com/max/800/1*nDCLdHdKK32s8PohosPxwQ.gif"><figcaption class="imageCaption">Forrás: <a href="http://machinelearninguru.com/computer_vision/basics/convolution/convolution_layer.html" data-href="http://machinelearninguru.com/computer_vision/basics/convolution/convolution_layer.html" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">http://machinelearninguru.com/computer_vision/basics/convolution/convolution_layer.html</a></figcaption></figure><p name="2728" id="2728" class="graf graf--p graf-after--figure">A konvolúciós réteg segítségével primitív mintákat ismerhetünk fel a kép bármely részén, majd ezek alapján újabb konvolúciós rétegek már komplexebb mintákat találhatnak meg. Megfelelő mélység esetén olyan komplex dolgokat is képesek felismerni mint egy macska, vagy épp egy jelzőtábla (pl. egy önvezető autó esetén). Itt ragadnám meg az alkalmat, hogy feloldjak egy látszólagos ellentmondást. Az írás elején azt mondtam, hogy a neurális hálózatokat nem kell programozni, mivel a tanítás során alakul ki a program, ezzel ellentétben az előbbiekben modellekről és a neurális hálózatok programozásáról írtam. Most akkor kell programozni a neurális hálózatokat, vagy nem? Nos, elméletben létezhet olyan neurális hálózat, ami bármilyen programot képes megvalósítani, ugyanakkor ez olyan sok paraméterrel rendelkezne, hogy nem lehetne értelmes időn belül betanítani. Amikor megadjuk a hálózat modelljét vagy topológiáját, akkor tulajdonképpen előhuzalozzuk azt. Ezzel radikálisan csökken a paraméterek száma, a tanításhoz szükséges idő és a szükséges számítási kapacitás. Jó példa erre az előbb említett konvolúciós réteg. Ha adott egy 32x32 pixeles szürkeárnyalatos kép, akkor egy erre felhúzott 32x32-es teljesen összekapcsolt általános háló is képes lenne megtanulni a konvolúciós mintát, de ehhez 32x32 (1024 db) súly értékét kellene meghatározni. Ezzel szemben egy 3x3-as konvolúciós minta esetén csupán 9 db súly meghatározása szükséges, ami jóval egyszerűbb. Ezért vált lehetségessé a konvolúciós réteg által, hogy a gyakorlatban is használható képfelismerő rendszerek jöjjenek létre a neurális hálózatok felhasználásával. A mesterséges intelligencia tehát nem váltja ki a programozók munkáját, csupán máshová helyeződik a fókusz. Míg általános esetben a programozó feladata az algoritmusok megírása, addig a neurális hálók esetén az adatok megfelelő előfeldolgozása és a neurális hálózat topológiájának és modelljének megalkotása a cél. Magát az algoritmust már a tanítás hozza létre. Éppen ezért a neurális hálózatok programozása felfogható egyfajta “metaprogramozásként”.</p><p name="ea44" id="ea44" class="graf graf--p graf-after--p">Most hogy értjük a neurális hálózatok működését, lássuk hogy képezhetőek le ezek tenzor folyamokká. Arról már írtam, hogy a hálózat bemenete és kimenete hogyan képezhető le tenzorok segítségével, arról viszont nem beszéltem, hogy maga a hálózat hogyan írható le tenzorokkal. Ahogyan az előzőekben láthattuk, a neurális hálóknál leggyakrabban használt művelet a bemenetek súlyokkal való beszorzása és összegzése. Ha valaki emlékszik még matek óráról a mátrixok szorzására, beugorhat neki, hogy ott pont ezt kell csinálni. Ha van X db bemenet és Y db neuron, akkor az Y db neuronban képződő összeget megkaphatjuk úgy, hogy egy X elemű vektort (1 dimenziós tenzor) beszorzunk egy Y*X méretű súlyokat tartalmazó mátrixszal (2 dimenziós tenzor), hiszen ennek eredménye pont egy olyan Y elemű vektor, ami a súlyozott összegeket tartalmazza. A mátrix szorzás azért is jó, mert van hozzá szuper jó célhardverünk, mégpedig a gépben lévő videókártya GPU-ja (vagy újabban a TPU, ami direkt MI-re lett kifejlesztve). A GPU-nak pont az az erőssége, hogy sok párhuzamos mátrix szorzást tud elvégezni nagyon gyorsan. Ezért van az, hogy a mesterséges intelligencia alkalmazások esetén sokszor sokkal fontosabb az, hogy milyen GPU van a gépben, mint az, hogy milyen CPU. Az összegképzéshez hasonlóan a kimeneti függvény alkalmazása is egy tenzor transzformáció, ami az Y elemű vektort egy másik Y elemű vektorba képzi le. Ez alapján nézzük meg, hogyan néz ki a második ábrán látható 3 bemenettel, 4 rejtett neuronnal és 2 kimenettel rendelkező neurális háló tenzor transzformációs gráfja. A bemenet egy 3 elemű vektor (1 dimenziós tenzor). Az első transzformáció ezt szorozza be egy 3x4 méretű súlymátrixszal (2 dimenziós tenzor). Az eredmény egy 4 elemű vektor (1 dimenziós tenzor). A következő transzformáció a kimeneti függvény alkalmazása, ami a 4 elemű vektort egy másik 4 elemű vektorba képzi le. Ez a 4 elemű vektor tehát a rejtett réteg kimenete. A következő transzformáció ezt szorozza be egy 4x2 méretű súlymátrixszal, így előállítva az összegeket. Erre alkalmazzuk a kimeneti függvényt, ami egy 2 elemű vektort képez 2 elemű vektorrá, így megadva a hálózat kimenetét. Ezzel kész is a tenzor gráfunk, ami egy 3 elemű, 1 dimenziós tenzort (vektort) képez le egy 2 elemű 1 dimenziós tenzorrá, amihez egy 3x4 és egy 4x2 méretű kétdimenziós paraméter tenzort (mátrixot) használ. A tanítás során ennek a két paraméter mátrixnak az értékei fognak megfelelő módon beállni, ezzel megvalósítva a kívánt működést.</p><p name="7d96" id="7d96" class="graf graf--p graf-after--p">Most, hogy tisztában vagyunk az alapokkal, nézzük hogyan működik mindez a gyakorlatban. Bár a keretrendszer telepítéséhez és a kódok futtatásához némi Python tudás szükséges, úgy gondolom, hogy a főbb részek enélkül is érthetőek.</p><p name="1334" id="1334" class="graf graf--p graf-after--p">A lenti kódok kipróbálhatóak a <a href="https://colab.research.google.com/gist/TheBojda/fe580f63fa4aa4c124dee1374fb1377f/tensorflow_keras_basics.ipynb" data-href="https://colab.research.google.com/gist/TheBojda/fe580f63fa4aa4c124dee1374fb1377f/tensorflow_keras_basics.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Google Colab-ban</a> is. Érdemes egy új lapfülön megnyitni a notebookot, így olvasás közben rögtön látható is a futás eredménye.</p><p name="d536" id="d536" class="graf graf--p graf-after--p">Ha inkább a saját gépünkön futtatnánk a kódokat, úgy elsőként telepítsük a kertrendszert és pár szükséges programkönyvtárat.</p><pre name="705d" id="705d" class="graf graf--pre graf-after--p">pip3 install tensorflow matplotlib numpy</pre><p name="a572" id="a572" class="graf graf--p graf-after--pre">Ha ez megvan, neki is kezdhetünk a neurális háló tanításának. Lássuk is a kódot:</p><figure name="8c89" id="8c89" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/TheBojda/f297544cc4864b2b10c2aad965339c58.js"></script><figcaption class="imageCaption">Forrás: <a href="https://gist.github.com/TheBojda/f297544cc4864b2b10c2aad965339c58" data-href="https://gist.github.com/TheBojda/f297544cc4864b2b10c2aad965339c58" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://gist.github.com/TheBojda/f297544cc4864b2b10c2aad965339c58</a></figcaption></figure><p name="3812" id="3812" class="graf graf--p graf-after--figure">Az első pár sor a <a href="https://www.cs.toronto.edu/~kriz/cifar.html" data-href="https://www.cs.toronto.edu/~kriz/cifar.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CIFAR10</a> teszt mintahalmaz betöltésére szolgál, amiben felcímkézett képeket találunk a tanításhoz.</p><pre name="d5c7" id="d5c7" class="graf graf--pre graf-after--p">(train_images, train_labels), (test_images, test_labels) = datasets.cifar10.load_data() </pre><p name="77b4" id="77b4" class="graf graf--p graf-after--pre">A train_images és a train_labels tenzorokba kerülnek a tanításhoz használt képek és címkék, míg a test_images és test_labels-be azok, amivel majd kipróbáljuk a neurális hálót.</p><p name="c396" id="c396" class="graf graf--p graf-after--p">A CIFAR adatbázis 32x32 pixeles 24bites képeket tartalmaz 3 dimenziós 32x32x3 méretű tenzorok formájában, így minden kép tulajdonképpen 3 db mátrixból áll. Mind a vörös, mind a kék, mind a zöld szín összetevőhöz tartozik egy mátrix ami 0–255-ös tartományban tartalmaz számokat. A következő sor ezt a tenzort normalizálja, hogy az egyes értékek 0–1 tartományba essenek.</p><pre name="d1ff" id="d1ff" class="graf graf--pre graf-after--p">train_images, test_images = train_images / 255.0, test_images / 255.0</pre><p name="ddee" id="ddee" class="graf graf--p graf-after--pre">A következő pár sor a mintahalmazt jeleníti meg a matplotlib segítségével, aminek az eredménye valahogy így néz ki:</p><figure name="9679" id="9679" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SZK4xU8_YzqIwntpEDb1gA.png" data-width="1000" data-height="986" src="https://cdn-images-1.medium.com/max/800/1*SZK4xU8_YzqIwntpEDb1gA.png"></figure><p name="f167" id="f167" class="graf graf--p graf-after--figure">Ezután következik a kód igazán lényeges része, a modell felépítése:</p><pre name="be64" id="be64" class="graf graf--pre graf-after--p">model = models.Sequential()<br>model.add(layers.Conv2D(32, (3, 3), activation=’relu’, input_shape=(32, 32, 3)))<br>model.add(layers.MaxPooling2D((2, 2)))<br>model.add(layers.Conv2D(64, (3, 3), activation=’relu’))<br>model.add(layers.MaxPooling2D((2, 2)))<br>model.add(layers.Conv2D(64, (3, 3), activation=’relu’))<br>model.add(layers.Flatten())<br>model.add(layers.Dense(64, activation=’relu’))<br>model.add(layers.Dense(10, activation=’softmax’))<br>model.summary()</pre><p name="54e9" id="54e9" class="graf graf--p graf-after--pre">Az első sor hozza létre a modellt, ami egy tenzor transzformációs gráf. Jelen esetben egy egyszerű szekvenciális gráf fog készülni, ahol egymást követik a transzformációk.</p><p name="6adf" id="6adf" class="graf graf--p graf-after--p">A model.summary() egy összegzést mutat a modellünkről.</p><pre name="4fd3" id="4fd3" class="graf graf--pre graf-after--p">Model: “sequential”<br>_________________________________________________________________<br>Layer (type) Output Shape Param # <br>=================================================================<br>conv2d (Conv2D) (None, 30, 30, 32) 896 <br>_________________________________________________________________<br>max_pooling2d (MaxPooling2D) (None, 15, 15, 32) 0 <br>_________________________________________________________________<br>conv2d_1 (Conv2D) (None, 13, 13, 64) 18496 <br>_________________________________________________________________<br>max_pooling2d_1 (MaxPooling2 (None, 6, 6, 64) 0 <br>_________________________________________________________________<br>conv2d_2 (Conv2D) (None, 4, 4, 64) 36928 <br>_________________________________________________________________<br>flatten (Flatten) (None, 1024) 0 <br>_________________________________________________________________<br>dense (Dense) (None, 64) 65600 <br>_________________________________________________________________<br>dense_1 (Dense) (None, 10) 650 <br>=================================================================<br>Total params: 122,570<br>Trainable params: 122,570<br>Non-trainable params: 0<br>_________________________________________________________________</pre><p name="b4cd" id="b4cd" class="graf graf--p graf-after--pre">Az első transzformáció egy konvolúció egy 3x3-as szűrővel. A bemenet egy 32x32x3-as tenzor (a kép), a kimeneti függvény pedig a ReLu, ami 0-nál kisebb érték esetén 0-t ad vissza, afelett pedig a bemeneti értéket. Az első 32-es (channel) paraméter azt jelenti, hogy 32 db ilyen konvolúciós szűrő fog létrejönni, melyek mindegyike külön paraméterezhető. A transzformáció kimenete így egy 30x30x32-es dimenziós tenzor, mivel a konvolúciós szűrő a 3 db 32x32-es mátrixot (a képet) 30x30-as mátrixra fogja leképezni és ebből készül 32 db. Ennek megfelelően ez a transzformáció 896 db állítható súly paraméterrel rendelkezik. Ez úgy jön ki, hogy egy 3x3-as szűrő 9 paramétert jelent. Mivel a bemenet 3 mátrixból áll, ezért ez már 27 paraméter. Ehhez jön még egy bemenettől független szám (angolul bias, amit nem tudom hogy lehetne magyarra fordítani), ami így 28-ra növeli a paraméterek számát. Ha pedig megszorozzuk a 28-at a 32 csatornával, kijön a 896 paraméter.</p><p name="aec4" id="aec4" class="graf graf--p graf-after--p">A következő szűrő egy maximumkiválasztás egy 2x2-es sablont használva. Ennek a szűrőnek nincs paramétere és a bemeneti 30x30x32-es tenzort egy 15x15x32-esre képzi le.</p><p name="b46c" id="b46c" class="graf graf--p graf-after--p">A maximumkiválasztást egy újabb konvolúció követi, azt egy újabb maximumkiválasztás, majd még egy konvolúció.</p><p name="a84a" id="a84a" class="graf graf--p graf-after--p">Ezt követi egy Flatten transzformáció, ami “kihajtogatja” a bemeneti tenzort. Így lesz a bemenő 4x4x64-es 3 dimenziós tenzorból egy 1024 elemű vektor (1 dimenziós tenzor).</p><p name="5ecd" id="5ecd" class="graf graf--p graf-after--p">Az ezt követő Dense transzformáció 64 db neuront hoz létre. A Dense tulajdonképpen a “hagyományos” neurális réteg. Minden neuron bemenetként megkapja az előző réteg kimenetét, így minden neuronnak 1024 bemenete lesz. Ez 1024 súlyt plusz egy bemenettől független bias-t jelent neurononként, így az összes neuron 65600 paraméterrel szabályozható, a kimeneti függvény pedig a már ismertetett ReLu.</p><p name="3c09" id="3c09" class="graf graf--p graf-after--p">Az utolsó réteg egy az előzőhöz hasonló Dense transzformáció, csak ez esetben 10 neuronnal, és softmax kimeneti függvénnyel. A <a href="https://en.wikipedia.org/wiki/Softmax_function" data-href="https://en.wikipedia.org/wiki/Softmax_function" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">softmax</a> lényege, hogy a kimeneteket 0–1 tartományba hozza úgy, hogy a kimenetek összege 1 legyen (ezt úgy éri el, hogy a kimenetek exponenciális függvényét darabonként elosztja az összes kimenet exponenciális függvényének összegével). A softmax kimenete tulajdonképpen egy százalékos eloszlás a kimenetek közt, ezért is szeretik osztályozó hálózatok kimeneti függvényeként használni. Az így keletkező 10 elemű vektor tehát azt fogja megmondani, hogy az előre meghatározott 10 kategória közül melyikbe mennyire tartozik bele a bemeneti kép.</p><p name="e5c5" id="e5c5" class="graf graf--p graf-after--p">Megvan tehát a hálózatunk, ami a 32x32x3 méretű 3 dimenziós tenzorként ábrázolt képeket 10 elemű vektorokra (1 dimenziós tenzor) képzi le, ezzel osztályozva a bemeneti mintát.</p><p name="a6bd" id="a6bd" class="graf graf--p graf-after--p">A következő lépés a modell tanításának konfigurálása, amit a compile metódussal tudunk megtenni.</p><pre name="7375" id="7375" class="graf graf--pre graf-after--p">model.compile(optimizer=’adam’, loss=’sparse_categorical_crossentropy’, metrics=[‘accuracy’])<br><br></pre><p name="412d" id="412d" class="graf graf--p graf-after--pre">Mivel ez csak egy alapozó írás, most nem nagyon részletezném, hogy melyik paraméter mit jelent. Elég annyit tudni, hogy az optimalizáláshoz (a potméterek beállításához) az <a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam" data-href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ADAM</a> algoritmust fogjuk használni, a hibát pedig a <a href="https://ml-cheatsheet.readthedocs.io/en/latest/loss_functions.html#cross-entropy" data-href="https://ml-cheatsheet.readthedocs.io/en/latest/loss_functions.html#cross-entropy" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">sparse_categorical_crossentropy</a> függvénnyel mérjük, ami azt mondja meg, hogy mennyire jó az osztályozás.</p><p name="459d" id="459d" class="graf graf--p graf-after--p">A konfigurálást követően jöhet a tanítás, amire a fit metódus szolgál.</p><pre name="f48b" id="f48b" class="graf graf--pre graf-after--p">history = model.fit(train_images, train_labels, epochs=10, validation_data=(test_images, test_labels))</pre><p name="12b9" id="12b9" class="graf graf--p graf-after--pre">A metódus első két paramétere a tanító minta és a címkék. Ez az amit be szeretnénk tanítani a hálózatnak. A következő (epochs) paraméter azt mondja meg, hogy hány iterációban történjen a tanítás. Végül a validation_data az a tesztadat készlet amivel egy tanítási fázis után tesztelhetjük a hálózatunk hatékonyságát. A tanítás végeztével kapunk egy history-t amit a matplotlibbel megjelenítve láthatjuk hogyan javult a hálózat hatékonysága az egyes tanítási fázisok alatt.</p><figure name="6edf" id="6edf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FVeA9RX5ScOphT3-8ha4yg.png" data-width="640" data-height="480" src="https://cdn-images-1.medium.com/max/800/1*FVeA9RX5ScOphT3-8ha4yg.png"></figure><p name="ba3a" id="ba3a" class="graf graf--p graf-after--figure">Az ábrán a vonalak szépen mutatják hogyan javult a hálózat hatékonysága az egyes tanítási ciklusokat követően.</p><p name="0e0a" id="0e0a" class="graf graf--p graf-after--p">A kód végén a save metódussal elmentjük a betanított hálózatunkat, hogy később bármikor elővehessük és használhassuk azt.</p><pre name="fd56" id="fd56" class="graf graf--pre graf-after--p">model.save(‘my_model.h5’)</pre><p name="de94" id="de94" class="graf graf--p graf-after--pre">Összegezzük tehát mit is építettünk: Létrehoztunk egy neurális hálózatot aminek van 3072 db (32x32x3) bemeneti neuronja és 10 db kimeneti neuronja. Azt szeretnénk elérni, hogy ha a hálózat repülőt “lát”, az 1. neuron aktiválódjon, ha autót, akkor a 2., stb. Ehhez felépítettünk egy hálózatot, ami 122 570 db paraméterrel rendelkezik. Ennyi darab potméter van a fekete dobozunkon amit a tanítás során a tanító algoritmus állítgathat. A 10 lépésből álló tanítást követően a hálózat kb. 70%-os hatásfokkal működik, tehát a teszt minták közül az esetek 70%-ban jól ismeri fel azt, hogy mi van a képen.</p><p name="6512" id="6512" class="graf graf--p graf-after--p">Most, hogy ilyen szépen betanítottuk a hálózatunkat, nincs más hátra, mint használni azt. Erre szolgál a következő python kód.</p><figure name="ac35" id="ac35" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/TheBojda/4b5a0e7023d3e209321e7a459c208dd0.js"></script></figure><p name="66cb" id="66cb" class="graf graf--p graf-after--figure">A kód elején a load_model metódussal betöltjük az előzőleg betanított modellt, majd a már megszokott módon betöltjük a CIFAR10-es teszt adathalmazt. Ezt követi két matplotlibes segédfüggvény ami majd az eredmény megjelenítésére fog szolgálni. Ezek működését most ennél jobban nem részletezném. Ami lényeges, az a modell predict függvényének használata.</p><pre name="f4ae" id="f4ae" class="graf graf--pre graf-after--p">predictions = model.predict(test_images[i:i+1])</pre><p name="540e" id="540e" class="graf graf--p graf-after--pre">A predict függvény paramétere egy bemeneteket tartalmazó tömb, a kimenete pedig azokat a kimeneteket fogja tartalmazni amit az adott bemenetekre a neurális háló ad. A fenti esetben az i. teszt kép lesz a bemenet, a kimenet pedig az a 10 elemű vektor, amit a hálózat visszaad. Az eredmény grafikusan megjelenítve valahogy így néz ki:</p><figure name="f623" id="f623" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Z7nAnR5bSe8wZqon7Y-s1w.png" data-width="600" data-height="300" src="https://cdn-images-1.medium.com/max/800/1*Z7nAnR5bSe8wZqon7Y-s1w.png"></figure><p name="17c7" id="17c7" class="graf graf--p graf-after--figure">A fenti képen látható, hogy a hálózatunk 91%-os biztonsággal felismerte, hogy a képen egy cica látható. A kutya és a béka neuron még picit aktiválódott, de toronymagasan a cica neuron vezet.</p><p name="b673" id="b673" class="graf graf--p graf-after--p">Körülbelül ennyit terveztem írni a tensorflow alapjairól. A cikkből kiderült, hogy mi az a tenzor, mik a neurális hálózatok, és végül össze is raktunk egy hálózatot ami egész magabiztosan ismer fel cicákat képeken. Remélem többen vannak azok, akiknek meghoztam a kedvét a tensorflow-val való kísérletezgetéshez, mint azok, akiknek elvettem. Akit mélyebben érdekel a téma, a neten rengeteg anyagot talál. Persze mindenképp érdemes a <a href="https://www.tensorflow.org/" data-href="https://www.tensorflow.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tensorflow hivatalos honlapjáról</a> indulni, illetve azon belül is a <a href="https://www.tensorflow.org/guide/keras" data-href="https://www.tensorflow.org/guide/keras" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Keras API</a>-val indítani, amit a fenti példában mi is használtunk.</p><p name="7385" id="7385" class="graf graf--p graf-after--p">Akit mélyebben érdekel, hogy hogyan működik a neurális hálók tanítása, az olvashat róla a <a href="https://medium.com/@thebojda/tensorflow-alapoz%C3%B3-2-14720a33aca" data-href="https://medium.com/@thebojda/tensorflow-alapoz%C3%B3-2-14720a33aca" class="markup--anchor markup--p-anchor" target="_blank">Tensorflow alapozó 2. részében</a>.</p><div name="2374" id="2374" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://medium.com/@thebojda/tensorflow-alapoz%C3%B3-2-14720a33aca" data-href="https://medium.com/@thebojda/tensorflow-alapoz%C3%B3-2-14720a33aca" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@thebojda/tensorflow-alapoz%C3%B3-2-14720a33aca"><strong class="markup--strong markup--mixtapeEmbed-strong">Tensorflow alapozó 2.</strong><br><em class="markup--em markup--mixtapeEmbed-em">(backpropagation, avagy hogyan működik a varázslat)</em>medium.com</a><a href="https://medium.com/@thebojda/tensorflow-alapoz%C3%B3-2-14720a33aca" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="acf8cadc94685ee340590198b4aca40e" data-thumbnail-img-id="1*YTDwPXrnfbPndXxNw77O-w.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*YTDwPXrnfbPndXxNw77O-w.png);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/d2d1ee97c9db"><time class="dt-published" datetime="2019-10-22T06:08:01.922Z">October 22, 2019</time></a>.</p><p><a href="https://medium.com/@thebojda/tensorflow-alapoz%C3%B3-d2d1ee97c9db" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 14, 2020.</p></footer></article></body></html>