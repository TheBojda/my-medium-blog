<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>An introduction of zk-merkle-tree, a JavaScript library for anonymous voting on Ethereum using…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">An introduction of zk-merkle-tree, a JavaScript library for anonymous voting on Ethereum using…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Anonymity in voting is one of the basic requirements, but on a public network like a blockchain, it’s not trivial to implement it…
</section>
<section data-field="body" class="e-content">
<section name="0dae" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="da45" id="da45" class="graf graf--h3 graf--leading graf--title">An introduction of zk-merkle-tree, a JavaScript library for anonymous voting on Ethereum using zkSNARK</h3><figure name="45f4" id="45f4" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*_mbHRS597QvG7gSG" data-width="4820" data-height="3084" data-unsplash-photo-id="BcjdbyKWquw" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*_mbHRS597QvG7gSG"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@tinaflour?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@tinaflour?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Kristina Flour</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="ef4f" id="ef4f" class="graf graf--p graf-after--figure">Anonymity in voting is one of the basic requirements, but on a public network like a blockchain, it’s not trivial to implement it. Fortunately, the technology of zero-knowledge proofs (ZKP) makes it possible, but unfortunately, ZKP is a very complex technology. This is why I built <a href="https://www.npmjs.com/package/zk-merkle-tree" data-href="https://www.npmjs.com/package/zk-merkle-tree" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zk-merkle-tree</a>, a JavaScript library that hides almost every complexity of <a href="https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof" data-href="https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zkSNARK</a>.</p><p name="5029" id="5029" class="graf graf--p graf-after--p">There are other libraries like <a href="https://semaphore.appliedzkp.org/" data-href="https://semaphore.appliedzkp.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">semaphore</a>, that solve this problem. The advantage of <a href="https://github.com/TheBojda/zk-merkle-tree" data-href="https://github.com/TheBojda/zk-merkle-tree" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zk-merkle-tree</a> is that it is very simple. I also have an <a href="https://github.com/TheBojda/zktree-vote" data-href="https://github.com/TheBojda/zktree-vote" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">example project</a>, where you can see, how you can use it in your own project.</p><p name="e2e5" id="e2e5" class="graf graf--p graf-after--p">In this article, I will show you step by step how I built this library based on the source code of the coin mixer application, <a href="https://github.com/tornadocash/tornado-core" data-href="https://github.com/tornadocash/tornado-core" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tornado Cash</a>, so this article will be not only a library introduction but a tutorial on how you can build a general zkSNARK based application.</p><p name="5dae" id="5dae" class="graf graf--p graf-after--p">I have previous articles about <a href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" data-href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zero-knowledge proofs</a> and <a href="https://medium.com/better-programming/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" data-href="https://medium.com/better-programming/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" class="markup--anchor markup--p-anchor" target="_blank">zkSNARK</a>. It is strongly recommended to read them before this article because this article is based on them.</p><p name="86b4" id="86b4" class="graf graf--p graf-after--p">The first thing that I want to talk about is hashing. In the Ethereum world, we are using variations of the SHA algorithm (SHA-256, Keccak-256, etc.) for hashing. Unfortunately, the calculation of ZKP by using these algorithms is expensive, so we have to use ZK-friendly hashing. There are some ZK-friendly algorithms, like MiMC and Pedersen that are used by Tornado Cash (and also zk-merkle-tree), or Poseidon which is used by semaphore. These hashes can be calculated cheaply in ZK circuits, but are a little bit more expensive on the blockchain than the SHA variations.</p><p name="4313" id="4313" class="graf graf--p graf-after--p">Tornado Cash and zk-merkle-tree are using MiMC hashes for building the Merkle tree. <a href="https://github.com/iden3/circomlibjs" data-href="https://github.com/iden3/circomlibjs" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Circonlibjs</a> contains an implementation of it and a smart contract generator that you can use to deploy it to the blockchain.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="09a4" id="09a4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiMCSponge</span> = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">ContractFactory</span>(<br />  mimcSpongecontract.<span class="hljs-property">abi</span>, <br />  mimcSpongecontract.<span class="hljs-title function_">createCode</span>(<span class="hljs-variable constant_">SEED</span>, <span class="hljs-number">220</span>), <br />  signers[<span class="hljs-number">0</span>]<br />)<br />mimcsponge = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MiMCSponge</span>.<span class="hljs-title function_">deploy</span>()</span></pre><p name="f09f" id="f09f" class="graf graf--p graf-after--pre">The code above is from <a href="https://github.com/TheBojda/zk-merkle-tree/blob/main/test/zktree_test.ts" data-href="https://github.com/TheBojda/zk-merkle-tree/blob/main/test/zktree_test.ts" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zktree_test.ts</a> and uses <a href="https://docs.ethers.org/v5/" data-href="https://docs.ethers.org/v5/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ethers</a> to deploy the MiMC hash contract to the blockchain.</p><p name="9de3" id="9de3" class="graf graf--p graf-after--p">The hasher on the JS side can be generated by the following:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="fd6c" id="fd6c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">mimc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">buildMimcSponge</span>();</span></pre><p name="5d1e" id="5d1e" class="graf graf--p graf-after--pre">You can test your contract by this code:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="db61" id="db61" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> mimcsponge[<span class="hljs-string">&quot;MiMCSponge&quot;</span>](<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br /><span class="hljs-keyword">const</span> res2 = mimc.<span class="hljs-title function_">hash</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br />assert.<span class="hljs-title function_">equal</span>(res.<span class="hljs-property">xL</span>.<span class="hljs-title function_">toString</span>(), mimc.<span class="hljs-property">F</span>.<span class="hljs-title function_">toString</span>(res2.<span class="hljs-property">xL</span>));<br />assert.<span class="hljs-title function_">equal</span>(res.<span class="hljs-property">xR</span>.<span class="hljs-title function_">toString</span>(), mimc.<span class="hljs-property">F</span>.<span class="hljs-title function_">toString</span>(res2.<span class="hljs-property">xR</span>));</span></pre><p name="9457" id="9457" class="graf graf--p graf-after--pre">The first line calculates the hash by using the smart contract, and the second line also calculates it by the JS function. The only interesting part is the number-to-string conversion by <em class="markup--em markup--p-em">F.toString</em>. In zk-SNARK, every calculation is done in a finite field, so we have to use <em class="markup--em markup--p-em">mimc.F.toString</em> for the conversion.</p><p name="865c" id="865c" class="graf graf--p graf-after--p">Now we can calculate ZK-friendly MiMC hashes, so everything is ready to build the Merkle tree. The Solidity implementation of the Merkle tree is fully imported from TornadoCash:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="7661" id="7661" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// based on https://github.com/tornadocash/tornado-core/blob/master/contracts/MerkleTreeWithHistory.sol</span><br /><br /><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br />pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.17</span>;<br /><br /><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;hardhat/console.sol&quot;</span>;<br /><br />interface <span class="hljs-title class_">IHasher</span> {<br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">MiMCSponge</span>(<span class="hljs-params"><br />        uint256 in_xL,<br />        uint256 in_xR,<br />        uint256 k<br />    </span>) external pure returns (uint256 xL, uint256 xR);<br />}<br /><br />contract <span class="hljs-title class_">MerkleTreeWithHistory</span> {<br />    uint256 public constant <span class="hljs-variable constant_">FIELD_SIZE</span> =<br />        <span class="hljs-number">21888242871839275222246405745257275088548364400416034343698204186575808495617</span>;<br />    uint256 public constant <span class="hljs-variable constant_">ZERO_VALUE</span> =<br />        <span class="hljs-number">21663839004416932945382355908790599225266501822907911457504978515578255421292</span>; <span class="hljs-comment">// = keccak256(&quot;tornado&quot;) % FIELD_SIZE</span><br />    <span class="hljs-title class_">IHasher</span> public immutable hasher;<br /><br />    uint32 public levels;<br /><br />    <span class="hljs-comment">// the following variables are made public for easier testing and debugging and</span><br />    <span class="hljs-comment">// are not supposed to be accessed in regular code</span><br /><br />    <span class="hljs-comment">// filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because</span><br />    <span class="hljs-comment">// it removes index range check on every interaction</span><br />    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">uint256</span> =&gt;</span> bytes32) public filledSubtrees;<br />    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">uint256</span> =&gt;</span> bytes32) public roots;<br />    uint32 public constant <span class="hljs-variable constant_">ROOT_HISTORY_SIZE</span> = <span class="hljs-number">30</span>;<br />    uint32 public currentRootIndex = <span class="hljs-number">0</span>;<br />    uint32 public nextIndex = <span class="hljs-number">0</span>;<br /><br />    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">uint32 _levels, IHasher _hasher</span>) {<br />        <span class="hljs-built_in">require</span>(_levels &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;_levels should be greater than zero&quot;</span>);<br />        <span class="hljs-built_in">require</span>(_levels &lt; <span class="hljs-number">32</span>, <span class="hljs-string">&quot;_levels should be less than 32&quot;</span>);<br />        levels = _levels;<br />        hasher = _hasher;<br /><br />        <span class="hljs-keyword">for</span> (uint32 i = <span class="hljs-number">0</span>; i &lt; _levels; i++) {<br />            filledSubtrees[i] = <span class="hljs-title function_">zeros</span>(i);<br />        }<br /><br />        roots[<span class="hljs-number">0</span>] = <span class="hljs-title function_">zeros</span>(_levels - <span class="hljs-number">1</span>);<br />    }<br /><br />    <span class="hljs-comment">/**<br />    <span class="hljs-doctag">@dev</span> Hash 2 tree leaves, returns MiMC(_left, _right)<br />    */</span><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">hashLeftRight</span>(<span class="hljs-params"><br />        uint256 _left,<br />        uint256 _right<br />    </span>) public view returns (bytes32) {<br />        <span class="hljs-built_in">require</span>(<br />            _left &lt; <span class="hljs-variable constant_">FIELD_SIZE</span>,<br />            <span class="hljs-string">&quot;_left should be inside the field&quot;</span><br />        );<br />        <span class="hljs-built_in">require</span>(<br />            _right &lt; <span class="hljs-variable constant_">FIELD_SIZE</span>,<br />            <span class="hljs-string">&quot;_right should be inside the field&quot;</span><br />        );<br />        uint256 R = _left;<br />        uint256 C = <span class="hljs-number">0</span>;<br />        (R, C) = hasher.<span class="hljs-title class_">MiMCSponge</span>(R, C, <span class="hljs-number">0</span>);<br />        R = <span class="hljs-title function_">addmod</span>(R, _right, <span class="hljs-variable constant_">FIELD_SIZE</span>);<br />        (R, C) = hasher.<span class="hljs-title class_">MiMCSponge</span>(R, C, <span class="hljs-number">0</span>);<br />        <span class="hljs-keyword">return</span> <span class="hljs-title function_">bytes32</span>(R);<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">_insert</span>(<span class="hljs-params">bytes32 _leaf</span>) internal returns (uint32 index) {<br />        uint32 _nextIndex = nextIndex;<br />        <span class="hljs-built_in">require</span>(<br />            _nextIndex != <span class="hljs-title function_">uint32</span>(<span class="hljs-number">2</span>) ** levels,<br />            <span class="hljs-string">&quot;Merkle tree is full. No more leaves can be added&quot;</span><br />        );<br />        uint32 currentIndex = _nextIndex;<br />        bytes32 currentLevelHash = _leaf;<br />        bytes32 left;<br />        bytes32 right;<br /><br />        <span class="hljs-keyword">for</span> (uint32 i = <span class="hljs-number">0</span>; i &lt; levels; i++) {<br />            <span class="hljs-keyword">if</span> (currentIndex % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {<br />                left = currentLevelHash;<br />                right = <span class="hljs-title function_">zeros</span>(i);<br />                filledSubtrees[i] = currentLevelHash;<br />            } <span class="hljs-keyword">else</span> {<br />                left = filledSubtrees[i];<br />                right = currentLevelHash;<br />            }<br />            currentLevelHash = <span class="hljs-title function_">hashLeftRight</span>(<span class="hljs-title function_">uint256</span>(left), <span class="hljs-title function_">uint256</span>(right));<br />            currentIndex /= <span class="hljs-number">2</span>;<br />        }<br /><br />        uint32 newRootIndex = (currentRootIndex + <span class="hljs-number">1</span>) % <span class="hljs-variable constant_">ROOT_HISTORY_SIZE</span>;<br />        currentRootIndex = newRootIndex;<br />        roots[newRootIndex] = currentLevelHash;<br />        nextIndex = _nextIndex + <span class="hljs-number">1</span>;<br />        <span class="hljs-keyword">return</span> _nextIndex;<br />    }<br /><br />    <span class="hljs-comment">/**<br />    <span class="hljs-doctag">@dev</span> Whether the root is present in the root history<br />    */</span><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">isKnownRoot</span>(<span class="hljs-params">bytes32 _root</span>) public view returns (bool) {<br />        <span class="hljs-keyword">if</span> (_root == <span class="hljs-number">0</span>) {<br />            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br />        }<br />        uint32 _currentRootIndex = currentRootIndex;<br />        uint32 i = _currentRootIndex;<br />        <span class="hljs-keyword">do</span> {<br />            <span class="hljs-keyword">if</span> (_root == roots[i]) {<br />                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br />            }<br />            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {<br />                i = <span class="hljs-variable constant_">ROOT_HISTORY_SIZE</span>;<br />            }<br />            i--;<br />        } <span class="hljs-keyword">while</span> (i != _currentRootIndex);<br />        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br />    }<br /><br />    <span class="hljs-comment">/**<br />    <span class="hljs-doctag">@dev</span> Returns the last root<br />    */</span><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLastRoot</span>(<span class="hljs-params"></span>) public view returns (bytes32) {<br />        <span class="hljs-keyword">return</span> roots[currentRootIndex];<br />    }<br /><br />    <span class="hljs-comment">/// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels</span><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">zeros</span>(<span class="hljs-params">uint256 i</span>) public pure returns (bytes32) {<br />        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x2fe54c60d3acabf3343a35b6eba15db4821b340f76e741e2249685ed4899af6c</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x256a6135777eee2fd26f54b8b7037a25439d5235caee224154186d2b8a52e31d</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x1151949895e82ab19924de92c40a3d6f7bcb60d92b00504b8199613683f0c200</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x20121ee811489ff8d61f09fb89e313f14959a0f28bb428a20dba6b0b068b3bdb</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x0a89ca6ffa14cc462cfedb842c30ed221a50a3d6bf022a6a57dc82ab24c157c9</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x24ca05c2b5cd42e890d6be94c68d0689f4f21c9cec9c0f13fe41d566dfb54959</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">6</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x1ccb97c932565a92c60156bdba2d08f3bf1377464e025cee765679e604a7315c</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">7</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x19156fbd7d1a8bf5cba8909367de1b624534ebab4f0f79e003bccdd1b182bdb4</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">8</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x261af8c1f0912e465744641409f622d466c3920ac6e5ff37e36604cb11dfff80</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">9</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x0058459724ff6ca5a1652fcbc3e82b93895cf08e975b19beab3f54c217d1c007</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">10</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x1f04ef20dee48d39984d8eabe768a70eafa6310ad20849d4573c3c40c2ad1e30</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">11</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x1bea3dec5dab51567ce7e200a30f7ba6d4276aeaa53e2686f962a46c66d511e5</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">12</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x0ee0f941e2da4b9e31c3ca97a40d8fa9ce68d97c084177071b3cb46cd3372f0f</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">13</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x1ca9503e8935884501bbaf20be14eb4c46b89772c97b96e3b2ebf3a36a948bbd</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">14</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x133a80e30697cd55d8f7d4b0965b7be24057ba5dc3da898ee2187232446cb108</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">15</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x13e6d8fc88839ed76e182c2a779af5b2c0da9dd18c90427a644f7e148a6253b6</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">16</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x1eb16b057a477f4bc8f572ea6bee39561098f78f15bfb3699dcbb7bd8db61854</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">17</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x0da2cb16a1ceaabf1c16b838f7a9e3f2a3a3088d9e0a6debaa748114620696ea</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">18</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x24a3b3d822420b14b5d8cb6c28a574f01e98ea9e940551d2ebd75cee12649f9d</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">19</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x198622acbd783d1b0d9064105b1fc8e4d8889de95c4c519b3f635809fe6afc05</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">20</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x29d7ed391256ccc3ea596c86e933b89ff339d25ea8ddced975ae2fe30b5296d4</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">21</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x19be59f2f0413ce78c0c3703a3a5451b1d7f39629fa33abd11548a76065b2967</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">22</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x1ff3f61797e538b70e619310d33f2a063e7eb59104e112e95738da1254dc3453</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">23</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x10c16ae9959cf8358980d9dd9616e48228737310a10e2b6b731c1a548f036c48</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">24</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x0ba433a63174a90ac20992e75e3095496812b652685b5e1a2eae0b1bf4e8fcd1</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">25</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x019ddb9df2bc98d987d0dfeca9d2b643deafab8f7036562e627c3667266a044c</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">26</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x2d3c88b23175c5a5565db928414c66d1912b11acf974b2e644caaac04739ce99</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">27</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x2eab55f6ae4e66e32c5189eed5c470840863445760f5ed7e7b69b2a62600f354</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">28</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x002df37a2642621802383cf952bf4dd1f32e05433beeb1fd41031fb7eace979d</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">29</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x104aeb41435db66c3e62feccc1d6f5d98d0a0ed75d1374db457cf462e3a1f427</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">30</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x1f3c6fd858e9a7d4b0d1f38e256a09d81d5a5e3c963987e2d4b814cfab7c6ebb</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">31</span>)<br />            <span class="hljs-keyword">return</span><br />                <span class="hljs-title function_">bytes32</span>(<br />                    <span class="hljs-number">0x2c7a07d20dff79d01fecedc1134284a8d08436606c93693b67e333f671bf69cc</span><br />                );<br />        <span class="hljs-keyword">else</span> <span class="hljs-title function_">revert</span>(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br />    }<br />}</span></pre><p name="6e0f" id="6e0f" class="graf graf--p graf-after--pre">The contract has 2 initial parameters. The level of the tree, and the address of the MiMC hasher contract.</p><p name="905b" id="905b" class="graf graf--p graf-after--p">The <em class="markup--em markup--p-em">hashLeftRight</em> private method calculates the MiMC hash of the pair of elements.</p><p name="d878" id="d878" class="graf graf--p graf-after--p">The <em class="markup--em markup--p-em">_insert</em> method inserts an element and calculates the new Merkle root. The tree stores the history of the last 30 roots because Ethereum transactions are not real-time. It is possible that you send your Merkle proof to the blockchain, but before your transaction, somebody inserts a new element that changes the Merkle root. Because of the history, your Merkle proof will be still valid, because the root that you used for your proof is in the history. This root checking is done by the <em class="markup--em markup--p-em">isKnownRoot</em> method.</p><p name="7087" id="7087" class="graf graf--p graf-after--p">Now we have a ZK-friendly Merkle tree where we can store the commitments. Let’s see, how we can calculate a Merkle proof for our commitment:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="d54c" id="d54c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// calculates Merkle root from elements and a path to the given element </span><br /><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateMerkleRootAndPath</span>(<span class="hljs-params">mimc: <span class="hljs-built_in">any</span>, levels: <span class="hljs-built_in">number</span>, elements: <span class="hljs-built_in">any</span>[], element?: <span class="hljs-built_in">any</span></span>) {<br />    <span class="hljs-keyword">const</span> capacity = <span class="hljs-number">2</span> ** levels<br />    <span class="hljs-keyword">if</span> (elements.<span class="hljs-property">length</span> &gt; capacity) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Tree is full&#x27;</span>)<br /><br />    <span class="hljs-keyword">const</span> zeros = <span class="hljs-title function_">generateZeros</span>(mimc, levels);<br />    <span class="hljs-keyword">let</span> layers = []<br />    layers[<span class="hljs-number">0</span>] = elements.<span class="hljs-title function_">slice</span>()<br />    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> level = <span class="hljs-number">1</span>; level &lt;= levels; level++) {<br />        layers[level] = []<br />        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(layers[level - <span class="hljs-number">1</span>].<span class="hljs-property">length</span> / <span class="hljs-number">2</span>); i++) {<br />            layers[level][i] = <span class="hljs-title function_">calculateHash</span>(<br />                mimc,<br />                layers[level - <span class="hljs-number">1</span>][i * <span class="hljs-number">2</span>],<br />                i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; layers[level - <span class="hljs-number">1</span>].<span class="hljs-property">length</span> ? layers[level - <span class="hljs-number">1</span>][i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] : zeros[level - <span class="hljs-number">1</span>],<br />            )<br />        }<br />    }<br /><br />    <span class="hljs-keyword">const</span> root = layers[levels].<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? layers[levels][<span class="hljs-number">0</span>] : zeros[levels - <span class="hljs-number">1</span>]<br /><br />    <span class="hljs-keyword">let</span> pathElements = []<br />    <span class="hljs-keyword">let</span> pathIndices = []<br /><br />    <span class="hljs-keyword">if</span> (element) {<br />        <span class="hljs-keyword">const</span> bne = <span class="hljs-title class_">BigNumber</span>.<span class="hljs-title function_">from</span>(element)<br />        <span class="hljs-keyword">let</span> index = layers[<span class="hljs-number">0</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-title class_">BigNumber</span>.<span class="hljs-title function_">from</span>(e).<span class="hljs-title function_">eq</span>(bne))<br />        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> level = <span class="hljs-number">0</span>; level &lt; levels; level++) {<br />            pathIndices[level] = index % <span class="hljs-number">2</span><br />            pathElements[level] = (index ^ <span class="hljs-number">1</span>) &lt; layers[level].<span class="hljs-property">length</span> ? layers[level][index ^ <span class="hljs-number">1</span>] : zeros[level]<br />            index &gt;&gt;= <span class="hljs-number">1</span><br />        }<br />    }<br /><br />    <span class="hljs-keyword">return</span> {<br />        <span class="hljs-attr">root</span>: root.<span class="hljs-title function_">toString</span>(),<br />        <span class="hljs-attr">pathElements</span>: pathElements.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.<span class="hljs-title function_">toString</span>()),<br />        <span class="hljs-attr">pathIndices</span>: pathIndices.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.<span class="hljs-title function_">toString</span>())<br />    }<br />}</span></pre><p name="063f" id="063f" class="graf graf--p graf-after--pre">This method is from <a href="https://github.com/TheBojda/zk-merkle-tree/blob/main/src/zktree.ts" data-href="https://github.com/TheBojda/zk-merkle-tree/blob/main/src/zktree.ts" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zktree.ts</a>, and calculates the Merkle proof for the given element. For the Merkle root calculation, we need the previously added elements and build the Merkle tree. We can read this information from the blockchain because every insert operation emits a Commit event. The code below collects these events and calculates the Merkle proof from them:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="32a6" id="32a6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateMerkleRootAndPathFromEvents</span>(<span class="hljs-params">mimc: <span class="hljs-built_in">any</span>, address: <span class="hljs-built_in">any</span>, provider: <span class="hljs-built_in">any</span>, levels: <span class="hljs-built_in">number</span>, element: <span class="hljs-built_in">any</span></span>) {<br />    <span class="hljs-keyword">const</span> abi = [<br />        <span class="hljs-string">&quot;event Commit(bytes32 indexed commitment,uint32 leafIndex,uint256 timestamp)&quot;</span><br />    ];<br />    <span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contract</span>(address, abi, provider)<br />    <span class="hljs-keyword">const</span> events = <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">queryFilter</span>(contract.<span class="hljs-property">filters</span>.<span class="hljs-title class_">Commit</span>())<br />    <span class="hljs-keyword">let</span> commitments = []<br />    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> event <span class="hljs-keyword">of</span> events) {<br />        commitments.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">BigNumber</span>.<span class="hljs-title function_">from</span>(event.<span class="hljs-property">args</span>.<span class="hljs-property">commitment</span>))<br />    }<br />    <span class="hljs-keyword">return</span> <span class="hljs-title function_">calculateMerkleRootAndPath</span>(mimc, levels, commitments, element)<br />}</span></pre><p name="4379" id="4379" class="graf graf--p graf-after--pre">Now we have a Merkle tree on the blockchain, we can insert elements into it and we can generate Merkle proofs on the client side, so let’s see the ZK part:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="751e" id="751e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// based on https://github.com/tornadocash/tornado-core/blob/master/circuits/merkleTree.circom</span><br />pragma circom <span class="hljs-number">2.0</span><span class="hljs-number">.0</span>;<br /><br />include <span class="hljs-string">&quot;../node_modules/circomlib/circuits/mimcsponge.circom&quot;</span>;<br /><br /><span class="hljs-comment">// Computes MiMC([left, right])</span><br />template <span class="hljs-title class_">HashLeftRight</span>() {<br />    signal input left;<br />    signal input right;<br />    signal output hash;<br /><br />    component hasher = <span class="hljs-title class_">MiMCSponge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">220</span>, <span class="hljs-number">1</span>);<br />    hasher.<span class="hljs-property">ins</span>[<span class="hljs-number">0</span>] &lt;== left;<br />    hasher.<span class="hljs-property">ins</span>[<span class="hljs-number">1</span>] &lt;== right;<br />    hasher.<span class="hljs-property">k</span> &lt;== <span class="hljs-number">0</span>;<br />    hash &lt;== hasher.<span class="hljs-property">outs</span>[<span class="hljs-number">0</span>];<br />}<br /><br /><span class="hljs-comment">// if s == 0 returns [in[0], in[1]]</span><br /><span class="hljs-comment">// if s == 1 returns [in[1], in[0]]</span><br />template <span class="hljs-title class_">DualMux</span>() {<br />    signal input <span class="hljs-keyword">in</span>[<span class="hljs-number">2</span>];<br />    signal input s;<br />    signal output out[<span class="hljs-number">2</span>];<br /><br />    s * (<span class="hljs-number">1</span> - s) === <span class="hljs-number">0</span>;<br />    out[<span class="hljs-number">0</span>] &lt;== (<span class="hljs-keyword">in</span>[<span class="hljs-number">1</span>] - <span class="hljs-keyword">in</span>[<span class="hljs-number">0</span>])*s + <span class="hljs-keyword">in</span>[<span class="hljs-number">0</span>];<br />    out[<span class="hljs-number">1</span>] &lt;== (<span class="hljs-keyword">in</span>[<span class="hljs-number">0</span>] - <span class="hljs-keyword">in</span>[<span class="hljs-number">1</span>])*s + <span class="hljs-keyword">in</span>[<span class="hljs-number">1</span>];<br />}<br /><br /><span class="hljs-comment">// Verifies that merkle proof is correct for given merkle root and a leaf</span><br /><span class="hljs-comment">// pathIndices input is an array of 0/1 selectors telling whether given pathElement is on the left or right side of merkle path</span><br />template <span class="hljs-title class_">MerkleTreeChecker</span>(levels) {<br />    signal input leaf;<br />    signal input pathElements[levels];<br />    signal input pathIndices[levels];<br />    signal output root;<br /><br />    component selectors[levels];<br />    component hashers[levels];<br /><br />    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; levels; i++) {<br />        selectors[i] = <span class="hljs-title class_">DualMux</span>();<br />        selectors[i].<span class="hljs-property">in</span>[<span class="hljs-number">0</span>] &lt;== i == <span class="hljs-number">0</span> ? leaf : hashers[i - <span class="hljs-number">1</span>].<span class="hljs-property">hash</span>;<br />        selectors[i].<span class="hljs-property">in</span>[<span class="hljs-number">1</span>] &lt;== pathElements[i];<br />        selectors[i].<span class="hljs-property">s</span> &lt;== pathIndices[i];<br /><br />        hashers[i] = <span class="hljs-title class_">HashLeftRight</span>();<br />        hashers[i].<span class="hljs-property">left</span> &lt;== selectors[i].<span class="hljs-property">out</span>[<span class="hljs-number">0</span>];<br />        hashers[i].<span class="hljs-property">right</span> &lt;== selectors[i].<span class="hljs-property">out</span>[<span class="hljs-number">1</span>];<br />    }<br /><br />    root &lt;== hashers[levels - <span class="hljs-number">1</span>].<span class="hljs-property">hash</span>;<br />}</span></pre><p name="1b47" id="1b47" class="graf graf--p graf-after--pre">The <a href="https://github.com/TheBojda/zk-merkle-tree/blob/main/circuits/MerkleTreeChecker.circom" data-href="https://github.com/TheBojda/zk-merkle-tree/blob/main/circuits/MerkleTreeChecker.circom" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Merkle proof validator circuit</a> is also copied from the source of Tornado Cash, like the Merkle tree contract itself. The circuit iterates on the path elements and calculates the Merkle root. When the voter votes, she doesn’t have to send the Merkle proof to the smart contract, only the Merkle root, and the ZK proof that she can successfully calculate the root by using this circuit and the Merkle proof that is known only by her (this is the private part of ZKP).</p><p name="4e43" id="4e43" class="graf graf--p graf-after--p">The last step is the commitment/nullifier generation method. To ensure that one voter votes only once, she has to send a nullifier to the blockchain, which is registered by the smart contract, and can be used only once. The nullifier has to be unique and assigned to the commitment. So, one commitment has only one nullifier, but because of ZKP, nobody knows (only the voter) which nullifier is assigned to which commitment. The nullifier is generated by MiMC in zk-merkle-tree:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="a0d5" id="a0d5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateCommitment</span>(<span class="hljs-params"></span>) {<br />    <span class="hljs-keyword">const</span> mimc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">buildMimcSponge</span>();<br />    <span class="hljs-keyword">const</span> nullifier = <span class="hljs-title class_">BigNumber</span>.<span class="hljs-title function_">from</span>(crypto.<span class="hljs-title function_">randomBytes</span>(<span class="hljs-number">31</span>)).<span class="hljs-title function_">toString</span>()<br />    <span class="hljs-keyword">const</span> secret = <span class="hljs-title class_">BigNumber</span>.<span class="hljs-title function_">from</span>(crypto.<span class="hljs-title function_">randomBytes</span>(<span class="hljs-number">31</span>)).<span class="hljs-title function_">toString</span>()<br />    <span class="hljs-keyword">const</span> commitment = mimc.<span class="hljs-property">F</span>.<span class="hljs-title function_">toString</span>(mimc.<span class="hljs-title function_">multiHash</span>([nullifier, secret]))<br />    <span class="hljs-keyword">const</span> nullifierHash = mimc.<span class="hljs-property">F</span>.<span class="hljs-title function_">toString</span>(mimc.<span class="hljs-title function_">multiHash</span>([nullifier]))<br />    <span class="hljs-keyword">return</span> {<br />        <span class="hljs-attr">nullifier</span>: nullifier,<br />        <span class="hljs-attr">secret</span>: secret,<br />        <span class="hljs-attr">commitment</span>: commitment,<br />        <span class="hljs-attr">nullifierHash</span>: nullifierHash<br />    }<br />}</span></pre><p name="3e35" id="3e35" class="graf graf--p graf-after--pre">As you can see, the commitment is a hash of the nullifier and a secret. The public part is the hash of the nullifier and the commitment hash, the secret is private. It’s easy to see, that without the secret, nobody can link the commitment to the nullifier.</p><p name="7df8" id="7df8" class="graf graf--p graf-after--p">Let’s see the whole <a href="https://github.com/TheBojda/zk-merkle-tree/blob/main/circuits/Verifier.circom" data-href="https://github.com/TheBojda/zk-merkle-tree/blob/main/circuits/Verifier.circom" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">validator circuit</a>:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="5ab4" id="5ab4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">pragma circom <span class="hljs-number">2.0</span><span class="hljs-number">.0</span>;<br /><br />include <span class="hljs-string">&quot;CommitmentHasher.circom&quot;</span>;<br />include <span class="hljs-string">&quot;MerkleTreeChecker.circom&quot;</span>;<br /><br />template <span class="hljs-title class_">Verifier</span>(levels) {<br />    signal input nullifier;<br />    signal input secret;<br />    signal input pathElements[levels];<br />    signal input pathIndices[levels];<br />    signal output nullifierHash;<br />    signal output root;<br /><br />    component commitmentHasher = <span class="hljs-title class_">CommitmentHasher</span>();<br />    component merkleTreeChecker = <span class="hljs-title class_">MerkleTreeChecker</span>(levels);<br /><br />    commitmentHasher.<span class="hljs-property">nullifier</span> &lt;== nullifier;<br />    commitmentHasher.<span class="hljs-property">secret</span> &lt;== secret;<br /><br />    merkleTreeChecker.<span class="hljs-property">leaf</span> &lt;== commitmentHasher.<span class="hljs-property">commitment</span>;<br />    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; levels; i++) {<br />        merkleTreeChecker.<span class="hljs-property">pathElements</span>[i] &lt;== pathElements[i];<br />        merkleTreeChecker.<span class="hljs-property">pathIndices</span>[i] &lt;== pathIndices[i];<br />    }<br /><br />    nullifierHash &lt;== commitmentHasher.<span class="hljs-property">nullifierHash</span>;<br />    root &lt;== merkleTreeChecker.<span class="hljs-property">root</span>;<br />}<br /><br />component main = <span class="hljs-title class_">Verifier</span>(<span class="hljs-number">20</span>);</span></pre><p name="c47c" id="c47c" class="graf graf--p graf-after--pre">The circuit is relatively simple. The <a href="https://github.com/TheBojda/zk-merkle-tree/blob/main/circuits/CommitmentHasher.circom" data-href="https://github.com/TheBojda/zk-merkle-tree/blob/main/circuits/CommitmentHasher.circom" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CommitmentHasher</a> validates the commitment and the nullifier hashes by using the nullifier and the secret as private parameters. If the commitment is valid, it validates the given Merkle proof in the next step.</p><p name="fb2e" id="fb2e" class="graf graf--p graf-after--p">Now we have everything that we need, so let’s put things together:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="78a0" id="78a0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateMerkleRootAndZKProof</span>(<span class="hljs-params">address: <span class="hljs-built_in">any</span>, provider: <span class="hljs-built_in">any</span>, levels: <span class="hljs-built_in">number</span>, commitment: <span class="hljs-built_in">any</span>, zkey: <span class="hljs-built_in">any</span></span>) {<br />    <span class="hljs-keyword">const</span> mimc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">buildMimcSponge</span>();<br />    <span class="hljs-keyword">const</span> rootAndPath = <span class="hljs-keyword">await</span> <span class="hljs-title function_">calculateMerkleRootAndPathFromEvents</span>(mimc, address, provider, levels, commitment.<span class="hljs-property">commitment</span>);<br />    <span class="hljs-keyword">const</span> { proof, publicSignals } = <span class="hljs-keyword">await</span> snarkjs.<span class="hljs-property">groth16</span>.<span class="hljs-title function_">fullProve</span>(<br />        {<br />            <span class="hljs-attr">nullifier</span>: commitment.<span class="hljs-property">nullifier</span>, <span class="hljs-attr">secret</span>: commitment.<span class="hljs-property">secret</span>,<br />            <span class="hljs-attr">pathElements</span>: rootAndPath.<span class="hljs-property">pathElements</span>, <span class="hljs-attr">pathIndices</span>: rootAndPath.<span class="hljs-property">pathIndices</span><br />        },<br />        <span class="hljs-title function_">getVerifierWASM</span>(),<br />        zkey);<br />    <span class="hljs-keyword">const</span> cd = <span class="hljs-title function_">convertCallData</span>(<span class="hljs-keyword">await</span> snarkjs.<span class="hljs-property">groth16</span>.<span class="hljs-title function_">exportSolidityCallData</span>(proof, publicSignals));<br />    <span class="hljs-keyword">return</span> {<br />        <span class="hljs-attr">nullifierHash</span>: publicSignals[<span class="hljs-number">0</span>],<br />        <span class="hljs-attr">root</span>: publicSignals[<span class="hljs-number">1</span>],<br />        <span class="hljs-attr">proof_a</span>: cd.<span class="hljs-property">a</span>,<br />        <span class="hljs-attr">proof_b</span>: cd.<span class="hljs-property">b</span>,<br />        <span class="hljs-attr">proof_c</span>: cd.<span class="hljs-property">c</span><br />    }<br />}</span></pre><p name="d778" id="d778" class="graf graf--p graf-after--pre">After the voter generated the commitment, she sends it to the smart contract that stores it in the Merkle tree. In the voting phase, she uses the <em class="markup--em markup--p-em">calculateMerkleRootAndZKProof</em> method that calculates the Merkle proof from the <em class="markup--em markup--p-em">Commit</em> events that are emitted by the smart contract. This method calculates the zero-knowledge proof and converts it into the correct form for the validator smart contract.</p><p name="ffff" id="ffff" class="graf graf--p graf-after--p">The Validator smart contract is generated from the Validator circuit by <a href="https://github.com/iden3/snarkjs" data-href="https://github.com/iden3/snarkjs" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">snarkjs</a>. It can be done by the following command:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="af26" id="af26" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">npx snarkjs zkey <span class="hljs-built_in">export</span> solidityverifier build/Verifier.zkey contracts/Verifier.sol</span></pre><p name="6d06" id="6d06" class="graf graf--p graf-after--pre">For more info, please check the <a href="https://github.com/TheBojda/zk-merkle-tree/blob/main/scripts/prepare.sh" data-href="https://github.com/TheBojda/zk-merkle-tree/blob/main/scripts/prepare.sh" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">prepare.sh</a> script, and my <a href="https://medium.com/better-programming/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" data-href="https://medium.com/better-programming/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" class="markup--anchor markup--p-anchor" target="_blank">previous article</a> about the topic.</p><p name="738b" id="738b" class="graf graf--p graf-after--p">The full <a href="https://github.com/TheBojda/zk-merkle-tree/blob/main/contracts/ZKTree.sol" data-href="https://github.com/TheBojda/zk-merkle-tree/blob/main/contracts/ZKTree.sol" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">ZKTree</em></a> contract looks like this:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="31ff" id="31ff" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// based on https://github.com/tornadocash/tornado-core/blob/master/contracts/Tornado.sol</span><br /><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br />pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.17</span>;<br /><br /><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./MerkleTreeWithHistory.sol&quot;</span>;<br /><br />interface <span class="hljs-title class_">IVerifier</span> {<br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">verifyProof</span>(<span class="hljs-params"><br />        uint[<span class="hljs-number">2</span>] memory a,<br />        uint[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] memory b,<br />        uint[<span class="hljs-number">2</span>] memory c,<br />        uint[<span class="hljs-number">2</span>] memory input<br />    </span>) external pure returns (bool r);<br />}<br /><br />contract <span class="hljs-title class_">ZKTree</span> is <span class="hljs-title class_">MerkleTreeWithHistory</span> {<br />    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">bytes32</span> =&gt;</span> bool) public nullifiers;<br />    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">bytes32</span> =&gt;</span> bool) public commitments;<br /><br />    <span class="hljs-title class_">IVerifier</span> public immutable verifier;<br /><br />    event <span class="hljs-title class_">Commit</span>(<br />        bytes32 indexed commitment,<br />        uint32 leafIndex,<br />        uint256 timestamp<br />    );<br /><br />    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><br />        uint32 _levels,<br />        IHasher _hasher,<br />        IVerifier _verifier<br />    </span>) <span class="hljs-title class_">MerkleTreeWithHistory</span>(_levels, _hasher) {<br />        verifier = _verifier;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">_commit</span>(<span class="hljs-params">bytes32 _commitment</span>) internal {<br />        <span class="hljs-built_in">require</span>(!commitments[_commitment], <span class="hljs-string">&quot;The commitment has been submitted&quot;</span>);<br /><br />        commitments[_commitment] = <span class="hljs-literal">true</span>;<br />        uint32 insertedIndex = <span class="hljs-title function_">_insert</span>(_commitment);<br />        emit <span class="hljs-title class_">Commit</span>(_commitment, insertedIndex, block.<span class="hljs-property">timestamp</span>);<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">_nullify</span>(<span class="hljs-params"><br />        bytes32 _nullifier,<br />        bytes32 _root,<br />        uint[<span class="hljs-number">2</span>] memory _proof_a,<br />        uint[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] memory _proof_b,<br />        uint[<span class="hljs-number">2</span>] memory _proof_c<br />    </span>) internal {<br />        <span class="hljs-built_in">require</span>(!nullifiers[_nullifier], <span class="hljs-string">&quot;The nullifier has been submitted&quot;</span>);<br />        <span class="hljs-built_in">require</span>(<span class="hljs-title function_">isKnownRoot</span>(_root), <span class="hljs-string">&quot;Cannot find your merkle root&quot;</span>);<br />        <span class="hljs-built_in">require</span>(<br />            verifier.<span class="hljs-title function_">verifyProof</span>(<br />                _proof_a,<br />                _proof_b,<br />                _proof_c,<br />                [<span class="hljs-title function_">uint256</span>(_nullifier), <span class="hljs-title function_">uint256</span>(_root)]<br />            ),<br />            <span class="hljs-string">&quot;Invalid proof&quot;</span><br />        );<br /><br />        nullifiers[_nullifier] = <span class="hljs-literal">true</span>;        <br />    }<br />}</span></pre><p name="05f9" id="05f9" class="graf graf--p graf-after--pre">The contract is inherited from the MerkleTree contract, and it has 3 initial parameters. The level and the hasher for the Merkle tree, and the address of the Verifier contract that is generated by snarkjs from the Verifier circuit.</p><p name="1c42" id="1c42" class="graf graf--p graf-after--p">The <em class="markup--em markup--p-em">_commit</em> method inserts the commitment into the Merkle tree and emits the <em class="markup--em markup--p-em">Commit</em> event for the Merkle root calculation.</p><p name="7e38" id="7e38" class="graf graf--p graf-after--p">The <em class="markup--em markup--p-em">_nullify</em> method checks that the nullifier is not used (one voter can vote only once), checks the root by the <em class="markup--em markup--p-em">isKnownRoot</em> method, and verifies the zero-knowledge proof.</p><p name="ecc3" id="ecc3" class="graf graf--p graf-after--p">The <em class="markup--em markup--p-em">_commit</em> and <em class="markup--em markup--p-em">_nullify</em> methods are abstract, so you cannot use the <em class="markup--em markup--p-em">ZKTree</em> contract directly, you have to inherit your own contract from it. This top-level contract will be responsible for the voter validation, and registration of votes.</p><p name="6009" id="6009" class="graf graf--p graf-after--p">You can find a minimal implementation in the <a href="https://github.com/TheBojda/zktree-vote" data-href="https://github.com/TheBojda/zktree-vote" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zktree-vote</a> project (I have a <a href="https://medium.com/@thebojda/how-i-built-an-anonymous-voting-system-on-the-ethereum-blockchain-using-zero-knowledge-proof-d5ab286228fd" data-href="https://medium.com/@thebojda/how-i-built-an-anonymous-voting-system-on-the-ethereum-blockchain-using-zero-knowledge-proof-d5ab286228fd" class="markup--anchor markup--p-anchor" target="_blank">full article</a> about it).</p><p name="d580" id="d580" class="graf graf--p graf-after--p">In summary, the implementation and the voting process are the following:</p><ul class="postList"><li name="ca65" id="ca65" class="graf graf--li graf-after--p">You have to implement the <em class="markup--em markup--li-em">ZKTree</em> contract and deploy it. Your contract will responsible for voter and vote registration.</li><li name="b2c2" id="b2c2" class="graf graf--li graf-after--li">The voter generates a commitment by the <em class="markup--em markup--li-em">generateCommitment</em> method and sends the commitment to the smart contract in the registration phase.</li><li name="0ca9" id="0ca9" class="graf graf--li graf-after--li">In the voting phase, the voter generates the zero-knowledge proof by the <em class="markup--em markup--li-em">calculateMerkleRootAndZKProof</em> method and sends it with the nullifier to the smart contract, which verifies it and registers the vote.</li></ul><p name="554f" id="554f" class="graf graf--p graf-after--li">That’s all. I hope this article will help you to understand how zero-knowledge proofs can be used with JavaScript and Solidity (not only for voting).</p><p name="9cda" id="9cda" class="graf graf--p graf-after--p graf--trailing">For more info, please check the <a href="https://github.com/TheBojda/zk-merkle-tree" data-href="https://github.com/TheBojda/zk-merkle-tree" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zk-merkle-tree</a> repository, and the <a href="https://github.com/TheBojda/zktree-vote" data-href="https://github.com/TheBojda/zktree-vote" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zktree-vote</a> repository which is an example implementation of the library.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/79caa3415d1e"><time class="dt-published" datetime="2023-01-30T21:05:11.941Z">January 30, 2023</time></a>.</p><p><a href="https://medium.com/@thebojda/an-introduction-of-zk-merkle-tree-a-javascript-library-for-anonymous-voting-on-ethereum-using-79caa3415d1e" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on February 1, 2023.</p></footer></article></body></html>