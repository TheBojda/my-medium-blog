<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Docker alapozó</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Docker alapozó</h1>
</header>
<section data-field="subtitle" class="p-summary">
Aki fejlesztett már bármit szerver oldalra, az tudja, hogy a működési logika csak a dolgok egyik oldala, ott van még emellett a szerver…
</section>
<section data-field="body" class="e-content">
<section name="feb4" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b266" id="b266" class="graf graf--h3 graf--leading graf--title">Docker alapozó</h3><figure name="4ff8" id="4ff8" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*RcFbuGJuEPQm6CN2.png" data-width="601" data-height="431" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*RcFbuGJuEPQm6CN2.png"><figcaption class="imageCaption">Forrás: <a href="https://www.docker.com/" data-href="https://www.docker.com/" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://www.docker.com/</a></figcaption></figure><p name="e8dc" id="e8dc" class="graf graf--p graf-after--figure">Aki fejlesztett már bármit szerver oldalra, az tudja, hogy a működési logika csak a dolgok egyik oldala, ott van még emellett a szerver környezet. Az adatbázis, az alkalmazásszerver és minden egyéb. Milyen jó lenne, ha a kód mellett ezt is le tudnánk írni valamilyen formában, amit lefordítva bármilyen szerverkörnyezetbe kirakhatnánk a kis csomagunkat vagy éppen fejlesztés közben egy a véglegeshez hasonló környezetben tesztelhetnénk a kódunkat anélkül hogy bármit kézzel kellene telepítgetni vagy beállítani. A Docker kb. erre a problémára ad megoldást és még talán ennél is többet…</p><p name="27c5" id="27c5" class="graf graf--p graf-after--p">A szerver környezet (izolált módon történő) helyben futtatására az egyik lehetőség, hogy felhúzunk egy virtuális gépet. Ennek nagy hátránya, hogy egy virtuális szerver futtatása erőforrás igényes. Kell a rendszerünk alá egy komplett operációs rendszer, emulált hardverek (pl. virtuális lemezek), dedikált memória, stb. Szerencsére Linuxon létezik egy kevésbé erőforrás igényes megoldás a processek izolálására, de mielőtt erre rátérnék, had tegyek egy rövid kitérőt…</p><p name="7075" id="7075" class="graf graf--p graf-after--p">Annak idején még fősulin volt egy Linux biztonságtechnika nevű óránk, ahol az egyik feladatunk <a href="https://en.wikipedia.org/wiki/Chroot" data-href="https://en.wikipedia.org/wiki/Chroot" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">chroot</a> jail összeállítása volt. A chroot jail a Linux kernel chroot hívásán alapul, amivel úgy futtathatunk egy porcess-t, hogy számára a root fájlrendszer a valódi fájlrendszer valamelyik könyvtára legyen. Ezzel a technológiával az adott process bezárható a saját kis root fájlrendszerébe, így ha egy támadó betörne a szerverre a processen keresztül, képtelen lesz elérni a teljes fájlrendszert, hiszen csak annyit lát belőle amennyit az adott process. Szokták chroot jailbe zárni a webszervereket, a DNS szervert, és szinte minden FTP szerver támogatja. Ez utóbbi esetben sikeres login után az FTP szerver chroot jailbe zárja a process-t, így az adott felhasználó csak a saját könyvtárát fogja látni és maga a kernel gondoskodik róla, hogy onnan ne tudjon kitörni.</p><p name="1d49" id="1d49" class="graf graf--p graf-after--p">A Docker a Linux-on <a href="https://en.wikipedia.org/wiki/Chroot" data-href="https://en.wikipedia.org/wiki/Chroot" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">névtereket</a> használ, ami hasonló a chroot-hoz, de a névterek segítségével nem csak saját root fájlrendszert kap a process, de külön process táblát, hálózati interfészt és minden egyebet. Tehát mikor Dockerben fut mondjuk egy webszerver, akkor nem indul új virtuális gép, de a webszerver nem fogja látni a hoszt gép fájlrendszerét, nem éri el a többi processt és hálózati szempontból is úgy fogja gondolni, hogy egyedül fut a gépen (pl.: indíthatunk több webszervert is a “saját” 80-as portján). Izoláció szempontjából tehát a Docker konténerek olyanok mint a virtuális gépek, ugyanakkor sokkal kevesebb erőforrást fogyasztanak, hiszen nem kell egy komplett OS-t emulálni.</p><p name="ce6e" id="ce6e" class="graf graf--p graf-after--p">A Docker nagy előnye, hogy nem csak egy toolt kapunk a porcessek izolált futtatásához, hanem egy komplett ökoszisztémát, aminek része egy nagy konténer repository, ahol megtalálható a legtöbb alaprendszer, webszerver, adatbázis szerver, stb. amiket akár egy az egyben használhatunk, vagy kiindulási alapként a saját konténerünkhöz. Ennek szemléltetésére gyorsan mutatok is egy példát:</p><pre name="0f96" id="0f96" class="graf graf--pre graf-after--p">docker run -it busybox sh</pre><p name="f09b" id="f09b" class="graf graf--p graf-after--pre">A fenti parancs lehúzza a Docker repoból a busybox image-t, ami egy alap Linux rendszer, elindítja azt, majd lefuttatja az sh parancsot amivel kapunk egy interaktív shell-t. (A Docker rendszer installálásáról nem akartam külön írni, itt megtalálható minden információ az egyes operációs rendszerekhez: <a href="https://docs.docker.com/get-docker/" data-href="https://docs.docker.com/get-docker/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://docs.docker.com/get-docker/</a>)</p><p name="70aa" id="70aa" class="graf graf--p graf-after--p">A konténerben futó shell-ben bármit csinálhatunk. Listázhatjuk a fájlrendszert, körbejárkálhatjuk a könyvtárakat, stb. De ugyanilyen könnyen, egyetlen sorból fel lehet húzni egy MySQL szervert vagy bármilyen más adatbázis szervert minden projektünkhöz külön sajátot, így nem kell ezekkel “szennyezni” a hoszt rendszert. Egyszerűen elindítjuk az éppen aktuálisan fejlesztett projekthez a megfelelő környezetet, majd ha nincs rá szükség egyszerűen leállítjuk.</p><p name="9b6e" id="9b6e" class="graf graf--p graf-after--p">Amiről még érdemes pár szót ejteni, az a Docker fájlrendszerének felépítése. Adjuk ki a busybox shellben a mount parancsot. A root fájlrendszernél valami ilyesmit fogunk látni:</p><pre name="588d" id="588d" class="graf graf--pre graf-after--p">overlay on / type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/CA5FL4FFRJFLJF36PN4VOQZWNR:/var/lib/docker/overlay2/l/TCJVSWOFYXJ5M3IHQ7GQLRXKIE,upperdir=/var/lib/docker/overlay2/1303a004c26c203f181d96e3179cce1351ee2f14648403dbac315af700352929/diff,workdir=/var/lib/docker/overlay2/1303a004c26c203f181d96e3179cce1351ee2f14648403dbac315af700352929/work,xino=off)</pre><p name="8cad" id="8cad" class="graf graf--p graf-after--pre">Látható, hogy a fájlrendszer típusa <a href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html" data-href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">overlay</a>, ami több könyvtárból áll össze. Amikor olvassuk a fájlrendszert, akkor a rendszer felülről lefelé keresi a fájlokat, ha pedig írás történik, a fájlok a legfelső (workdir) könyvtárban jönnek létre, így az alap busybox fájlrendszert sosem piszkítjuk össze. Ez azért jó, mert ha van mondjuk 10 adatbázis konténerünk, nem kell 10 példányban létrehozni a teljes fájlrendszert, elég azokat a fájlokat eltárolni amik az egyes konténerekben különböznek az alap image-től. Ehhez a működéshez persze elég lenne 2 réteg. Egy alap csak olvasható fájlrendszer és egy második réteg ahol az egyedi változásokat tároljuk. Ezzel szemben sok konténer esetén a listában akár 10–20 réteget is látunk. Ez azért van, mert az egyes docker image-ek egymásra épülhetnek, így minden image saját réteget kap. Mondjuk ha van egy MySQL és egy PostgreSQL szerverünk amik ugyanarra az alap Linux image-re épülnek, akkor az alsó szint mindkét esetben a Linux réteg lesz, amit így elég csak egyszer tárolni a hoszt fájlrendszerben. A fentiekből látható, hogy a Docker a számítási kapacitás mellett a fájlrendszerrel is próbál takarékosan bánni. Ha a fenti példa 10 adatbázis szerverét virtuális szerveren futtatnánk, az 10 komplett virtuális disket jelentene operációs rendszerrel és minden egyébbel.</p><p name="2717" id="2717" class="graf graf--p graf-after--p">Most, hogy nagyjából túl vagyunk az alapokon, hozzunk is létre egy saját Docker konténer image-t. Ehhez huzzuk le a következő repo-t:</p><pre name="a016" id="a016" class="graf graf--pre graf-after--p">git clone <a href="https://github.com/TheBojda/docker-sample.git" data-href="https://github.com/TheBojda/docker-sample.git" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">https://github.com/TheBojda/docker-sample.git</a></pre><p name="8389" id="8389" class="graf graf--p graf-after--pre">Az egész projekt 3 fájlból áll és egy sima statikus index.html fájlt tud kiszolgálni. A docker image leírása a Dockerfile-ban található, ami így néz ki:</p><pre name="d6a8" id="d6a8" class="graf graf--pre graf-after--p">FROM nginx</pre><pre name="7f0d" id="7f0d" class="graf graf--pre graf-after--pre">COPY run.sh /</pre><pre name="1240" id="1240" class="graf graf--pre graf-after--pre">RUN chmod +x /run.sh</pre><pre name="2baa" id="2baa" class="graf graf--pre graf-after--pre">COPY html /usr/share/nginx/html</pre><pre name="3334" id="3334" class="graf graf--pre graf-after--pre">ENTRYPOINT [“/run.sh”]</pre><p name="c44a" id="c44a" class="graf graf--p graf-after--pre">A Dockerfile felépítése igen egyszerű. A fájl elején a FROM részben adjuk meg a kiinduló image-t, ami jelen esetben egy NGINX szerver. Ezt követi a run.sh másolása a root könyvtárba, amire futtatási jogot adunk. A következő sorban bemásoljuk a html könyvtár tartalmát a /usr/share/nginx/html könyvtárba, majd elindítjuk a run.sh-t, ami futtatja a nginx-et.</p><p name="dbdf" id="dbdf" class="graf graf--p graf-after--p">Ahogy láthatjuk, a Dockerfile egy egyszerű script szerű leírás arról, hogy hogyan álljon össze a konténer image. Magát az image-t a következő paranccsal tudjuk létrehozni (a repo legyen az aktuális könyvtár):</p><pre name="df76" id="df76" class="graf graf--pre graf-after--p">docker build . -t docker-sample</pre><p name="c40c" id="c40c" class="graf graf--p graf-after--pre">A fenti parancs lefuttatja a Dockerfile-t, végrehajtja a benne található parancsokat, majd létrehozza az image-t amit a -t kapcsolóval docker-sample-nek fogunk elnevezni. Ha minden jól ment, akkor a</p><pre name="a390" id="a390" class="graf graf--pre graf-after--p">docker images</pre><p name="deb2" id="deb2" class="graf graf--p graf-after--pre">paranccsal láthatjuk a listában a docker-sample image-t. Futtatni a konténerünket a következő paranccsal tudjuk:</p><pre name="405e" id="405e" class="graf graf--pre graf-after--p">docker run -p 80:80 docker-sample</pre><p name="b6ae" id="b6ae" class="graf graf--p graf-after--pre">A -p paraméter a konténer 80-as portját a hoszt 80-as portjára vezeti ki. Erre azért van szükség, mert ahogy korábban említettem a konténerek izoláltan futnak saját fájlrendszerrel, processz listával és hálózattal, így enélkül nem tudnánk elérni a konténer 80-as portját. Ha minden jól sikerült, akkor a <a href="http://localhost" data-href="http://localhost" class="markup--anchor markup--p-anchor" target="_blank">http://localhost</a> címen a “Hello from Docker” feliratot fogjuk látni, ami az index.html fájl tartalma.</p><p name="62a0" id="62a0" class="graf graf--p graf-after--p">A gyorstalpalónk végén szeretnék még pár szót szólni a docker-compose parancsról. Ez egy Pythonban írt tool, amivel több konténerből álló docker környezeteket tudunk felhúzni. A környezet leírására a docker-compose.yaml fájl szolgál. Az alábbi minta azt mutatja, hogyan ránthatunk fel pár sorból egy komplett WordPress oldalt:</p><figure name="6629" id="6629" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/TheBojda/f28e3038288ce94d73945e413a2112b8.js"></script></figure><p name="ba4e" id="ba4e" class="graf graf--p graf-after--figure">A yaml fájlban 2 service-t definiálunk ami 2 docker konténer elindítását jelenti. Az első service a db, ami egy mysql szerver. Az environment részben adjuk meg az adatbázis nevét és az alap felhasználót. A volumes részben a /var/lib/mysql könyvtárba felcsatolunk egy virtuális meghajtót (egy könyvtár a lokális gépen), így ha töröljük a konténert, az adatbázis tartalma akkor is megmarad (egészen addig amíg a virtuális meghajtót nem töröljük). A második service maga a wordpress. Ennek a konténernek a konfigurációja hasonlít a db-hez, az egyetlen különbség a ports és a depends_on rész. Az előbbi azt adja meg, hogy a konténer melyik portja a hoszt melyik portjára legyen leképezve, az utóbbi pedig azt, hogy a wordpress service előtt kell elindítani a db-t. A compose fájlt a</p><pre name="8e0a" id="8e0a" class="graf graf--pre graf-after--p">docker-compose up</pre><p name="b37e" id="b37e" class="graf graf--p graf-after--pre">paranccsal futtathatjuk le. Ha minden jól ment, akkor a <a href="http://localhost:8000/" data-href="http://localhost:8000/" class="markup--anchor markup--p-anchor" target="_blank">http://localhost:8000/</a> címen elérjük az új WordPress site-unkat. Ha egy másik terminálban lefuttatjuk a</p><pre name="2b67" id="2b67" class="graf graf--pre graf-after--p">docker ps</pre><p name="2c29" id="2c29" class="graf graf--p graf-after--pre">parancsot, akkor szépen látszik a két docker konténer. Egy a db-nek és egy a wordpress-nek.</p><p name="9a78" id="9a78" class="graf graf--p graf-after--p">A Docker nagy előnye, hogy egyfajta általános konténer szabvánnyá vált, így minden cloud szolgáltató támogatja ezt a formátumot. Ha tehát a saját gépünkön megvagyunk a fejlesztésekkel, az elkészült konténer image-t egy mozdulattal kirakhatjuk a felhőbe, ahol menedzselt módon futtathatjuk azt. Ez utóbbi azt jelenti, hogy a rendszer automatikusan gondoskodik a működésképtelenné vált konténerek újraindításáról, a rendszer fel illetve leskálázásáról, illetve ha legalább két szerveren fut a konténerünk, akkor felváltva frissíthetjük a konténereinket, így a szolgáltatásunk egy másodpercre sem fog leállni.</p><p name="d558" id="d558" class="graf graf--p graf-after--p graf--trailing">Remélem a fentiekből nagyjából körvonalazódott, hogy mennyire hasznos a Docker és a konténerek használata. Nyilván a témával könyveket lehetne megtölteni, de úgy gondolom, hogy alapozónak ennyi talán elegendő. Ha valakit mélyebben érdekel a téma, az itt talál egy nagyon jó tutorialt angol nyelven: <a href="https://docker-curriculum.com/" data-href="https://docker-curriculum.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://docker-curriculum.com/</a> . Ezen kívül rengeteg írás elérhető a weben, így aki jobban el akar mélyedni a témában, könnyedén talál hozzá anyagot.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/b8efb6aa68e9"><time class="dt-published" datetime="2021-07-15T23:29:47.005Z">July 15, 2021</time></a>.</p><p><a href="https://medium.com/@thebojda/docker-alapoz%C3%B3-b8efb6aa68e9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 9, 2021.</p></footer></article></body></html>