<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Nyomjunk saját pénzt, avagy az ERC20-as tokenek rejtelmei (2. rész) #ethereumtudas</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Nyomjunk saját pénzt, avagy az ERC20-as tokenek rejtelmei (2. rész) #ethereumtudas</h1>
</header>
<section data-field="subtitle" class="p-summary">
Az előző részből megtudtuk, hogy hogyan működik egy token, hogy mi az ERC20-as token standard, és ígéretet tettünk arra, hogy ebben a…
</section>
<section data-field="body" class="e-content">
<section name="f61f" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="679a" id="679a" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">Nyomjunk saját pénzt, avagy az ERC20-as tokenek rejtelmei (2. rész) #ethereumtudas</strong></h3><h4 name="0088" id="0088" class="graf graf--h4 graf-after--h3 graf--subtitle">Az előző részből megtudtuk, hogy hogyan működik egy token, hogy mi az ERC20-as token standard, és ígéretet tettünk arra, hogy ebben a részben saját tokent fogunk nyomni. Most beváltjuk az ígéretünket…</h4><figure name="4233" id="4233" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*zRKOtkFb2Wb4pcZpUEaxyg.jpeg" data-width="1280" data-height="853" src="https://cdn-images-1.medium.com/max/800/1*zRKOtkFb2Wb4pcZpUEaxyg.jpeg"></figure><p name="b351" id="b351" class="graf graf--p graf-after--figure">Mielőtt bárminek is nekikezdenénk, telepítenünk kell egy offline pénztárcát (walletet), ahol majd látni fogjuk a saját pénzünket. Erre legalkalmasabb a hivatalos Ethereum Wallet, amit <a href="https://github.com/ethereum/mist/releases" data-href="https://github.com/ethereum/mist/releases" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">innen</a> tölthetünk le. Érdekességként el kell mondanunk, hogy a hivatalos Ethereum pénztárca valójában egy DApp (kvázi egy weboldal), ami a Mist Ethereum böngészőben fut. Ha letöltöttük a pénztárcát, indítsuk el a testrpc-t, majd a pénztárcát parancssorból a <em class="markup--em markup--p-em">— rpc http://localhost:8545</em> paraméterrel. Ezzel érjük el azt, hogy a pénztárcánk az Ethereum hálózat helyett a testrpc-re csatlakozzon. Indításkor jön majd egy warning, amit simán okézzunk le. A pénztárca próbál még további csomópontokat keresni, ami nyilván nem fog neki sikerülni, így nyomjuk meg a “LUNCH APPLICATION” gombot. Ha a pénztárca elindult és mindent jól csináltunk, látni fogjuk a testrpc által létrehozott 10 accountot.</p><blockquote name="4601" id="4601" class="graf graf--blockquote graf-after--p">Gabriel: Aki számára ez nem világos olvassa vissza az #ethereumtudas előző részeit, ahol a tesztkörnyezet telepítését vettük át (Windows, OSX, Linux).</blockquote><h3 name="bb9a" id="bb9a" class="graf graf--h3 graf-after--blockquote">Új token születik</h3><p name="03ff" id="03ff" class="graf graf--p graf-after--h3">A következő lépés, hogy megalkotunk egy új tokent. Ehhez az embark_demo/app/contracts könyvtárban hozzunk létre egy token.sol fájlt, és másoljuk be az alábbi kódot:</p><figure name="acad" id="acad" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/TheBojda/3769cebbf0268558cfd0ed16e5dc977e.js"></script></figure><h4 name="3ced" id="3ced" class="graf graf--h4 graf-after--figure">Mit is látunk a kódban?</h4><p name="65b9" id="65b9" class="graf graf--p graf-after--h4">Ahogyan arról már az előző cikkben szó volt, publikus változók formájában meg tudjuk adni a token adatait: azaz, hogy mi a token szimbóluma, megnevezése, és a hány tizedes jegyig osztható. Ezek megadására szolgál az első 3 sor:</p><p name="d978" id="d978" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">string public constant symbol = “TST”;<br> string public constant name = “Test token”;<br> uint8 public constant decimals = 18;</em></p><p name="bf47" id="bf47" class="graf graf--p graf-after--p">Ezt követi a két esemény megadása, aminek minden ERC20-as tokenben szerepelnie kell (lásd. előző cikk):</p><p name="230b" id="230b" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">event Transfer(address indexed from, address indexed to, uint value);<br>event Approval( address indexed owner, address indexed spender, uint value);</em></p><p name="d3a3" id="d3a3" class="graf graf--p graf-after--p">A következő két sor a lényeg:</p><p name="d600" id="d600" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">mapping( address =&gt; uint ) _balances;<br>mapping( address =&gt; mapping( address =&gt; uint ) ) _approvals;</em></p><p name="ee13" id="ee13" class="graf graf--p graf-after--p">A mapping egy összerendelést jelöl. Legegyszerűbben úgy képzelhetünk el egy ilyet, mint egy fiókos szekrényt, amely fel van címkézve. A =&gt; előtti rész a címke típusa, az utána lévő pedig a fiókban lévő adat típusa. Ez alapján az első sor egy olyan szekrény (tároló), amiben számokat tárolunk, és Ethereum címmel van felcímkézve. Azért írtam, hogy ez a két sor a lényeg, mert tulajdonképpen itt vannak letárolva a tokenjeink. Az okos szerződés ebben a tárolóban tartja nyilván, hogy kinek hány tokenje van.</p><p name="e726" id="e726" class="graf graf--p graf-after--p">A második sor dupla mapping. Olyan felcímkézett fiókos szekrény, aminek a fiókjaiban fiókos szekrények vannak, ebben a szekrényben pedig számok. Itt tartjuk nyilván azt, hogy ki mennyi tokent vonhat le tőlünk. Ez a rész akkor kap majd szerepet, amikor az előző részben említett csoportos beszedési megbízás szerű token levonást valaki számára engedélyezni szeretnénk. Ilyenkor a rendszer a fiókos szekrényből előszedi a mi címünkhöz tartozó kisebb szekrényt, majd abban megkeresi, hogy a levonni szándékozó személy címéhez be van-e állítva valamilyen érték. Ha igen, akkor az adott cím tulajdonosa ezen értékig vonhat le tőlünk tokent.</p><p name="985c" id="985c" class="graf graf--p graf-after--p">A következő sor ismét nagyon fontos:</p><p name="cb75" id="cb75" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">uint public _supply = 1000000;</em></p><p name="ced8" id="ced8" class="graf graf--p graf-after--p">Ez adja meg ugyanis, hogy hány tokenünk létezik összesen. Azért nagyon fontos ez, mert ahogy azt már említettük korábban, ha valamit a blokkláncba égetünk, az bizony az idők végezetéig ott is marad. Tehát ha egyszer publikáltuk az okos szerződést, akkor akár a fejünk tetejére is állhatunk, akkor sem fog ennél több vagy kevesebb token létezni.</p><blockquote name="43a4" id="43a4" class="graf graf--blockquote graf-after--p">Gabriel: Aki valamennyire belelát az ICO-k világába az látja az összefüggést, hiszen ez az a pont amikor a “maximum market cap” definiálásra kerül. A kibocsátott tokenek száma egy fix szám, ami nem változik.</blockquote><p name="2449" id="2449" class="graf graf--p graf-after--blockquote">A Token konstruktorában (ami egyszer és csakis egyszer fut le a token publikálásakor) beálltjuk, hogy kezdetben az összes token a tulajdonoshoz kerüljön:</p><p name="464a" id="464a" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function Token() {<br> _balances[msg.sender] = _supply;<br>}</em></p><p name="70c4" id="70c4" class="graf graf--p graf-after--p">Ezt úgy érjük el, hogy a tokenek mennyiségét nyilvántartó <em class="markup--em markup--p-em">_balances</em> tároló azon rekeszébe, ami hozzánk tartozik (a <em class="markup--em markup--p-em">msg.sender</em> tartalmazza a tokent létrehozó felhasználó Ethereum címét), beírjuk a teljes mennyiséget (<em class="markup--em markup--p-em">_supply</em>).</p><p name="19a7" id="19a7" class="graf graf--p graf-after--p">A továbbiakban következzenek az ERC20-as szabvány által definiált metódusok:</p><p name="4958" id="4958" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function totalSupply() constant returns (uint supply) {<br> return _supply;<br>}<br></em> <br>A totalSupply a teljes token mennyiséget adja vissza, amit a <em class="markup--em markup--p-em">_supply</em> belső tároló tartalmaz, így simán ezt kell visszaadnunk.</p><p name="0e88" id="0e88" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function balanceOf( address who ) constant returns (uint value) {<br> return _balances[who];<br>}</em></p><p name="7a57" id="7a57" class="graf graf--p graf-after--p">A balanceOf-al a paraméterben megadott felhasználó tokenjeinek mennyiségét kell visszaadnunk. Itt tehát egyszerűen kiolvassuk a <em class="markup--em markup--p-em">_balances</em> tárolóból (címkézett fiókos szekrény), hogy mi a benne lévő szám, és ezt adjuk vissza. Kezdetben ugye csak a token létrehozójának fiókjában lesz 0-tól különböző érték, mert nála van az összes token.</p><p name="de34" id="de34" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function transfer( address to, uint value) {<br> if( _balances[msg.sender] &lt; value ) {<br> throw;<br> }<br> if( !safeToAdd(_balances[to], value) ) {<br> throw;<br> }<br> _balances[msg.sender] -= value;<br> _balances[to] += value;<br> Transfer( msg.sender, to, value );<br>}</em></p><p name="93d6" id="93d6" class="graf graf--p graf-after--p">A Transfer a metódusok közül a legfontosabb, hisz ezzel tudunk tokent küldeni valakinek. Ennek ellenére látszik, hogy nem túl bonyolult. Két paramétere van. Az egyik, hogy kinek akarunk küldeni, a másik, hogy mennyit. Az első sor megvizsgálja, hogy a metódust hívó felhasználó (akinek <em class="markup--em markup--p-em">msg.sender</em>-ben van az Ethereum címe) rendelkezik-e elég pénzzel az utaláshoz. Ha a felhasználó által birtokolt tokenek száma kevesebb mint az utalandó, akkor hibát dob a metódus (<em class="markup--em markup--p-em">throw</em>) és megszakad a végrehajtás.</p><p name="fecb" id="fecb" class="graf graf--p graf-after--p">A <em class="markup--em markup--p-em">safeToAdd</em> metódust majd később kifejtjük. Most annyit elég róla tudni, hogy ez egy védelem a túlcsordulás ellen. Hogy ez mit is jelent, azt később tisztázzuk.</p><p name="0fc9" id="0fc9" class="graf graf--p graf-after--p">A varázslat az utolsó 3 sorban történik! A küldőhöz rendelt értékből az okos szerződés levon a mennyiségnek megfelelőt, míg a fogadó félnél tárolt értékhez hozzáad ugyanennyit. Ezzel megtörtént a tulajdonképpeni utalás. Valójában tehát amikor tokent utalunk valakinek, nem megy semmi sehová. Egyszerűen az okos szerződés a fiókos szekrényben a mi fiókunkban lévő értéket lecsökkenti, míg a fogadó fél fiókjában lévőt megnöveli ugyanennyivel.</p><blockquote name="cd47" id="cd47" class="graf graf--blockquote graf-after--p">Gabriel: Világos! Csak az adatbázis módosul, de ez egy élesben létrehozott tokennél azért komolyabb hiszen X mennyiségű bányásznak kell hitelesíteni a tranzakciót, miután az beleégetődik egy blokkba.</blockquote><p name="4f06" id="4f06" class="graf graf--p graf-after--blockquote">Az utolsó sor pedig a Transfer esemény meghívása, ami értesíti a pénztárcákat a tranzakcióról. Ez történik hát, amikor tokent utalunk valakinek, vagy épp nekünk utalnak.</p><p name="08a9" id="08a9" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function transferFrom( address from, address to, uint value) returns (bool ok) {<br> if( _balances[from] &lt; value ) {<br> throw;<br> }<br> if( _approvals[from][msg.sender] &lt; value ) {<br> throw;<br> }<br> if( !safeToAdd(_balances[to], value) ) {<br> throw;<br> }<br> _approvals[from][msg.sender] -= value;<br> _balances[from] -= value;<br> _balances[to] += value;<br> Transfer( from, to, value );<br> return true;<br>}</em></p><p name="fb6e" id="fb6e" class="graf graf--p graf-after--p">A <em class="markup--em markup--p-em">transferFrom</em> metódussal tud valaki tokent levonni tőlünk az általunk engedélyezett értékig. A kapcsolódó kód nagyon hasonló a <em class="markup--em markup--p-em">transfer</em> kódjához, csak némileg bonyolultabb annál. Az első blokk ugyanúgy ellenőrzi, hogy a forrás cím rendelkezik-e megfelelő fedezettel. A következő blokk ellenőrzi, hogy a levonandó összeg belefér-e a kiadott keretbe (kisebb mint a megadott keret). Ehhez az <em class="markup--em markup--p-em">_approvals</em> tárolóból (ez az a fiókos szekrény, amiben minden fiókban újabb fiókos szekrény van) olvassa ki az engedélyezett értéket. Ezt követi a túlcsordulás védelem, amiről később lesz szó, majd a konkrét utalás. Elsőként az engedélyezett összeget csökkentjük az épp átutalandó összeggel. Majd a forrás címhez tartozó egyenleget is csökkentjük ennyivel (levonjuk a küldőtől a tokeneket), és pontosan ugyanennyivel növeljük a fogadó számláját. Végül meghívjuk a szokásos Transfer eseményt, ami a külvilágot (jellemzően a pénztárcákat) értesíti az utalás megtörténtéről.</p><p name="f166" id="f166" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function approve(address spender, uint value) returns (bool ok) {<br> _approvals[msg.sender][spender] = value;<br> Approval( msg.sender, spender, value );<br> return true;<br> }</em></p><p name="0eae" id="0eae" class="graf graf--p graf-after--p">Az <em class="markup--em markup--p-em">approve</em> metódussal adhatjuk meg, hogy egy adott cím számára mekkora összeg levonását engedélyezzük. Ebben a metódusban simán beírjuk ezt az értéket az <em class="markup--em markup--p-em">_approvals</em> tárolóba (dupla fiókos szekrény), és meghívjuk az <em class="markup--em markup--p-em">Approve</em> eseményt, ami az engedélyezés tényéről értesíti a külvilágot.</p><p name="2feb" id="2feb" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function allowance(address owner, address spender) constant returns (uint _allowance) {<br> return _approvals[owner][spender];<br>}</em></p><p name="984a" id="984a" class="graf graf--p graf-after--p">Az utolsó metódus az <em class="markup--em markup--p-em">allowance</em>, amivel lekérdezhető, hogy adott cím esetén mekkora a levonáshoz engedélyezett keret. Itt egyszerűen csak elő kell szedni az értéket a tárolóból, és visszaadni.</p><p name="2f97" id="2f97" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">function safeToAdd(uint a, uint b) internal returns (bool) {<br> return (a + b &gt;= a);<br>}</em></p><p name="fcb1" id="fcb1" class="graf graf--p graf-after--p">A végére maradt a <em class="markup--em markup--p-em">safeToAdd</em>, ami a sokszor említett, misztikusan hangzó “túlcsordulás védelem” funkciót látja el. A paramétere két pozitív egész szám és egy látszólag értelmetlen dolgot vizsgál: Azt nézi meg, hogy a két szám összege nagyobb-e vagy egyenlő, mint az első szám. Ez elsőre butaságnak tűnik, hisz ha egy pozitív számhoz hozzáadunk egy másik pozitív számot, az mindig nagyobb kell legyen. Egy számítógép esetében viszont ezek a számok véges tárolókban tárolódnak, ha pedig a tárolóban nem fér el a szám, az körbefordul mint a kocsi kilométer számlálója, és valami kis számra áll be. Ez ellen véd ez a <em class="markup--em markup--p-em">safeToAdd</em>.</p><p name="f0c5" id="f0c5" class="graf graf--p graf-after--p">Nem engedi átfordulni az egyenleg tárolására szolgáló tárolót. Hozzá kell tenni, hogy az ilyesmihez azért elég extrém körülmények kellenek, de fő a biztonság. Annál is inkább, hisz ha publikáltunk egy ilyen token contractot, az onnantól kezdve saját életet él. Nem leszünk rá semmilyen hatással. Nem tudunk visszagörgetni tranzakciókat, nem tudjuk megváltoztatni a tokenek számát, még megszüntetni sem tudjuk. Semmit nem tehetünk vele, nincs többé semmi közünk hozzá. Talán kicsit túl szájbarágósan, de nem győzzük hangsúlyozni, hogy ha valamit a blokkláncba égetünk, az megváltoztathatatlanul ott is marad az idők végezetéig.</p><blockquote name="c467" id="c467" class="graf graf--blockquote graf-after--p">Gabriel: Lassan ezzel a felirattal egy pólóáruházat kell nyitnunk. Viccet félretéve érdekes az, hogy az említett kontroll megszűnésével történhet meg az, hogy egy tévesen utalt számlára küldött pénzt nincs módjában senkinek sem visszaszereznie. A centralizált bankoknak épp ezért van egy fajta hatalmuk mondjuk pénzeket visszahúzni, amely biztonságot igyekeznek is kommuikálni felénk ha a crypto világról van szó… A megoldás: oda kell figyelni minden utalásnál és tudatosan mozgatni a pénzeinket és élvezni a decentralizált modell alkotta világot.</blockquote><p name="fc28" id="fc28" class="graf graf--p graf-after--blockquote">Most, hogy kész a saját tokenünk, nincs más hátra, mint publikálnunk azt. A testrpc és az ethereum pénztárca elvileg már fut, jöhet az embark. Ha az emberk run paranccsal elindítjuk a rendszert, az felfedezi a contracts könyvtárban az új sol fájlt, és publikálja a tokenünket. Ha mindent jól csináltunk, akkor az embark konzolon látszik majd, hogy sikeresen publikálásra került (deploy kezdetű sorok) a SimpleStorage és a Token nevű smart contract. Itt le is olvashatjuk, hogy milyen ethereum azonosító tartozik a Token contracthoz, ami fontos lesz ahhoz, hogy azt felvehessük a pénztárcába. Az Ethereum Walletben felül válasszuk ki a “contracts” részt, majd tekerjünk le a “watch token”-ig. Nyomjuk meg a gombot, és illesszük be a token contract ethereum címét, amit ugye az embark console-ról olvashatunk le. Ha mindent jól csináltunk, akkor a cím beírását követően megjelennek a token adatai, miket az Ethereum Wallet a blokkláncból olvas ki. Az OK megnyomását követően váltsunk vissza a “wallets” fülre, és nézzük meg a “main accountot”. És voila, ott vannak a tokenjeink. (Legalábbis remélem, hogy mindenki sikerrel járt.)</p><blockquote name="7dc5" id="7dc5" class="graf graf--blockquote graf-after--p">Gabriel: Ismét egy ICO token vásárlásból jól ismert és rém idegesítő jelenet az, amikor a tokenekből igényt tartunk a vásárlásunknak megfelelő mennyiségre. Az ICO-k sok esetben nem jól végezték a dolgukat és nem látjuk a tokeneink számát. Manuálisan kell a MyEtherWallet, Metamask walleteknél kiolvasnunk az okos szerződésből a token adatait. Erről szól a fent is leírt metódus. Ismerős ugye? Megjegyzem személy szerint idáig azonnal a KICKICO esetében fordult velem először elő, hogy azonnal láttam a tokenjeimet. Laci erre mondta, hogy ez a logikus és nem is érti miért nem így működik mindenhol. Na de vissza a tananyaghoz…</blockquote><p name="f9a8" id="f9a8" class="graf graf--p graf-after--blockquote">Az utalás sajnos nem működik Ethereum Walletből a testrpc miatt, de kis kerülőúton ezt is meg tudjuk ejteni. Válasszuk ki a kedvenc accountunkat (mondjuk a 10-est) és másoljuk ki ez ethereum címét. Ezt követően váltsunk át az embark konzolra, és alulra írjuk be a következő sort:</p><p name="c1a8" id="c1a8" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Token.transfer(“…ide jön a fogadó ethereum címe…”, 10);</em></p><p name="1b7e" id="1b7e" class="graf graf--p graf-after--p">Ezzel a sorral direktbe meghívjuk a token contract trasfer metódusát, ami ugyanazt eredményezi, mint mikor az éles hálózaton (nem testrpc-n) tokent küldünk valakinek. A parancs végrehajtását követően átkerül a 10 token a fogadóhoz, amit az Ethereum Walletben ellenőrizhetünk.</p><p name="bae5" id="bae5" class="graf graf--p graf-after--p graf--trailing">Hát ennyi. Nem is olyan bonyodalmas dolog saját pénzt nyomni. Valójában pár egyszerű kódsor az egész. Érdekes látni, hogy adott esetben sok milliós összegek tologatása mögött milyen egyszerű, primitív kis kódok futnak. Most hogy van saját tokenünk, akár el is kezdhetjük árulni. Erről lesz szó a következő részben. Leprogramozunk egy ICO-t. Mer’ az vagány. Tartsatok velünk…</p></div></div></section><section name="d442" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c5e4" id="c5e4" class="graf graf--h3 graf--leading">Kövess minket!</h3><p name="0e27" id="0e27" class="graf graf--p graf-after--h3">A cikksorozat további részeiben ezekkel az okos szerződésekkel fogunk közelebbről megismerkedni, és megtanuljuk azt is, hogy hogyan készíthetünk ilyeneket mi magunk is.</p><p name="4df4" id="4df4" class="graf graf--p graf-after--p">Hogy mindez tényleg felfogható lehessen a cikksorozatot ketten fogjuk írni. A programozói részekért jómagam <a href="https://medium.com/u/792a8f999852" data-href="https://medium.com/u/792a8f999852" data-anchor-type="2" data-user-id="792a8f999852" data-action-value="792a8f999852" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Laszlo Fazekas</a>(fejlesztő) felelek majd, azért pedig, hogy tényleg minden érthető legyen <a href="https://medium.com/u/f91cbcd0bc44" data-href="https://medium.com/u/f91cbcd0bc44" data-anchor-type="2" data-user-id="f91cbcd0bc44" data-action-value="f91cbcd0bc44" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Gabriel Varaljay</a>(marketing) “játssza majd a naivat” (tesz fel kérdéseket, magyarázza újra a feldolgozott anyagot).</p><p name="3dcb" id="3dcb" class="graf graf--p graf-after--p graf--trailing">Épp ezért érdemes feliratkoznod <a href="https://medium.com/envienta-magyarország" data-href="https://medium.com/envienta-magyarország" class="markup--anchor markup--p-anchor" target="_blank">ERRE a medium csatornára</a>, de követheted az ENVIENTA Magyarországot <a href="https://twitter.com/envientahun" data-href="https://twitter.com/envientahun" class="markup--anchor markup--p-anchor" rel="nofollow noopener nofollow noopener noopener" target="_blank">Twitteren</a>, vagy akár csatlakozhatsz a <a href="https://www.facebook.com/groups/1459500857429638/" data-href="https://www.facebook.com/groups/1459500857429638/" class="markup--anchor markup--p-anchor" rel="nofollow noopener nofollow noopener noopener" target="_blank">tematikus Facebook csoportunkhoz</a> is.</p></div></div></section><section name="3da7" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e524" id="e524" class="graf graf--h3 graf--leading"><strong class="markup--strong markup--h3-strong">Támogasd az ENVIENTA-t!</strong></h3><p name="872d" id="872d" class="graf graf--p graf-after--h3">Ha szereted a cikkeinket és támogatnád az ENVIENTA non-profit szervezet munkáját azt crypto valutában is megteheted:</p><p name="14f0" id="14f0" class="graf graf--p graf-after--p">BTC: 18LzExKVBpoWKvtGgUExUvjfbB7Tv5yqYY</p><p name="b475" id="b475" class="graf graf--p graf-after--p graf--trailing">ETH: 0x197E9bf5924c30Aa0140Cef4082E017A69Ca9d73</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/75852f914cbf"><time class="dt-published" datetime="2017-09-04T23:22:36.385Z">September 4, 2017</time></a>.</p><p><a href="https://medium.com/@thebojda/nyomjunk-saj%C3%A1t-p%C3%A9nzt-avagy-az-erc20-as-tokenek-rejtelmei-2-r%C3%A9sz-ethereumtudas-75852f914cbf" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 9, 2021.</p></footer></article></body></html>