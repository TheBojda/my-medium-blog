<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Solidity és DApp-ok (avagy ugrás a mélyvízbe) #ethereumtudas</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Solidity és DApp-ok (avagy ugrás a mélyvízbe) #ethereumtudas</h1>
</header>
<section data-field="subtitle" class="p-summary">
Az előző cikkünkben bemutattuk, hogy hogyan telepíthetjük az okos szerződések fejlesztéséhez szükséges eszközöket: a testrpc-t és az…
</section>
<section data-field="body" class="e-content">
<section name="7497" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bc72" id="bc72" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">Solidity és DApp-ok (avagy ugrás a mélyvízbe) #ethereumtudas</strong></h3><p name="f57b" id="f57b" class="graf graf--p graf-after--h3">Az előző cikkünkben bemutattuk, hogy hogyan telepíthetjük az okos szerződések fejlesztéséhez szükséges eszközöket: a testrpc-t és az embark-ot. A magyarázattal viszont adósak maradtunk, hogy mégis mik ezek az eszközök. Ebben a fejezetben kicsit megismerkedünk a testrpc-vel és az embark-al, és belenézünk az embark által generált demo projekt forráskódjába (igen, végre lesznek kódok is).</p><figure name="596a" id="596a" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 465px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.4%;"></div><img class="graf-image" data-image-id="1*gppZaKrYawY4Vgf0I_uJVg.jpeg" data-width="1280" data-height="850" src="https://cdn-images-1.medium.com/max/800/1*gppZaKrYawY4Vgf0I_uJVg.jpeg"></div></figure><h4 name="686c" id="686c" class="graf graf--h4 graf-after--figure">TestRPC</h4><p name="c11b" id="c11b" class="graf graf--p graf-after--h4">Ahogyan az alapozó cikkekben már írtunk róla, az Ethereum blokkláncot csomópontok egyenrangú hálózata alkotja. Ahhoz, hogy kapcsolódhassunk ehhez a hálózathoz, telepítenünk kell egy Ethereum klienst. Mivel az Ethereum protokoll teljesen nyílt, ezért többféle kliens létezik. Ezek közül a legelterjedtebb az Ethereum alapítvány által fejlesztett hivatalos kliens, a geth. Ha egy ilyen Ethereum klienst telepítünk a gépünkre és elindítjuk, a kliens más csomópontokhoz csatlakozik, így mi is másokkal egyenrangú pontjává válunk a hálózatnak. Mivel a geth egy parancssoros program, nem rendelkezik felhasználói felülettel, e helyett egy JSON-RPC nevű programozói interfészen (API-n) keresztül lehet vele kommunikálni. A TestRPC egy olyan Ethereum kliens, ami nem kapcsolódik más csomópontokhoz, a hálózatot csak emulálja, de JSON-RPC-n keresztül ugyanúgy lehet vele kommunikálni mint egy valódi Ethereum klienssel. Amikor elindítjuk, láthatjuk, hogy a TestRPC virtuális hálózatán létrejött 10 Ethereum cím a hozzá tartozó privát kulcsokkal együtt (ez az a sok krix-krax amit kiír), valamint hogy a localhost 8545-ös portján figyel a JSON-RPC szerver. A létrehozott virtuális Ethereum címekhez jó adag virtuális Ether-t is létrehoz a rendszer, így ezek használatával kedvünkre tesztelhetjük okos szerződéseinket úgy, hogy az semmibe nem kerül nekünk. (Az előző cikkekben ugye szó volt róla, hogy az okos szerződések létrehozása és futtatása is Ether-be kerül.)</p><blockquote name="d041" id="d041" class="graf graf--blockquote graf-after--p">Gabriel: Összefoglalva a TestRPC azért felel, hogy a fejlesztésünk mindent úgy érzékeljen, hogy minden már egy decentralizált környezetben fut. Ezért kapunk “kátékpénzt” azaz virtuális Ethert, 10 Ethereum címet és privát kulcsokat (private keys). Utóbbiakat fontosságát majd később megértjük. A lényeg, hogy a TestRPC fontos eleme a programozói játszóterünknek.</blockquote><h4 name="91d2" id="91d2" class="graf graf--h4 graf-after--blockquote">Embark és DApp-ok</h4><p name="60a1" id="60a1" class="graf graf--p graf-after--h4">Az embark egy komplexebb eszköz, ami mindent tartalmaz ahhoz, hogy okos szerződéseket és dapp-okat fejlesszünk. Mielőtt azonban rátérnénk, tisztáznunk kell, hogy mik azok a dapp-ok (decentralizált alkalmazások). Az előbbiekben említettük, hogy az Ethereum kliens csupán egy JSON-RPC interfésszel rendelkezik, de nem tartozik hozzá felhasználói felület. Ilyen felhasználói felületet HTML és JavaScript segítségével hozhatunk létre. Ezek tulajdonképpen sima weblapok. Az Ethereum szeret úgy tekinteni magára, mint egyfajta új generációs Internetre, ami messze túlmutat a virtuális valutákon és a blokkláncon. Erre az új Internetre web3-ként úgy hivatkoznak, mint a ma létező (web 2.0) rendszer következő generációjára. Ezen új rendszerben az Ethereum hálózaton futó okos szerződések töltik be a backend (kb. szerver oldali logika) szerepét, míg a frontend-et (kliens oldali logika) a dapp-ok jelentik. A dapp-ok tehát pontosan olyan weblapok, mint az összes többi, csak ezek egy központi szerver helyett az Ethereum hálózathoz kapcsolódnak. Mivel a jelenlegi böngészők nem támogatják az Ethereumot (a web3-at, ha az ő terminológiájukat használjuk), ezért ezeknek a dapp-oknak a használatához vagy különleges böngészőre (pl. Mist) vagy valamilyen böngésző kiegészítőre (pl. MetaMask) van szükség. Szerencsére az embark áthidalja nekünk a problémát egy lokális szerver futtatásával, így nekünk a fejlesztéshez nem kell telepítenünk majd sem új böngészőt, sem kiegészítőt.</p><blockquote name="53a0" id="53a0" class="graf graf--blockquote graf-after--p">Gabriel: Az embark tehát egy olyan ügyes kis eszköz, amely segít nekünk abban, hogy a klasszikus centralizált internetből megszokott böngésző felületet tudjuk használni. Azt kell megértünk, hogy mi egy számunkra ismert internetet ismerünk és használunk, miközben már születik a következő. Olyan mintha mi csak 2 dimenzióban látnánk, de már fejleszteni szeretnénk egy 3 dimenziós környezetben. Kell valami ami a mi 2 dimenziós agyunk számára szimulálja és felfoghatóvá teszi a 3D-s képet. Így van ez a decentralizált alkalmazásokkal is amelyeket még el kell fogadtatni a mostani böngészőinkkel (miközben azok még nem készek rá, mert centralizált működésre vannak kialakítva). Nos, ezt a feladatot oldja meg az embark.</blockquote><h4 name="2fa2" id="2fa2" class="graf graf--h4 graf-after--blockquote">Fejlesztés Embark-al</h4><p name="6983" id="6983" class="graf graf--p graf-after--h4">Az előző cikkünkben az <strong class="markup--strong markup--p-strong">embark demo</strong> paranccsal létrehoztunk egy demo projektet, ami az embark_demo könyvtárban található. Nézzünk kicsit itt körbe! Ami innen most nekünk érdekes, az az app könyvtár. Itt található a dapp és az okos szerződés. Ránézésre olyan az egész mint egy sima weblap. Van itt egy index.html, képek, css, némi javascript, és egy contracts könyvtár. Ez utóbbi a kakukktojás, ő tartalmazza az okos szerződést. Nézzünk is bele gyorsan: találunk itt egy simple_storage.sol fájlt. A .sol kiterjesztés a Solidity-re utal, ami az Ethereum okos szerződésekhez ajánlott hivatalos programozási nyelve. Azért írtam így, mert az előző cikkekben már volt szó róla, hogy az Ethereum blokklánc bájtkód formában tárolja az okos szerződéseket és létezik több fordító is ami ilyen bájtkódot képes előállítani. Ezek közül messze legelterjedtebb a JavaScript szerű Solidity, így a továbbiakban mi is erre koncentrálunk.</p><blockquote name="c64a" id="c64a" class="graf graf--blockquote graf-after--p">Gabriel: Nyugalom itt már én is kezdem elveszíteni a fonalat, de senki sem sürget, ha nem érted olvasd el újra a mondatokat. Segítek. A telepítéssel létrehoztunk egy embark_demo könyvtárat, melyet érdemes most az elején tüzetesebben megvizsgálni. Csak egy megjegyzés még: OSX-en nálam az említett könyvtár és fájlok az app alkönyvtárban vannak.</blockquote><blockquote name="c80a" id="c80a" class="graf graf--blockquote graf-after--blockquote">index.html, képek, css — ezeket a fájlokat ismerjük a “mi világunkból”</blockquote><blockquote name="540e" id="540e" class="graf graf--blockquote graf-after--blockquote">contracts könyvtár — itt vannak vagy lesznek az okosszerződések</blockquote><blockquote name="0ef8" id="0ef8" class="graf graf--blockquote graf-after--blockquote">simple_storage.sol — a .sol a Solidity tehát az Ethereum programozási nyelve</blockquote><p name="37c1" id="37c1" class="graf graf--p graf-after--blockquote">Nézzük hát a kódot:</p><figure name="af61" id="af61" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="88a3" id="88a3" class="graf graf--p graf-after--figure">Az első sor (<strong class="markup--strong markup--p-strong">pragma …</strong>) a fordítóak szól. Jelzi, hogy a kód 0.4.7-es Solidity verzióra készült.</p><p name="c0af" id="c0af" class="graf graf--p graf-after--p">A következő sortól (<strong class="markup--strong markup--p-strong">contract …</strong>) jön maga az okos szerződés. Aki kicsit járatosabb a programozásban, annak feltűnhet a hasonlóság az objektum osztályok definíciójával. Nos, egy smart contract végül is felfogható egy objektum példánynak, ami az Ethereum hálózatban létezik és vannak mezői meg metódusai. Aki nem annyira járatos az objektum orientált programozásban, az tekintse úgy, hogy egy okos szerződésben vannak kis rekeszek vagy tárolók (őket hívják amúgy mezőknek) és nyújt bizonyos szolgáltatásokat (ők a metódusok).</p><blockquote name="078d" id="078d" class="graf graf--blockquote graf-after--p">Gabriel: A legtöbb objektum orientált programozásban a kód nagy része ilyen rekeszeket tartalmaz, amelyek különböző dolgokra használhatók. Némely rekesz csak szöveget tud tárolni, míg mások csak számokat, stb. A lényeg, hogy ezektől most ne ijedjünk meg, mert amikor már egy konkrét programot fogunk írni és azon megyünk át, minden világossá fog válni. Tehát csak semmi pánik!</blockquote><p name="a03b" id="a03b" class="graf graf--p graf-after--blockquote">A következő (<strong class="markup--strong markup--p-strong">uint public storedData</strong>) sor pont egy ilyen tárolót definiál. A tároló neve storedData és egy pozitív egész számot (<strong class="markup--strong markup--p-strong">uint típus</strong>) lehet bele rakni. Ennek a smart contraktnak más tárolója (mezője) nincs.</p><p name="78c4" id="78c4" class="graf graf--p graf-after--p">Eztán jönnek a szolgáltatások (metódusok) amik a function kezdetű részekben vannak leírva. Az első metódus (a továbbiakban inkább így hívnám) neve megegyezik a smart contract nevével. Ez egy speciális metódus, ami a smart contract létrehozásakor (és csak akkor) fut le (objektum orientált programozásban konstruktornak hívják az ilyet). Van neki egy pozitív egész szám típusú (uint), initialValue nevű paramétere, és ennek az értékét írja be a storedData mezőbe. Ez arra jó, hogy mikor a smart contractot létrehozzuk, megadhassunk valami kezdeti értéket a storedData tárolónak (mezőnek).</p><blockquote name="f48a" id="f48a" class="graf graf--blockquote graf-after--p">Gabriel: A rekeszeken túl most a metódusokra kell figyelnünk, ezek különböző funkciókért felelnek. A fenti program esetében megmondják, hogy melyik rekeszbe mi kerülhet. Az uint-t azt jelenti, hogy oda abban a rekeszben csak egész szám mehet.</blockquote><p name="58ec" id="58ec" class="graf graf--p graf-after--blockquote">Amikor egy ilyen tárolóba értéket írunk be, az érték beíródik a blokkláncba. Mivel ugye a blokkláncban nem értékek, hanem tranzakciók vannak, épp ezért ha pontosak akarunk lenni, ilyenkor valójában nem egy szám íródik be a blokkláncba, hanem az, hogy a storedData változó értéke mire változott. Ha később megváltoztatjuk a storedData értékét, akkor egy új tranzakció íródik be a blokkláncba. Ez az egész a smart contract szempontjából teljesen transzparens, tehát nekünk csak azzal kell foglalkoznunk, hogy vannak tárolóink, amibe értékeket írunk.</p><p name="2bae" id="2bae" class="graf graf--p graf-after--p">Amiért mégis fontosnak tartottam kiemelni a fentieket, az az, hogy lássuk a dolog belső működését. Lássuk azt, amit már a a bevezetőben is írtunk, hogy a blokklánc nem felejt. Ha bármilyen értéket írunk a belső változóba, az a blokkláncban ottmarad, hiába változtatjuk meg később, mindig vissza fog lehet keresni, hogy mi volt az eredeti érték.</p><blockquote name="28a6" id="28a6" class="graf graf--blockquote graf-after--p">Gabriel: Ismét egy újabb részlet abból a világból, amely számunkra még nem annyira ismerős: nem lehet csalni, átírni számokat, meghamisítani számlákat, eltüntetni pénzeket… A blokklánc minden változásról bejegyzést készít és letárolja azt akár több millió számítógépen. Hogy mi a biztonság? Az, hogy lehetetlen több millió embert bevonni egy bűncselekménybe és eltüntetni ezeket a nyomokat. Ilyen szempontból épp a centralizált bankredszer az, ami sérülékenyebb. Érdekes az emberi agy, a megszokás, hogy mégis nem tudjuk elengedni a régit (ami félelmetesebb) és befogadni az újat (amely biztonságosabb).</blockquote><p name="aba3" id="aba3" class="graf graf--p graf-after--blockquote">A következő metódus a <strong class="markup--strong markup--p-strong">set</strong>, ami a paramétereként kapott pozitív egész számot (uint) beírja a tárolóba. Ezt a metódust már bármelyik Ethereum felhasználó meghívhatja, így bárki megváltoztathatja a smart contractban tárolt értéket. Van ennek egy párja is, a <strong class="markup--strong markup--p-strong">get</strong> metódus, ami pedig a tárolt értéket olvassa ki. Ezzel a metódussal tehát bármelyik Ethereum felhasználó elérheti a blokkláncban tárolt legutoljára beírt számot. Ez a smart contract ennyit tud. Van egy belső változója, amit bárki beállíthat illetve kiolvashat.</p><blockquote name="f909" id="f909" class="graf graf--blockquote graf-after--p">Gabriel: A set angol jelentése “beállít”, a get pedig a “megkap” vagy “kinyer”. Egyszerű, hiszen könnyen megjegyezhető, hogy a set-et értéket írunk be egy “rekeszbe”, míg a get-el ki tudjuk olvasni azt belőle. Képzeljük ezt el a gyakorlatban: a Coinbase alkalmazással ETH-t veszünk. A Coinbase jóváírja nekünk ezt a tranzakciót és átírja a set paramétert az adott ETH értékre (ez átíródik a blokkláncban és letárolódik sok ezer gépen). Ezután ha elindítjuk az alkalmazást a mobilunkon, hiszen látni szeretnénk mennyi ETH-nk van, az alkalmazás kiolvassa egy get metódussal az értéket és megmutatja az összeget.</blockquote><p name="d64a" id="d64a" class="graf graf--p graf-after--blockquote">Ha elindítjuk egy terminálban a testrpc-t, és egy másik terminálban az embark_demo könyvtárban kiadjuk az <strong class="markup--strong markup--p-strong">embark build</strong> parancsot, a rendszer le is fordítja a sol fájlokat és fel is tölti azokat a blokkláncba. Ez most ugyebár a testrpc-nek köszönhetően a virtuális teszt hálózat, de ugyanígy tudunk majd szerződést publikálni az igazi Ethereum hálózatra is. A különbség, csak annyi, hogy akkor Ethereum kliensként a testrpc helyett a geth-et (vagy más alternatív klienst) kellene futtatnunk. Ennyi az egész, és pont ezért szeretjük az Embark-ot. Ugye nem bonyolult?</p><blockquote name="157b" id="157b" class="graf graf--blockquote graf-after--p">Gabriel: Annyira nem, de azért kell egy kis idő mire megemészti az ember ezt az egészet. Szerintem van akinek a két Terminal ablak és a plusz böngésző is elég sokkolólag hat, de idővel engem is beleértve megszokjuk majd.</blockquote><p name="7f11" id="7f11" class="graf graf--p graf-after--blockquote">A következő részben ránézünk kicsit a dapp-ra, hogy lássuk hogyan is készíthetünk (vizuálisan is jobban feldolgozható) felhasználói felületet az okos szerződésünkhöz.</p><h3 name="aaba" id="aaba" class="graf graf--h3 graf-after--p">Kövess minket!</h3><p name="0e27" id="0e27" class="graf graf--p graf-after--h3">A cikksorozat további részeiben ezekkel az okos szerződésekkel fogunk közelebbről megismerkedni, és megtanuljuk azt is, hogy hogyan készíthetünk ilyeneket mi magunk is.</p><p name="4df4" id="4df4" class="graf graf--p graf-after--p">Hogy mindez tényleg felfogható lehessen a cikksorozatot ketten fogjuk írni. A programozói részekért jómagam <a href="https://medium.com/u/792a8f999852" data-href="https://medium.com/u/792a8f999852" data-anchor-type="2" data-user-id="792a8f999852" data-action-value="792a8f999852" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Laszlo Fazekas</a>(fejlesztő) felelek majd, azért pedig, hogy tényleg minden érthető legyen <a href="https://medium.com/u/f91cbcd0bc44" data-href="https://medium.com/u/f91cbcd0bc44" data-anchor-type="2" data-user-id="f91cbcd0bc44" data-action-value="f91cbcd0bc44" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Gabriel Varaljay</a>(marketing) “játssza majd a naivat” (tesz fel kérdéseket, magyarázza újra a feldolgozott anyagot).</p><p name="3dcb" id="3dcb" class="graf graf--p graf-after--p graf--trailing">Épp ezért érdemes feliratkoznod <a href="https://medium.com/envienta-magyarország" data-href="https://medium.com/envienta-magyarország" class="markup--anchor markup--p-anchor" target="_blank">ERRE a medium csatornára</a>, de követheted az ENVIENTA Magyarországot <a href="https://twitter.com/envientahun" data-href="https://twitter.com/envientahun" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">Twitteren</a>, vagy akár csatlakozhatsz a <a href="https://www.facebook.com/groups/1459500857429638/" data-href="https://www.facebook.com/groups/1459500857429638/" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">tematikus Facebook csoportunkhoz</a> is.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/c6bd4ac2f740"><time class="dt-published" datetime="2017-08-14T08:43:27.942Z">August 14, 2017</time></a>.</p><p><a href="https://medium.com/@thebojda/solidity-%C3%A9s-dapp-ok-avagy-ugr%C3%A1s-a-m%C3%A9lyv%C3%ADzbe-c6bd4ac2f740" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 31, 2020.</p></footer></article></body></html>