<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Zero-Knowledge Group Membership Management With the Semaphore Protocol</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Zero-Knowledge Group Membership Management With the Semaphore Protocol</h1>
</header>
<section data-field="subtitle" class="p-summary">
Semaphore is a zero-knowledge protocol enabling anonymous group membership proof and signaling that we can use for many things. Anonymous‚Ä¶
</section>
<section data-field="body" class="e-content">
<section name="5131" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e60c" id="e60c" class="graf graf--h3 graf--leading graf--title">Zero-Knowledge Group Membership Management With the Semaphore Protocol</h3><figure name="cb43" id="cb43" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*tZ-zM31BwSfU7KxypncQfg.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*tZ-zM31BwSfU7KxypncQfg.png"></figure><p name="b7b1" id="b7b1" class="graf graf--p graf-after--figure"><a href="https://semaphore.pse.dev/" data-href="https://semaphore.pse.dev/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Semaphore</a> is a zero-knowledge protocol enabling anonymous group membership proof and signaling that we can use for many things. Anonymous voting, anonymizing financial transactions, and OpenAI CEO Sam Altman‚Äôs WorldCoin project uses Semaphore to ensure the anonymity of its users.</p><p name="188d" id="188d" class="graf graf--p graf-after--p">The basic logic of Semaphore is very similar to the <a href="https://github.com/tornadocash/tornado-core" data-href="https://github.com/tornadocash/tornado-core" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">basic logic of Tornado Cash</a>, but it is much more general and complex. Therefore, before we delve into how Semaphore works, it is worth familiarizing ourselves with Tornado Cash. I have written a <a href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" data-href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">full article on the topic</a>, so in this article, I will only briefly discuss the system. For those interested in the details, please read my previous article.</p><p name="1bcc" id="1bcc" class="graf graf--p graf-after--p">Tornado Cash is a coin mixer designed to make tracking money transfers impossible. To use the system, the user generates a key pair. Using one of the keys, they can deposit a certain amount into the Tornado Cash smart contract, which can then be withdrawn using the other key. The connection between the two keys is proven using a zero-knowledge proof, so no one besides the user can determine which deposit key corresponds to which withdrawal key, making the money transfers untraceable.</p><p name="f712" id="f712" class="graf graf--p graf-after--p">The following figure illustrates how the keys are generated:</p><figure name="add2" id="add2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*_wYaDdfe3KiPunJy.png" data-width="219" data-height="121" src="https://cdn-images-1.medium.com/max/800/0*_wYaDdfe3KiPunJy.png"></figure><p name="ec3e" id="ec3e" class="graf graf--p graf-after--figure">The user generates a nullifier and a secret. These will be used to generate the two keys. To make a deposit, the user uses the commitment hash, created by hashing the secret and the nullifier. The key used for withdrawal is the nullifier hash. When the user places the amount into a deposit, the smart contract stores the commitment hash in a Merkle tree (I wrote about Merkle trees in more detail in my previous article).</p><p name="7e0d" id="7e0d" class="graf graf--p graf-after--p">When withdrawing the amount, the user provides the nullifier hash and a zero-knowledge proof, which proves that the commitment hash can be derived from the nullifier using the secret, as well as a Merkle proof that the commitment hash is included in the Merkle tree. The smart contract stores the nullifier hash, ensuring that it can only be used once and, therefore, an amount placed in a deposit cannot be withdrawn multiple times. This is a brief summary of how the system works. For a more detailed description, please read my previous article.</p><p name="32cb" id="32cb" class="graf graf--p graf-after--p">The logic of Semaphore is very similar but much more general and complex, as can be seen from the following diagram. This is the schematic diagram of the circuit associated with the system:</p><figure name="23dd" id="23dd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*tIDreckiJxWcbXIp.png" data-width="999" data-height="579" src="https://cdn-images-1.medium.com/max/800/0*tIDreckiJxWcbXIp.png"><figcaption class="imageCaption">source: <a href="https://semaphore.pse.dev/docs/technical-reference/circuits" data-href="https://semaphore.pse.dev/docs/technical-reference/circuits" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://semaphore.pse.dev/docs/technical-reference/circuits</a></figcaption></figure><p name="5f79" id="5f79" class="graf graf--p graf-after--figure">Here, the user generates two private variables: the <strong class="markup--strong markup--p-strong">Identity Trapdoor</strong> and the <strong class="markup--strong markup--p-strong">Identity Nullifier</strong>. These two private variables can be seen as a private key. By hashing these two private variables, the Identity Commitment is created, which can also be seen as a form of a public key. This public key can be used for registration, for example, in the case of anonymous voting.</p><p name="e178" id="e178" class="graf graf--p graf-after--p">Registration follows the same process as in Tornado Cash, by adding the <strong class="markup--strong markup--p-strong">Identity Commitment</strong> to a Merkle tree, so when we want to prove membership in the group, we can do so with a Merkle proof. In the circuit, the Merkle proof is defined by the <strong class="markup--strong markup--p-strong">Sibiligs</strong> and <strong class="markup--strong markup--p-strong">Path Indices</strong> parameters.</p><p name="c526" id="c526" class="graf graf--p graf-after--p">The figure shows that the nullifier hash is not simply generated by hashing the nullifier as in the case of Tornado Cash, but rather as a combination of an <strong class="markup--strong markup--p-strong">Identity Nullifier</strong> and an <strong class="markup--strong markup--p-strong">External Nullifier</strong> hash. This is beneficial because, unlike Tornado Cash, the nullifier can be reused multiple times. For example, in the case of an anonymous voting system, a user only needs to register once and can participate in multiple votes. For each vote, a unique external nullifier is generated. This allows for generating unique public nullifiers for each vote, which are specific to the particular vote but cannot be linked to each other.</p><p name="dba7" id="dba7" class="graf graf--p graf-after--p">The last parameter is the <strong class="markup--strong markup--p-strong">Signal Hash</strong>. The signal is freely chosen data that can be linked to the zero-knowledge proof. In the case of a vote, for example, it could be the vote itself. If we consider the Identity Tapdoor and Identity Nullifier as private keys, and the Identity Commitment as a public key, then the zero-knowledge proof can be seen as a form of digital signature, as it can only be generated with knowledge of the private data. In this case, the signal is the digitally signed content.</p><p name="cda4" id="cda4" class="graf graf--p graf-after--p">After the theory, let‚Äôs take a look at what this looks like in practice (the full code is available in this <a href="https://github.com/TheBojda/semaphore-example" data-href="https://github.com/TheBojda/semaphore-example" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub repository</a>).</p><p name="9401" id="9401" class="graf graf--p graf-after--p">The following code snippet showcases the use of the semaphore library in off-chain:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="4224" id="4224" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> groupId = <span class="hljs-number">1</span><br /><span class="hljs-keyword">const</span> externalNullifier = <span class="hljs-number">1212</span><br /><span class="hljs-keyword">const</span> signal = <span class="hljs-number">1</span><br /><br /><span class="hljs-keyword">let</span> identity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Identity</span>()<br /><br /><span class="hljs-keyword">const</span> group = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Group</span>(groupId, merkleTreeDepth)<br /><br />group.<span class="hljs-title function_">addMember</span>(identity.<span class="hljs-property">commitment</span>)<br /><br /><span class="hljs-keyword">const</span> fullProof = <span class="hljs-keyword">await</span> <span class="hljs-title function_">generateProof</span>(<br />  identity, <br />  group, <br />  externalNullifier, <br />  signal, {<br />    <span class="hljs-attr">zkeyFilePath</span>: zkeyFilePath,<br />    <span class="hljs-attr">wasmFilePath</span>: wasmFilePath<br />  }<br />)<br /><br /><span class="hljs-title function_">assert</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">verifyProof</span>(fullProof, merkleTreeDepth))</span></pre><p name="d0b0" id="d0b0" class="graf graf--p graf-after--pre">First, we create an <code class="markup--code markup--p-code">Identity</code>object to generate the random identity nullifier and trapdoor. As mentioned before, these variables are similar to a private key, so we must securely store them, which is not a trivial task. That is why there is the option to initialize the <code class="markup--code markup--p-code">Identity</code>with a fixed value instead of random variables. A typical solution is to sign a constant string with a private key (for example, using MetaMask) and use this as the source for the Identity, while the nullifier and trapdoor are not stored, but generated in real-time. By doing this, our Semaphore identity provides the same level of security as a private key, as the trapdoor and nullifier can only be derived with knowledge of the private key. For example, if our private key is stored on a hardware wallet, then the nullifier and trapdoor can only be generated with the help of the hardware wallet.</p><p name="9b97" id="9b97" class="graf graf--p graf-after--p">After creating the <code class="markup--code markup--p-code">Identity</code>, we create the <code class="markup--code markup--p-code">Group</code>. The <code class="markup--code markup--p-code">Group</code>class manages the Merkle tree. The constructor has two parameters: a unique groupId and the depth of the Merkle tree. The depth of the Merkle tree determines the number of possible elements in the group. In the example, we have given 20, which means that the group will be able to store 2¬≤‚Å∞ elements. We can add the identity commitments to the group using the <code class="markup--code markup--p-code">addMember</code>method.</p><p name="7ec5" id="7ec5" class="graf graf--p graf-after--p">The zero-knowledge proof is generated with the <code class="markup--code markup--p-code">generateProof</code>function. The first four parameters of the function are identity, which contains the private variables; group, which is necessary for generating Merkle proof; externalNullifier; and signal. The 5th parameter passes the proving key and a wasm file containing the validator code. These can be downloaded from <a href="https://www.trusted-setup-pse.org/" data-href="https://www.trusted-setup-pse.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>. Separate files are assigned for each Merkle tree depth, from 16 to 32. The proving key and wasm file can also be generated from the Semaphore circuit. For more information on this topic, please read <a href="https://betterprogramming.pub/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" data-href="https://betterprogramming.pub/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">my article</a>.</p><p name="5909" id="5909" class="graf graf--p graf-after--p">The zero-knowledge proof can be easily validated with the <code class="markup--code markup--p-code">verifyProof</code>function, which has two parameters: the proof and the depth of the Merkle tree. The return value is a boolean variable that indicates whether the validation of the proof was successful or not.</p><p name="490f" id="490f" class="graf graf--p graf-after--p">Things may be a little more complicated if the management of the Merkle tree and the validation of the proof are done on the blockchain (on-chain). This is demonstrated by the following code snippet:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="fa52" id="fa52" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> { semaphore }: { <span class="hljs-attr">semaphore</span>: <span class="hljs-title class_">Semaphore</span> } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">run</span>(<br />  <span class="hljs-string">&quot;deploy:semaphore&quot;</span>, { <span class="hljs-attr">logs</span>: <span class="hljs-literal">false</span> }<br />)<br /><br /><span class="hljs-keyword">const</span> groupId = <span class="hljs-number">1</span><br /><span class="hljs-keyword">const</span> merkleTreeDepth = <span class="hljs-number">20</span><br /><span class="hljs-keyword">const</span> externalNullifier = <span class="hljs-number">1212</span><br /><span class="hljs-keyword">const</span> signal = <span class="hljs-number">1</span><br /><br /><span class="hljs-keyword">let</span> identity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Identity</span>()<br /><br /><span class="hljs-keyword">await</span> semaphore[<span class="hljs-string">&quot;createGroup(uint256,uint256,address)&quot;</span>](<br />  groupId, merkleTreeDepth, <span class="hljs-variable constant_">ADMIN</span>.<span class="hljs-property">address</span><br />)<br /><br /><span class="hljs-keyword">await</span> semaphore.<span class="hljs-title function_">addMember</span>(groupId, identity.<span class="hljs-property">commitment</span>)<br /><br /><span class="hljs-comment">// generate proof from events</span><br /><br /><span class="hljs-keyword">const</span> group = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Group</span>(groupId, merkleTreeDepth)<br /><br /><span class="hljs-keyword">const</span> events = <span class="hljs-keyword">await</span> semaphore.<span class="hljs-title function_">queryFilter</span>(<br /> semaphore.<span class="hljs-property">filters</span>[<span class="hljs-string">&quot;MemberAdded(uint256,uint256,uint256,uint256)&quot;</span>](groupId)<br />)<br /><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> event <span class="hljs-keyword">of</span> events) {<br />  group.<span class="hljs-title function_">addMember</span>(event.<span class="hljs-property">args</span>.<span class="hljs-property">identityCommitment</span>.<span class="hljs-title function_">toBigInt</span>())<br />}<br /><br />assert.<span class="hljs-title function_">equal</span>(<br />  (<span class="hljs-keyword">await</span> semaphore.<span class="hljs-title function_">getMerkleTreeRoot</span>(groupId)).<span class="hljs-title function_">toBigInt</span>(), <br />  group.<span class="hljs-property">root</span><br />)<br /><br /><span class="hljs-keyword">const</span> fullProof = <span class="hljs-keyword">await</span> <span class="hljs-title function_">generateProof</span>(<br />  identity, <br />  group, <br />  externalNullifier, <br />  signal, {<br />    <span class="hljs-attr">zkeyFilePath</span>: zkeyFilePath,<br />    <span class="hljs-attr">wasmFilePath</span>: wasmFilePath<br />  }<br />)<br /><br /><span class="hljs-comment">// ---</span><br /><br /><span class="hljs-keyword">const</span> transaction = <span class="hljs-keyword">await</span> semaphore.<span class="hljs-title function_">verifyProof</span>(<br />  groupId,<br />  fullProof.<span class="hljs-property">merkleTreeRoot</span>,<br />  fullProof.<span class="hljs-property">signal</span>,<br />  fullProof.<span class="hljs-property">nullifierHash</span>,<br />  fullProof.<span class="hljs-property">externalNullifier</span>,<br />  fullProof.<span class="hljs-property">proof</span><br />)<br /><br /><span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(transaction)<br />  .<span class="hljs-property">to</span>.<span class="hljs-title function_">emit</span>(semaphore, <span class="hljs-string">&quot;ProofVerified&quot;</span>)<br />  .<span class="hljs-title function_">withArgs</span>(<br />    groupId, <br />    fullProof.<span class="hljs-property">merkleTreeRoot</span>, <br />    fullProof.<span class="hljs-property">nullifierHash</span>, <br />    fullProof.<span class="hljs-property">externalNullifier</span>, <br />    fullProof.<span class="hljs-property">signal</span><br />  )</span></pre><p name="5cb6" id="5cb6" class="graf graf--p graf-after--pre">The Semaphore smart contract is deployed in the first row. This is a general contract on which we can create multiple different groups, so it is sufficient to deploy only one smart contract that can be used for all applications without the need for a separate contract for each application.</p><p name="de5a" id="de5a" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">Group</code>is created using the <code class="markup--code markup--p-code">createGroup</code>function of the smart contract. Its three parameters are the unique groupId, the depth of the Merkle tree, and the Ethereum address of the group administrator.</p><p name="2af0" id="2af0" class="graf graf--p graf-after--p">We can add a new element to the Merkle tree using the <code class="markup--code markup--p-code">addMember</code>method of the contract, just like in the off-chain solution.</p><p name="85d1" id="85d1" class="graf graf--p graf-after--p">Generating a Merkle proof is more complex than in the off-chain case, as here we first need to query the blockchain to find out what members are in the group. This can be done by querying the <em class="markup--em markup--p-em">MemberAdded</em> events. This way, we can build the Merkle tree locally using the <code class="markup--code markup--p-code">Group</code>class, and then generate the zero-knowledge proof similar to the off-chain example.</p><p name="743c" id="743c" class="graf graf--p graf-after--p">The proof can be verified by calling the <code class="markup--code markup--p-code">verifyProof</code>method in the smart contract. If the proof is incorrect, the method will throw an <em class="markup--em markup--p-em">InvalidProof</em> error, and if it is valid, it will generate a <em class="markup--em markup--p-em">ProofVerified</em> event. If the <code class="markup--code markup--p-code">verifyProof</code>method is used within a smart contract to validate the proof, it is sufficient to call it without checking the return value, as the execution will stop if the proof is invalid.</p><p name="ad6e" id="ad6e" class="graf graf--p graf-after--p">In a nutshell, this is what I wanted to write about the Semaphore protocol. I hope this article will assist in understanding its function, and that many of you will be able to utilize it in your future projects.</p><h4 name="25a6" id="25a6" class="graf graf--h4 graf-after--p"><a href="https://plainenglish.io" data-href="https://plainenglish.io" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">PlainEnglish.io</a> üöÄ</h4><p name="5f9d" id="5f9d" class="graf graf--p graf-after--h4"><em class="markup--em markup--p-em">Thank you for being a part of the In Plain English community! Before you go:</em></p><ul class="postList"><li name="e00f" id="e00f" class="graf graf--li graf-after--p"><em class="markup--em markup--li-em">Be sure to </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">clap</em></strong><em class="markup--em markup--li-em"> and </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">follow</em></strong><em class="markup--em markup--li-em"> the writer</em></li><li name="ebda" id="ebda" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Learn how you can also </em><a href="https://plainenglish.io/blog/how-to-write-for-in-plain-english" data-href="https://plainenglish.io/blog/how-to-write-for-in-plain-english" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">write for In Plain English</em></strong></a><strong class="markup--strong markup--li-strong">Ô∏è</strong></li><li name="5cba" id="5cba" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Follow us: </em><a href="https://twitter.com/inPlainEngHQ" data-href="https://twitter.com/inPlainEngHQ" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">X</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em"> | </em></strong><a href="https://www.linkedin.com/company/inplainenglish/" data-href="https://www.linkedin.com/company/inplainenglish/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">LinkedIn</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em"> | </em></strong><a href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" data-href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">YouTube</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em"> | </em></strong><a href="https://discord.gg/in-plain-english-709094664682340443" data-href="https://discord.gg/in-plain-english-709094664682340443" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Discord</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em"> | </em></strong><a href="https://newsletter.plainenglish.io/" data-href="https://newsletter.plainenglish.io/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Newsletter</em></strong></a></li><li name="aeba" id="aeba" class="graf graf--li graf-after--li graf--trailing"><em class="markup--em markup--li-em">Visit our other platforms: </em><a href="https://stackademic.com/" data-href="https://stackademic.com/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Stackademic</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em"> | </em></strong><a href="https://cofeed.app/" data-href="https://cofeed.app/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">CoFeed</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em"> | </em></strong><a href="https://venturemagazine.net/" data-href="https://venturemagazine.net/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Venture</em></strong></a></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/1a63126de81c"><time class="dt-published" datetime="2023-11-12T22:20:27.907Z">November 12, 2023</time></a>.</p><p><a href="https://medium.com/@thebojda/zero-knowledge-group-membership-management-with-the-semaphore-protocol-1a63126de81c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 27, 2023.</p></footer></article></body></html>