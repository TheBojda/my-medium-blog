<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Writing decentralized applications in JavaScript — libp2p basics</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Writing decentralized applications in JavaScript — libp2p basics</h1>
</header>
<section data-field="subtitle" class="p-summary">
Libp2p is one of the most known p2p libraries. It is the base of the Interplanetary Filesystem and it will be the base of Ethereum 2.0, so…
</section>
<section data-field="body" class="e-content">
<section name="365f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="cbc2" id="cbc2" class="graf graf--h3 graf--leading graf--title">Writing decentralized applications in JavaScript — libp2p basics</h3><figure name="4dc1" id="4dc1" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*9AuA85p_yVe-6lZYTw9K_A.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*9AuA85p_yVe-6lZYTw9K_A.png"><figcaption class="imageCaption">Source: <a href="https://discuss.libp2p.io/" data-href="https://discuss.libp2p.io/" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://discuss.libp2p.io/</a></figcaption></figure><p name="8970" id="8970" class="graf graf--p graf-after--figure"><a href="https://libp2p.io/" data-href="https://libp2p.io/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Libp2p</a> is one of the most known p2p libraries. It is the base of the <a href="https://ipfs.io/" data-href="https://ipfs.io/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Interplanetary Filesystem</a> and it will be the base of <a href="https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md" data-href="https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Ethereum 2.0</a>, so it is a very good choice if you want to develop decentralized applications. In this article, I will show the basic conceptions of libp2p and we will develop a minimalistic browser-based (no own server needed) chat application using the JavaScript implementation of libp2p and vue.js.</p><h4 name="471b" id="471b" class="graf graf--h4 graf-after--p">PeerId</h4><p name="70e1" id="70e1" class="graf graf--p graf-after--h4"><a href="https://docs.libp2p.io/concepts/peer-id/" data-href="https://docs.libp2p.io/concepts/peer-id/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">PeerId</a> is one of the main elements of libp2p. It is something like a BitCoin or Ethereum address that is generated from the public key part of a keypair. Like a BitCoin address, it is unique and can be used to sign a message by the private key that can be validated by the public key that is associated with the peerId. You can generate a peerId by the <a href="https://www.npmjs.com/package/peer-id" data-href="https://www.npmjs.com/package/peer-id" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">peer-id</a> utility.</p><p name="5b51" id="5b51" class="graf graf--p graf-after--p">You can simply install peer-id by npm:</p><pre name="e2fc" id="e2fc" class="graf graf--pre graf-after--p">sudo npm i peer-id -g</pre><p name="cf1a" id="cf1a" class="graf graf--p graf-after--pre">After the installation, you can simply generate your very own peer-id by the peer-id CLI tool:</p><pre name="579c" id="579c" class="graf graf--pre graf-after--p">peer-id<br>{</pre><pre name="a9a3" id="a9a3" class="graf graf--pre graf--startsWithDoubleQuote graf-after--pre">“id”: “QmPMKmmRyepsh4Wq24msEdeGJQWSszy7eWNSjL53bxz3sS”,</pre><pre name="4535" id="4535" class="graf graf--pre graf--startsWithDoubleQuote graf-after--pre">“privKey”: “CAASqAkwggSkAgEAAoIBAQC6/4DQXtW9HYbx5wPNbcsNbwMITH8Mg70O+zhQ9t9w/9Z7BuOzwQqu/ABaRclkl1FIuGfIayKSzqkczYkdY3I6bMUtn8dyHuJi1JzJj5PtaGfK81ra6hNvkVRqttYKJdgpPdGWCa6ouRbFPf3l0w2sK0ejf1Im/h4bAL1ltgZK7G+fXZTlUdAoEvQJja3bl9b47zqWiq+oVaez7uBhemrJQ6Ao09Tlr/RpVfbsc48NAczuDqh9nZzUq27LQEu9OXOf6xk/hPaDcof0ubQs9REXDCcDq01Cg6dQ5odKKHcT9hTeytZlvzfZZgleU8pME9r1EVpG5aEMn5qC0zfoe3PTAgMBAAECggEAWBoa+ZFEyHYJ5xy9WOMaoLilyBoqXZ4Py+gmj1bQzS9sQMhtLXqM6waFsAJjMUZtoIJpOy7muh4t5QkdScBZyBcJC0bVM/pDFOcw+3Hu8xKWnDLtomhYQd9J04FS9LMB1eRvQ25KYOnbRZDAd7BpJ624cdqBvSdKzdQaZ7pL2q4d/P1DUVLVfNDHzHlHyiLoxL1Ilm5YQtGGA3PwTLmSMqWGPvrzK4n0qL2rXUMbio0wf7w3lWDnBNQpncwdcPqUSTPDItwa2GNImH5yZRIF/vP2Qdky7LvNoxIzr+UhyQ6s2YSfRLwgnSPNL4IRuRaUWCtFprdaMd/x65xkBDVP2QKBgQDqXV922hbpMWgGPUco0uv7C8UApWiA/TP95pDzJuoD/SL0pn15QQrPMYTbOf32DrwC/sVMuuIbStqJd8RSApTsQO48KiPgmJM6WgD35umlYpmPQh8djvhPTe3nCadoxy+40i7NuuDde9AtvDlqwti4t1E/6lnYNZecbrXnT3ELZwKBgQDMQryboWcrUS+pfrJADtNiBOBtAAIQz7aHZRmk9ZFY7L8ekSB1Cuee4/FXswkrie+jE1rGbV97OQ1f6qW10SkoN64OIs8AVx408MxLdEejLg0vLwjEqEVXE2Wc1/TkOuEOpsrniKgisIZThrdC2RhmOqtaKRnAWz761ypCluP8tQKBgQCzqzV+Zh9eUpQPBHdDIr/qS9GRdz0wdeyf31yMK+8Hc86Sg/h5NpXU1X+mmUTKl+0m1q3m7vZcOfxjmr+Up4oHvJdm5F9w1Uc5WrqXUh0Yvwg+PVChVnOiSHnzvwDqYJmDNQ7QhU3SPhMQnNXftNR0d4UAXObXy+4Y7P7i/5IITQKBgQCtIxh6Frq7lep/kjwHXknA+P8+hVY658YBSCoPkHOuW6a4gy1u6FpibTZCLyjjtdzhbuNv9H+NlFOI7P2fevaW93Na2hh6Yl3hZAbXIm4inENirkyRXUzBPVjRNKCI4HuqDqlIzqYuGVES9crbJ+etp6ddGh+Q1AczWjShEwOXTQKBgF2cuW8w7ghAXapb2BKQU9bZTMAevohw6cxEmajNngVGSGMQJIJdhEoaGUXdtBOpOxAfYdycegf9VkPraVERXAbCMDk5mAh4Aor1SsHUDnQ7VKMLQfGzH3Jfk2TpXqy/11rJlLAl05LCyAeHGLVM4CQrvpLOIeM5n6j/3QWO3Jdh”,</pre><pre name="7375" id="7375" class="graf graf--pre graf--startsWithDoubleQuote graf-after--pre">“pubKey”: “CAASpgIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC6/4DQXtW9HYbx5wPNbcsNbwMITH8Mg70O+zhQ9t9w/9Z7BuOzwQqu/ABaRclkl1FIuGfIayKSzqkczYkdY3I6bMUtn8dyHuJi1JzJj5PtaGfK81ra6hNvkVRqttYKJdgpPdGWCa6ouRbFPf3l0w2sK0ejf1Im/h4bAL1ltgZK7G+fXZTlUdAoEvQJja3bl9b47zqWiq+oVaez7uBhemrJQ6Ao09Tlr/RpVfbsc48NAczuDqh9nZzUq27LQEu9OXOf6xk/hPaDcof0ubQs9REXDCcDq01Cg6dQ5odKKHcT9hTeytZlvzfZZgleU8pME9r1EVpG5aEMn5qC0zfoe3PTAgMBAAE=”</pre><pre name="0767" id="0767" class="graf graf--pre graf-after--pre">}</pre><p name="c8b7" id="c8b7" class="graf graf--p graf-after--pre">Calling peer-id will generate a JSON with the private and the public key, and the id which is a multihashed public key. This id is your unique peer address.</p><h4 name="9cba" id="9cba" class="graf graf--h4 graf-after--p">Multihash</h4><p name="5f11" id="5f11" class="graf graf--p graf-after--h4"><a href="https://docs.libp2p.io/reference/glossary/#multihash" data-href="https://docs.libp2p.io/reference/glossary/#multihash" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Multihash</a> is a future-proof hashing format that is used by libp2p and IPFS. It is built from 2 parts. The first 2 characters are the hash header that defines the hashing algorithm, and the second part is the hash itself. In the above example (in the id part of the peerId JSON) Qm means it is an SHA-256 hash and the second part is the base58 encoded 256 bits hash.</p><h4 name="2984" id="2984" class="graf graf--h4 graf-after--p">Multiaddress</h4><p name="b877" id="b877" class="graf graf--p graf-after--h4"><a href="https://docs.libp2p.io/reference/glossary/#multiaddr" data-href="https://docs.libp2p.io/reference/glossary/#multiaddr" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Multiaddress</a> is something like an HTTP URL, but it’s more general. A multiaddr is a list of protocol/value pairs that can point to a host, a service, a peer, etc. Let’s see some examples:</p><p name="fd2d" id="fd2d" class="graf graf--p graf-after--p">/ip4/1.2.3.4 — this multiaddr points to a host</p><p name="96bc" id="96bc" class="graf graf--p graf-after--p">/ip4/1.2.3.4/tcp/80 — this points to TCP port 80 of the host</p><p name="569d" id="569d" class="graf graf--p graf-after--p">/dns4/example.com/udp/123 — this points to the UDP port 123 of example.com</p><p name="7ccf" id="7ccf" class="graf graf--p graf-after--p">/p2p/QmbEKwwsuzArDenmWJfcFgyQ8uATQrmkjAsaT8VaGocV1x — this points to a peerId</p><p name="42f2" id="42f2" class="graf graf--p graf-after--p">/ip4/7.7.7.7/tcp/4242/p2p/QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N — this multiaddr exactly points to a host and a TCP port where we can communicate to the given peer</p><p name="0ce5" id="0ce5" class="graf graf--p graf-after--p">Now we know the basics, let’s go forward to the implementation. Libp2p is a modular network stack with many implementations. In this article, I will use the JavaScript implementation that can run on the server-side in node.js or in your browser. Let’s see some code to understand how js-libp2p works:</p><pre name="f403" id="f403" class="graf graf--pre graf--startsWithSingleQuote graf-after--p">‘use strict’<br>const Libp2p = require(‘libp2p’)<br>const TCP = require(‘libp2p-tcp’)<br>const { NOISE } = require(‘@chainsafe/libp2p-noise’)<br>const createNode = async () =&gt; {<br>  const node = await Libp2p.create({<br>    addresses: {<br>      listen: [‘/ip4/0.0.0.0/tcp/4321’]<br>    },<br>    modules: {<br>      transport: [ TCP ],<br>      connEncryption: [ NOISE ]<br>    }<br>  })<br>  await node.start()<br>  return node<br>}</pre><p name="567d" id="567d" class="graf graf--p graf-after--pre">The above example shows how can we start a libp2p node. The Libp2p.create method has two options here. The first is the address where the node will listen. In this case, the node will listen on every IP address and on 4321 port. The second option is the definitions of the modules. Libp2p is a strongly modular stack. Every module is defined by an interface, and you can freely choose which one would you use, or you can create your own modules. Every part of the stack is modular. You can define the transport layer, the encryptions, you can define your own peer discovery mechanism, etc. In this case, we will use TCP transport and NOISE encryption.</p><p name="05b8" id="05b8" class="graf graf--p graf-after--p">The above code works fine in node.js, but in a web browser, it’s not possible to open server ports. To solve this problem, libp2p can use relay servers that can open the required server ports and forward the traffic to the browser.</p><pre name="b761" id="b761" class="graf graf--pre graf-after--p">this.libp2p = await Libp2p.create({<br>  addresses: {<br>    listen: [<br>     &quot;/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star&quot;,<br>     &quot;/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star&quot;,<br>    ],<br>  },<br>  modules: {<br>    transport: [Websockets, WebRTCStar],<br>    connEncryption: [NOISE],<br>    streamMuxer: [Mplex],<br>    peerDiscovery: [Bootstrap],<br>    dht: KadDHT,<br>  },<br>  config: {<br>    peerDiscovery: {<br>      [Bootstrap.tag]: {<br>      enabled: true,<br>      list: [<br>&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN&quot;,<br>&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb&quot;,<br>&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp&quot;,<br>&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa&quot;,<br>&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt&quot;,<br>      ],<br>      },<br>    },<br>    dht: {<br>      enabled: true,<br>    },<br>  },<br>});</pre><p name="45cc" id="45cc" class="graf graf--p graf-after--pre">This more complex example uses the wrtc-star1.par.dwebops.pub and wrtc-star2.sjc.dwebops.pub servers as relays through the webrtc protocol. These servers are provided by the libp2p community, only for testing. If you building a real-world application, you should <a href="https://github.com/libp2p/js-libp2p-webrtc-star/blob/master/DEPLOYMENT.md" data-href="https://github.com/libp2p/js-libp2p-webrtc-star/blob/master/DEPLOYMENT.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">install your own webrtc star servers</a>.</p><p name="0d33" id="0d33" class="graf graf--p graf-after--p">Another new thing is the bootstrap nodes. These nodes are the starting point of peer discovery. When your node starts, it will connect to these nodes firstly. After the connection, our node will get other nodes addresses that are also connected to the bootstrap nodes, and it will connect some of them, so after the bootstrap, the bootstrap nodes are not needed anymore, the p2p network builds automatically. The bootstrap nodes in the example are also provided by the libp2p community. By defining different bootstrap nodes, you can define your own, separated p2p networks.</p><p name="e181" id="e181" class="graf graf--p graf-after--p">The last thing that I want to talk about is the DHT. <a href="https://en.wikipedia.org/wiki/Distributed_hash_table" data-href="https://en.wikipedia.org/wiki/Distributed_hash_table" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Distributed Hash Table</a> is a distributed key/value store that is stored on the nodes. This key/value store is used to store the current internet address of the peerId. It is something like the DNS system, where the DNS servers store the IP addresses for the domain names. DNS is also distributed like the DHT, but in this case, we use the peerId instead of the domain and the endpoint’s multiaddress instead of the IP.</p><pre name="7747" id="7747" class="graf graf--pre graf-after--p">let peerId = PeerId.parse(this.otherPeerId);<br>let result = await this.libp2p.peerRouting.findPeer(peerId);<br>this.otherPeerMultiaddrs = result.multiaddrs;</pre><p name="035b" id="035b" class="graf graf--p graf-after--pre">The above example shows, how can you find a peer by its peerId. The peerRouting module’s findPeer method tries to discover the peer by the peerId and if it finds it the multiaddress will be available in the result.</p><p name="1935" id="1935" class="graf graf--p graf-after--p">Now we can start our own nodes in the browser, and find other peers. The next step is communicating with them.</p><p name="5306" id="5306" class="graf graf--p graf-after--p">First of all, we have to define a protocol and handle the incoming connections. It is something like open a server port in a traditional client-server application.</p><pre name="495e" id="495e" class="graf graf--pre graf-after--p">this.libp2p.handle(&#39;/chat/1.0.0&#39;, <br>  ({ connection, stream, protocol }) =&gt; { <br>    this.remotePeerId = connection.remoteAddr.getPeerId(); <br>    pipe( <br>      stream, <br>      (source) =&gt; { <br>        return (async function* () { <br>         for await (const buf of source) <br>           yield array2str(buf.slice()); <br>        })(); <br>      }, <br>      async (source) =&gt; { <br>       for await (const msg of source) { <br>        this.messages.push(“&gt; “ + msg); <br>       } <br>      } <br>    ); <br>});</pre><p name="a733" id="a733" class="graf graf--p graf-after--pre">The above code defines the ‘chat/1.0.0’ (this is the standard format of a protocol) protocol and handles the incoming connections to it. The handler function has 3 parameters where the 2. is the most important, the incoming stream. JavaScript streams are very tricky things, but hopefully, there are some nice tools to handle them. In this example, we are using the pipe function. The first parameter of the pipe is a stream and the last is a consumer. The middle parameters can be stream transformers. In our case, we transform the stream elements by the array2str function because the stream is binary and we need simple UTF8 strings. The last function (the consumer) simply read the messages from the stream and write them out.</p><p name="febb" id="febb" class="graf graf--p graf-after--p">Now we have nodes in the browser that can find each other, and we have a chat protocol handler. The last step is connecting from one peer to another, and send some messages on the chat protocol.</p><pre name="1c85" id="1c85" class="graf graf--pre graf-after--p">const { stream, protocol } = await this.libp2p.dialProtocol( <br>  peerId, chatProtocol <br>); <br>this.chatQueue = pushable(); <br>pipe( <br>  this.chatQueue, <br>  (source) =&gt; { <br>    return (async function* () { <br>      for await (const msg of source) yield str2array(msg); <br>    })(); <br>  }, <br>  stream <br>);</pre><p name="cc54" id="cc54" class="graf graf--p graf-after--pre">Libp2p has a dialProtocol method for connecting other peers. The method has 2 parameters. The target peerId and the protocol identifier. The result of the method is a stream, so we use the pipe function again. The first parameter of the pipe is a pushable. Pushable is a queue that can be read as a stream. We will push the chat messages to this queue. The second stage of the pipe is a transformer that calls str2array to convert the string messages to binary form. The last stage of the pipe is the stream itself.</p><p name="427f" id="427f" class="graf graf--p graf-after--p">Let’s see the full code. I’ve used Vue, cause it is compact and easy to read.</p><figure name="d8c3" id="d8c3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/TheBojda/e201e9f9805edb032a7fdb3006c2ce96.js"></script></figure><p name="02c2" id="02c2" class="graf graf--p graf-after--figure">You can test it online on <a href="https://thebojda.github.io/js-libp2p-browser-chat/index.html" data-href="https://thebojda.github.io/js-libp2p-browser-chat/index.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://thebojda.github.io/js-libp2p-browser-chat/index.html</a>. Open this URL on 2 browser tabs. Copy the one tab’s peerId to the other tab and push the ‘Find’ button. If everything goes well, the browser node will find the other node in the other tab. Then push ‘Dial protocol’ button and you can start chatting between the two tabs.</p><p name="480a" id="480a" class="graf graf--p graf-after--p graf--trailing">Libp2p is the basis of many p2p applications. I hope, this short introduction will help you to start developing your own p2p applications (maybe a new sharing economy application, or your very own new blockchain). So, let’s coding…</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/4fa46c5dae8a"><time class="dt-published" datetime="2021-09-05T10:39:23.400Z">September 5, 2021</time></a>.</p><p><a href="https://medium.com/@thebojda/writing-decentralized-applications-in-javascript-libp2p-basics-4fa46c5dae8a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 9, 2021.</p></footer></article></body></html>